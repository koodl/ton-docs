# Блокчейн блокчейнов

:::tip
Термины '**Smart contract**', '**account**' и '**actor**' используются взаимозаменяемыми в этом документе для описания сущности блокчейна.
:::

## Одиночный актер

Давайте рассмотрим один умный контракт.

В TON это _thing_ со свойствами, такими как `address`, `code`, `data`, `balance` и другие. Другими словами, это объект, который имеет _storage_ и _behavior_.
Это поведение имеет следующую структуру:

- что-то происходит (наиболее распространенная ситуация заключается в том, что договор получает сообщение)
- контракт обрабатывает это событие в соответствии со своими собственными свойствами, выполнив свой `code` в виртуальной машине TON.
- контракт изменяет свои свойства («код», «данные» и другие)
- контракт опционально генерирует исходящие сообщения
- договор вступает в режим ожидания до следующего события

Комбинация этих шагов называется **транзакция**. Важно, чтобы события обрабатывались один за другим, поэтому _транзакции_ строго упорядочены и не могут прерывать друг друга.

Этот шаблон поведения хорошо известен и называется «Актер».

### Самый низкий уровень: Цепочка клиента

Последовательность _транзакций_ `Tx1 -> Tx2 -> Tx3 -> ....` можно назвать **цепи**. И в рассматриваемом случае **AccountChain** следует подчеркнуть, что это _цепочка_ одного счета транзакций.

Теперь, поскольку узлы, которые обрабатывают транзакции время от времени должны координировать состояние смарт-контракта (для достижения _консенсуса_ о состоянии) эти _транзакции_ пакеты:
`[Tx1 -> Tx2] -> [Tx3 -> Tx4 -> Tx5] -> [] -> [Tx6]`.
Пакетное объединение не вмешивается в последовательность, каждая транзакция все еще имеет только одну предыдущую транзакцию и не более одну «следующую tx», но теперь эта последовательность разделена на **блоки**.

Также целесообразно включать очереди входящих и исходящих сообщений в _blocks_. В этом случае _block_ будет содержать полный набор информации, который определяет и описывает, что случилось с смарт-контрактом во время этого блока.

## Многие цепочки клиентов: Фрагменты

Теперь рассмотрим много аккаунтов. Мы можем получить несколько _AccountChains_ и хранить их вместе, такой набор _AccountChains_ называется **ShardChain**. Таким же образом мы можем вырезать **ShardChain** на **ShardBlocks**, которые представляют собой совокупность индивидуальных _AccountBlocks_.

### Динамическое разделение и слияние Осколков

Заметьте, что в _ShardChain_ легко отличить _AccountChains_, мы можем его легко разделить. Таким образом, если у нас 1 _ShardChain_ описывает события, происходящие с 1 миллионом аккаунтов, и транзакций в секунду слишком много для обработки и хранения в одном узле, так что мы просто делим (или **split**) цепочку на две меньшие _ShardChains_ с каждой цепочкой на полмиллиона аккаунтов и каждая цепочка обрабатывается на отдельной подгруппе узлов.

Аналогично, если осколки стали слишком незанятыми, они могут быть **объединены** в один большой осколк.

Очевидно, что существует два ограниченных случая: когда шард содержит только один аккаунт (и, следовательно, не может быть разделен далее) и когда шард содержит все аккаунты.

Аккаунты могут взаимодействовать друг с другом, отправляя сообщения. Существует специальный механизм маршрутизации, который перемещает сообщения из исходящих очереди в соответствующие входящие очереди и обеспечивает 1) все сообщения будут доставлены2) сообщения будут доставлены последовательно (ранее отправленное сообщение достигнет места назначения).

:::info ПРИМЕЧАНИЕ
Для разделения и слияния детерминированных систем агрегация AccountChains на шарды основана на бит-представлении адресов счета. Например, адрес выглядит как `(префикс шарда, адрес)`. Таким образом, все учетные записи в shardchain будут иметь одинаковый двоичный префикс (например, все адреса будут начинаться с `0b00101`).
:::

## Блокчейн

Агрегация всех шардов, содержащих все аккаунты по одному набору правил, называется **Блокчейн**.

В TON может быть много наборов правил и, таким образом, много блокчейнов, которые работают одновременно и могут взаимодействовать друг с другом, отправляя сообщения перекрестным способом, таким образом, что учетные записи одной цепочки могут взаимодействовать друг с другом.

### Сеть работ: Блокчейн с вашими правилами

Если вы хотите настроить правила группы Shardchains, вы можете создать **Workchain**. Хорошим примером является создание рабочей цепи, которая работает на основе EVM для управления смарт-контрактами Solidity.

Теоретически каждый человек в сообществе может создать свою производственную цепочку. На самом деле, это довольно сложная задача построить ее, после этого заплатить (дорогую) цену создания и получить 2/3 голосов от валидаторов утвердить создание вашей Workchain.

TON позволяет создать цепочки рабочих процессов `2^32`, которые подразделяются на `2^60`.

Сегодня в TON: MasterChain и BaseChain.

BaseChain используется для ежедневных транзакций между субъектами, потому что это довольно дешево, в то время как у MasterChain есть важнейшая функция для TON, поэтому давайте покроем что это делает!

### Шедевраль: Блокчейн блокчейнов

Существует необходимость в синхронизации маршрутизации сообщений и выполнения транзакций. Другими словами, узлам сети нужен способ исправить некоторую "точку" в многоканальном состоянии и достичь консенсуса по этому состоянию. В ТОН для этой цели используется специальная цепь **MasterChain**. Блоки _masterchain_ содержат дополнительную информацию (последние хэши блоков) обо всех других цепочках в системе, Таким образом, любой наблюдатель однозначно определяет состояние всех многоканальных систем на одном блоке шедевров.
