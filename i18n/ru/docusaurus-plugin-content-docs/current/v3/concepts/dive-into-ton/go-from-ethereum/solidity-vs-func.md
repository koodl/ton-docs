# Солидарность против FunC

Умная разработка контрактов включает использование предопределенных языков, таких как Solidity for Ethereum, и FunC for TON.
Солидарность является объектно-ориентированным, высокоуровневым языком, на котором влияют C++, Python и JavaScript, и специально разработан для написания смарт-контрактов, выполняемых на платформах блокчейн Ethereum.

Кроме того, FunC является высокоуровневым языком, используемым для программирования смарт-контрактов на TON Blockchain, будучи специфичным для домена, C-схожим, статистическим типом языка.

В нижеследующих разделах будут кратко проанализированы следующие аспекты этих языков, т.е. типы данных, хранение, функции, структуры управления потоками и словари (хэшкарты).

## Расположение хранилища

Solidity обеспечивает модель плоского хранения, что означает, что все переменные состояний хранятся в едином, непрерывном блоке памяти, называемом памятью. Хранилище - это хранилище ключевого значения, где каждое целое число ключей составляет 256-битное (32-байт), представляющее номер слота хранения, и каждое значение - это 256-битное слово, хранящееся в этом слоте. Слоты нумеруются последовательно, начиная с нуля, и каждый слот может хранить одно слово. Солидарность позволяет программисту указывать макет хранилища с помощью ключевого слова хранилища для определения переменных состояний. Порядок определения переменных определяет их положение в хранилище.

Постоянное хранение данных в TON Blockchain хранится в ячейке. Гены играют роль памяти в ТВ на основе стека. Ген может быть преобразован в ломтик, а затем данные и ссылки на другие ячейки из ячейки можно получить, загрузив их из ломтика. Биты и ссылки на другие ячейки могут храниться в конструкторе, а затем конструктор может быть завершен в новую ячейку.

## Типы данных

Солидарность включает в себя следующие основные типы данных:

- Подписанные/неподписанные целые
- Boolean
- Адреса – используются для хранения адреса Ethereum или смарт-контракта, обычно около 20 байт. Тип адреса может быть суффикс с ключевым словом «оплачиваемый», которая ограничивает хранение только адресов кошельков и использование функций передачи и отправки криптовалют.
- Массивы байтов объявлены с ключевым словом «байт», — это массив фиксированного размера, используемый для хранения предопределенного количества байт до 32, обычно заявленных вместе с ключевым словом.
- Литературы – Неизменяемые значения, такие как адреса, рациональные и целые числа, строки, юникоды и гексадецималы, которые могут храниться в переменной.
- Количество
- Массивы (фиксированные/динамические)
- Структуры
- Сопоставления

В случае FunC основными типами данных являются:

- Целые
- Ячейка – базовая для структуры непрозрачных данных TON, которая содержит до 1023 бит и до 4 ссылок на другие клетки
- Slice and Builder – специальные объекты для чтения и записи в гены,
- Продолжение – еще один вариант ячейки, который содержит готовый к исполнению байт-код TVM
- Тройки – это упорядоченная коллекция до 255 компонентов, имеющих произвольные типы значений, возможно отличающихся.
- Тенсоры – это упорядоченная коллекция, готовая к массовому назначению: (int, int) a = (2, 4). Особый случай растяжения - тип единицы (). Это означает, что функция не возвращает ни одного значения или не имеет аргументов.

В настоящее время FunC не поддерживает определение пользовательских типов.

### Смотреть также

- [Statements](/v3/documentation/smart-contracts/func/docs/statements)

## Объявление и использование переменных

Солидарность представляет собой статически типизированный язык, что означает, что тип каждой переменной должен быть указан, когда она объявлена.

```js
uint test = 1; // Объявление незнакомой переменной целого типа
bool isActive = true; // Логическая переменная
имя строки = "Alice"; // Строковая переменная
```

FunC - более абстрактный и функциональный язык, поддерживает динамическое типирование и стиль программирования.

```func
(int x, int y) = (1, 2); // Объявление динамических переменных с двумя целыми переменными
var z = x + ; // Объявление динамической переменной 
```

### Смотреть также

- [Statements](/v3/documentation/smart-contracts/func/docs/statements)

## Циклы

Солидарность поддерживает `for`, `while`, и \`do { ... Циклы while}.

Если вы хотите что-то сделать 10 раз, вы можете сделать это так:

```js
uint x = 1;

for (uint i; i < 10; i++) {
    x *= 2;
}

// x = 1024
```

FunC в свою очередь поддерживает `repeat`, `while`, и `do { ... } циклов until. Цикл для позиции не поддерживается. Если вы хотите выполнить тот же код, что и в примере выше в Func, вы можете использовать `повторить\`

```func
int x = 1;
repeat(10) {
  x *= 2;
}
;; x = 1024
```

### Смотреть также

- [Statements](/v3/documentation/smart-contracts/func/docs/statements)

## Функции

Объявления о солидарных подходах сочетаются с ясностью и контролем. На этом языке программирования каждая функция инициируется с помощью ключевого слова "функция", за которым следует название функции и ее параметры. Состав этой функции заключен в фигурные скобки, четко определяющие операционные рамки. Кроме того, возвращаемые значения указываются при помощи ключевого слова «возвраты». Разделяя солидарность, можно назвать ее функциями "публичные", "частные", "внутренний", или "внешних", с учетом условий, при которых они могут быть доступны и вызваны другими частями контракта или внешними субъектами. Ниже приведен пример, в котором мы устанавливаем глобальную переменную «num» на языке солидарности:

```js
function set(uint256 _num) public returns (bool) {
    num = _num;
    return true;
}
```

Переход на FunC, программа FunC по сути представляет собой список декларирований/определений функций и глобальных декларирования переменных. Объявление функции FunC обычно начинается с необязательного декларатора, а затем - с типом возврата и именем функции. Параметры перечислены далее, а объявление заканчивается выбором спецификаторов, таких как `impure`, `inline/inline_ref` и `method_id`. Эти спецификаторы настраивают видимость функции, ее способность изменять хранилища контракта и его поведение. Ниже приведен пример, в котором мы храним переменную как ячейку в постоянном хранилище на языке Func:

```func
() save_data(int num) impure inline {
  set_data(begin_cell()
            .store_uint(num, 32)
           .end_cell()
          );
}
```

### Смотреть также

- [Functions](/v3/documentation/smart-contracts/func/docs/functions)

## Структуры управления потоками

Большинство управляющих структур, известных на языках с фигурными скобками, доступны в солидарности, в том числе: "если", `else`, `while`, `do`, `for`, `break`, `continue`, `return`, с обычной семантикой, известной от C или JavaScript.

FunC поддерживает классические операторы `if-else`, а также циклы `ifnot`, `repeat`, `while` и `do/until`.  Также с версии 0.4.0 поддерживается `try-catch`.

### Смотреть также

- [Statements](/v3/documentation/smart-contracts/func/docs/statements)

## Словари

Структура данных словаря (хэшма/сопоставления) очень важна для разработки контракта Solidity и FunC, так как позволяет разработчикам эффективно хранить и извлекать данные в смарт-контрактах, специфические данные, связанные с конкретным ключом, такие как баланс пользователя или владение активом.

Mapping представляет собой хэш-таблицу в Solidity, которая сохраняет данные как пары ключевой стоимости, где ключ может быть любой из встроенных типов данных, за исключением эталонных типов и значения типа данных могут быть любыми. Привязки обычно используются в Солидарности и блокчейне Ethereum для подключения уникального Ethereum адреса к соответствующему типу ценности. В любом другом языке программирования отображение эквивалентно словарю.

В случае солидарности сопоставления не имеют длины и не имеют понятия установки ключа или ценности. Привязки применимы только к переменным состояний, которые используются в качестве эталонных типов магазина. Когда сопоставления инициализируются, они включают в себя все возможные ключи и сопоставляются со значениями, чьи байт-представления являются всеми нулями.

Аналогом сопоставлений в FunC являются словари или хэшкарты TON. В контексте TON, хэшкарта представляет собой структуру данных, представленную деревом ячеек. Hashmap отображает ключи к значениям произвольного типа, чтобы можно было быстро найти и модифицировать. Абстрактное представление хэшкарты в TVM является патрицией дерева или компактной бинарной трии. Работа с потенциально большими деревьями клеток может создать несколько проблем. Каждая операция обновления строит заметное количество ячеек (каждая из ячеек стоит 500 газа), , что означает, что эти операции могут закончиться ресурсами, если они используются небрежно. Во избежание превышения лимита газа, ограничение количества словарей в одной транзакции. Также двоичное дерево для пар ключей «N» содержит ветки «N-1», что означает как минимум «2N-1». Хранилище смарт-контракта ограничено уникальными клетками `65536`, , поэтому максимальное количество записей в словаре составляет `32768`, или немного больше, если есть повторяющиеся ячейки.

### Смотреть также

- [Словари в TON](/v3/documentation/smart-contracts/func/docs/dictionaries)

## Связь с контрактом

Солидарность и FunC предоставляют различные подходы к взаимодействию с смарт-контрактами. Основное различие заключается в механизмах ссылки на контракты и взаимодействия между ними.

Солидарность использует объектно-ориентированный подход, в рамках которого контракты взаимодействуют друг с другом на основе используемых методов. Это похоже на метод вызовов на традиционных объектно-ориентированных языках программирования.

```js
// Внешний интерфейс внешнего контракта
интерфейс IReceiver {
    function receiveData(uint x) внешний;
}

контракт {
    function sendData(address receiverAddress, uint x) public {
        IReceiver receiver = IReceiver(receiverAddress);
        получатель. eceiveData(x); // Прямой вызов функции контракта
    }
}
```

Система FunC, используемая в экосистеме блокчейна TON, работает по идее сослаться и взаимодействовать между смарт-контрактами. Вместо прямого вызова методов контракты отправляют друг другу сообщения, которые могут содержать данные и код для выполнения.

Рассмотрим пример, когда смарт-отправитель контракта должен отправить сообщение с номером, и смарт-получатель контракта должен получить этот номер и выполнить некоторые манипуляции на нем.

Первоначально получатель смарт-контракта должен описать, как он будет получать сообщения.

```func
() recv_internal(int my_balance, int msg_value, cell in_msg, slice in_msg_body) impure {
    int op = in_msg_body~load_uint(32);
    
    if (op == 1) {
        int num = in_msg_body~load_uint(32);
        ;; сделать некоторые манипуляции
        возврат ();
    }

    if (op == 2) {
        ;. .
    }
}
```

Давайте более подробно обсудим, как получить сообщение в нашем контракте о назначении:

1. `recv_internal()` - эта функция выполняется при наличии контракта непосредственно в блокчейне. Например, при заключении контракта к нашему договору.
2. Функция принимает сумму остатка контракта, сумму входящего сообщения, ячейка с оригинальным сообщением и ломтиком `in_msg_body`, в которой хранится только тело принятого сообщения.
3. Наше тело сообщения будет хранить два целых числа. Первое число - это 32-битное неподписанное целое `op`, определяющее выполненную операцию или «метод» смарт-контракта, который должен быть вызван. Вы можете нарисовать несколько аналогий с Solidity и думать о `op` в качестве подписи функции. Второе число — это число, с которым нам нужно выполнить некоторые манипуляции.
4. Для чтения из результирующего числа `op` и `our number`, мы используем `load_uint()`.
5. Далее мы манипулируем номером (в данном примере мы пропустили эту функцию).

Далее смарт-контракт отправителя - отправить сообщение правильно. Это достигается с помощью send_raw_message\`, который в качестве аргумента ожидает сериализованное сообщение.

```func
int num = 10;
ячейка msg_body_cell = begin_cell().store_uint(1,32).store_uint(num,32). nd_cell();

var msg = begin_cell()
            . tore_uint(0x18, 6)
            . tore_slice("EQBIhPuWmjT7fP-VomuTWseE8JNWv2q7QYfsVQ1IZwnMk8wL"a) ;; в примере мы просто написали адрес получателя
            . tore_coins(0)
            . _tore_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            . tore_ref(msg_body_cell)
        .end_cell();

send_raw_message(msg, mode);
```

Давайте более подробно обсудим, как выглядит наш смарт-контракт, чтобы отправить сообщение получателю:

1. Первоначально нам нужно составить наше послание. The full structure of the send can be found [here](/v3/documentation/smart-contracts/message-management/sending-messages). Мы не будем подробно остановиться на том, как собрать его здесь, вы можете прочитать об этом по ссылке.
2. Тело сообщения представляет собой ячейку. В `msg_body_cell` мы делаем: `begin_cell()` - создаем `Builder` для будущей ячейки, первый `store_uint` - хранит первый uint в `Builder` (1 - это наш `op`), второй `store_uint` - хранит второй uint в `Builder` (num - это наш номер, который мы будем манипулировать в приемном договоре), `end_cell()` - создает ячейку.
3. Чтобы прикрепить тело, которое будет приходить в сообщение `recv_internal`, мы ссылаемся на собранную ячейку в самом сообщении с помощью `store_ref`.
4. Отправка сообщения.

В этом примере показано, как умные контракты могут общаться друг с другом.

### Смотреть также

- [Внутренние сообщения](/v3/documentation/smart-contracts/message-management/internal-messages)
- [Отправка сообщений](/v3/documentation/smart-contracts/message-management/sending-messages)
- [Незагруженные сообщения](/v3/documentation/smart-contracts/message-management/non-bounceable-messages)
