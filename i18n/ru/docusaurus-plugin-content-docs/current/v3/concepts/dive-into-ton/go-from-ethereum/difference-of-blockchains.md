# Различия блокчейнов

В этой главе мы рассмотрим ключевые различия между блокчейном Ethereum по сравнению с блокчейном TON. Этот анализ будет включать обзор сетевых архитектур, освещение их уникальных особенностей и оценку преимуществ и недостатков каждой из них.

начиная с обзора экосистем Ethereum и TON, можно отметить, что обе платформы предлагают аналогичную структуру участников и сервисов, включая пользователей, которые владеют активами и совершают операции, валидаторы, которые поддерживают и обеспечивают безопасность сети, а также разработчики приложений, которые используют блокчейн в качестве основы для своих продуктов и услуг. Обе экосистемы включают как услуги хранения, так и услуги, не связанные с хранением, которые обеспечивают пользователей различными уровнями контроля над их активами.

Кроме того, следует подчеркнуть, что обе платформы облегчают создание децентрализованных приложений (DApps), предлагая разработчикам мощные инструменты и стандарты для разработки.

Однако, несмотря на сходство в общей структуре и предлагаемых чертах, ключевые технологические аспекты и подходы к проектированию сетей Ethereum и TON значительно различаются. Эти различия закладывают основу для глубокого понимания уникальных преимуществ и ограничений каждой платформы, что особенно важно для разработчиков, стремящихся максимально использовать возможности каждой сети. В следующих подразделах мы более подробно изучим эти различия, сосредоточив внимание на сетевой архитектуре, модели, механизмы транзакций и система расчетов по сделкам, чтобы дать разработчикам представление о которых они нужны.

## Архитектура блокчейнов

Ethereum, наследуя и расширяя основополагающие принципы Bitcoin, предоставил разработчикам гибкость, необходимую для создания сложных децентрализованных приложений (DApps). Уникальной особенностью Ethereum является его способность предоставлять каждому аккаунту индивидуальные данные хранилища, позволяя транзакциям не только выполнять трансферты токенов, но и изменять состояние блокчейна, взаимодействуя с смарт-контрактами. Эта возможность синхронного взаимодействия между учетными записями, как мы знаем, дает большие обещания для разработки приложений, но также поднимает проблему масштабируемости. Каждая транзакция в сети Ethereum требует обновления и поддержания полного состояния блокчейна, Это приводит к значительной задержке и увеличивает стоимость газа по мере увеличения загрузки сети.

В ответ на эти вызовы TON предлагает альтернативный подход, направленный на повышение масштабируемости и эффективности. Разработанный с амбициями, чтобы предоставить разработчикам максимальную гибкость для создания различных приложений, TON использует концепцию шардов и шедевров для оптимизации процесса создания блоков. В каждом шардинге TON и шестеренке создается новый блок в среднем каждые 5 секунд, обеспечивая быстрое выполнение транзакции. В отличие от Ethereum, где обновления состояния синхронизируются, TON реализует асинхронные сообщения между смарт-контрактами, позволяет обрабатывать каждую транзакцию самостоятельно и параллельно, значительно ускоряет обработку транзакций в сети. Разделы и статьи для ознакомления с:

- [Shards](/v3/documentation/smart-contracts/shards/shards-intro)
- [Сравнение Blockchains document](https://ton.org/comparison_of_blockchains.pdf)
- [Сравнение таблицы блокчейнов (гораздо меньше информативного документа, но более визуального)](/v3/concepts/dive-into-ton/ton-blockchain/blockchain-comparison)

В заключение, сравнивая архитектуру и технологические основы TON и Ethereum, ясно, что TON обладает значительными преимуществами. инновационный подход к асинхронной обработке транзакций и уникальной архитектуре шарда и шестернга, TON демонстрирует потенциал поддержки миллионов транзакций в секунду без ущерба безопасности или централизации. Это обеспечивает отличную гибкость и эффективность, что делает его идеальным для широкого спектра применений.

## Модель на основе учета (ЭТ) и модель актора (ТЕН)

В первом подразделе мы провели сравнение между Ethereum и TON, подчеркнув их ключевые архитектурные различия и основные задачи, стоящие перед Ethereum. Особо следует отметить различные подходы к организации взаимодействия в этих блокчейнах и использованию моделей. Эти различия обусловлены уникальным архитектурным выбором каждой платформы. Для разработчиков, привыкших к Ethereum, важно глубоко понимать эти различия для эффективного перехода к разработке на TON. Такое понимание позволит архитектуре адаптировать и оптимизировать взаимодействие смарт-контрактов в новой среде.

Итак, давайте помним, как работает модель на базе учетной записи в Ethereum. Ethereum использует эту модель для отслеживания балансов. Как и банковский счет, средства хранятся на счетах, а не в отдельных монетах. Существует два типа счетов:

- Собственные внешние счета (ЭОС) - счета управляемые внешними подрядчиками контролируются пользователем с использованием государственных и частных ключей. Открытый ключ позволяет другим отправлять платежи на счет.
- Аккаунты контрактов - управляются смарт-кодом, а не закрытыми ключами. Поскольку у них нет закрытого ключа, контрактные счета не могут самостоятельно инициировать сделки.

При создании кошелька пользователь Ethereum, внешний счет добавляется в глобальное состояние на всех узлах децентрализованной сети при вызове первой транзакции или получении первых средств. Развертывание смарт-контракта создает контрактный счет, способный хранить и распространять средства программированным образом на основе определенных условий. Все типы счетов имеют балансы, хранилища и могут инициировать транзакции путем вызова функций на других счетах. Эта структура дает Ethereum возможность служить в качестве программируемых денег.

Ethereum имеет синхронную обработку транзакций, где каждая транзакция обрабатывается последовательно в строгом порядке. Это гарантирует, что состояние блокчейна всегда остается неизменным и предсказуемым для всех участников сети. Все транзакции атомарны, либо полностью завершены или полностью завершены неуспешно, без частичного или неполного выполнения. Более того, когда возникает смарт-контракт и в свою очередь вызывает другой смарт-контракт, призыв мгновенно в рамках той же транзакции. Но тут снова есть недостатки, сделка может расти так же, как и ей разрешено расти. Отрицательный эффект синхронизации все еще перезагружается, так как вычисления не могут выполняться параллельно. Количество контрактов и пользователей растет, и неспособность распараллеливать вычисления становится одним из основных ограничивающих факторов в развитии сети.

Теперь давайте поймем, что такое модель персонажа? Модель актора - это подход к параллельным и распределенным вычислениям, где главным элементом является персонаж - независимый исполняемый блок кода. Первоначально разработанная для кластерных вычислений, эта модель широко используется в архитектурах микросерверов для удовлетворения потребностей современных распределенных систем за счет возможности масштабировать, параллелизм и толерантность. Актеры получают и обрабатывают сообщения, в зависимости от логики сообщения, реагировать, приняв локальные изменения или выполняя действия в ответ на него, может создавать других действующих лиц или отправлять сообщения дальше. Они безопасны для резьбы и перегружены, что исключает потребность в замках и упрощает параллельную обработку задач. Эта модель идеально подходит для построения масштабируемых и надежных серверных решений, обеспечивающих эффективное одновременное управление и поддержку как синхронных, так и асинхронных сообщений.

В ТОН все представлено смарт-контрактами, которые также могут называться действующим лицом в контексте модели актера. Умный контракт – это объект со свойствами, такими как адрес, код, данные и баланс. Имеет возможность хранить данные и вести себя в соответствии с инструкциями, полученными от других смарт-контрактов. После заключения контракта получает сообщение и обрабатывает его, выполнив свой код в ТВМ, могут возникнуть различные сценарии:

- Контракт изменяет свойства «код, данные, баланс»
- Контракт по желанию генерирует исходящее сообщение
- Контракт вступает в режим ожидания до следующего события

Результатом скриптов всегда является создание транзакции.  Сами транзакции асинхронны, что означает, что система может продолжать обработку других транзакций в ожидании завершения прошлых транзакций. Это обеспечивает большую гибкость при обработке сложных транзакций. Иногда одна транзакция может потребовать выполнения нескольких смарт-контрактов в определенной последовательности. Поскольку эти вызовы асинхронны, разработчики могут более легко проектировать и реализовывать сложные транзакции, которые могут включать несколько одновременных операций. Разработчику, исходящему из Ethereum, необходимо понимать, что смарт-контракты в блокчейне TON могут общаться только друг с другом, посылая асинхронные сообщения, что означает, что в случае необходимости запроса данных по другому контракту и немедленного ответа это будет невозможно. Вместо этого `get methods` должен вызываться клиентами за пределами сети, так же, как кошелек в Ethereum использует RPC узлы, такие как Infura для запроса состояния смарт-контракта. Это является важным ограничением по нескольким причинам. Например, флеш-займы - это операции, которые должны выполняться в рамках одного блока, полагаясь на возможность заимствования и погашения в той же сделке. Это облегчается синхронным характером Ethereum EVM, но в TON, асинхронный характер всех сделок делает невозможным выполнение срочных кредитов. Также Oracles, обеспечивающие смарт-контракты с внешними данными, требуют более сложного процесса проектирования в TON. Что такое Oracles и как их использовать в TON можно найти [here](/v3/documentation/dapps/oracles/about_blockchain_oracles).

## Разница кошельков

Мы уже обсуждали, что в Ethereum, пользовательский кошелек генерируется на основе их адреса, , который находится в отношениях между 1 и 1 с их общественным ключом. Но в TON, все кошельки являются умными контрактами, которые должны быть развернуты самим пользователем. Так как смарт-контракты могут быть настроены различными способами и иметь различные функции, есть несколько версий кошельков, , который вы можете прочитать о [here](/v3/documentation/smart-contracts/contracts-specs/wallet-contracts). Из-за того, что кошельки являются смарт-контрактами, пользователь может иметь несколько кошельков с разными адресами и исходными параметрами. Чтобы отправить транзакцию, пользователь должен подписать сообщение своим приватным ключом и отправить его на контракт кошелька, , которая в свою очередь направляет его на смарт-контракт определенного приложения DApp. Такой подход значительно увеличивает гибкость при проектировании кошельков, и разработчики могут в будущем добавлять новые версии кошелька. В настоящее время в Ethereum разработчики активно используют мульти-сигнализированные кошельки (смарт-контракты), такие как gnosis и просто начинают внедрять так называемые «account-abstractions», как ERC-4337, где кошельки будут заполнены функционалом, как отправка транзакций без обычного токена, восстановление аккаунта после его потери и т.д. но стоит отметить, что кошельки гораздо дороже использовать с точки зрения платы за газ по сравнению с EOA в Ethereum.

## Сообщения и транзакции

Что происходит между двумя контрактами называется сообщение - небольшое количество токенов и произвольные данные отправляются на указанный адрес. Когда сообщение приходит к контракту, оно обрабатывается в соответствии с кодом контракта, контракт обновляет его состояние и, по желанию, отправляет новое сообщение. Все эти действия по контракту регистрируются как сделки. Давайте представим пример, у нас есть цепочка сообщений, от контракта «A» до контракта «B», - от контракта "B" до контракта "C" - тогда у нас будут два сообщения и три сделки. Но во-первых, чтобы изменить состояние блокчейна, тебе нужен внешний сигнал. Для вызова смарт-контракта Вам необходимо отправить внешнее сообщение, которое направляется валидаторам и применяется к смарт-контракту. И мы уже обсуждали в последнем подразделе, что кошелек является смарт-контрактом, так что это внешнее сообщение обычно сначала отправляется в смарт-контракт кошелька, которая записывает их в качестве первой транзакции и первой транзакции обычно содержит встроенное сообщение для фактического целевого контракта. Когда смарт-контракт кошелька получает сообщение, он обрабатывает его и доставляет его к контракту назначения (например, контракт «A» может быть кошельком и когда он получит внешнее сообщение, он будет иметь первую транзакцию). Последовательность транзакций формирует цепочку. Таким образом, вы можете видеть, что каждый смарт-контракт имеет свои собственные транзакции, что означает, что у каждого контракта есть собственный `little blockchain` (подробнее об этом можно прочитать [here](/v3/concepts/dive-into-ton/ton-blockchain/blockchain-of-blockchains)), чтобы сеть могла обрабатывать транзакции из-за этого совершенно независимо друг от друга

## Разница в газовой системе

В Итоговом документе Ethereum стоимость сделки измеряется в газе, которая отражает сумму вычислительных ресурсов, необходимых для совершения сделки. Стоимость «газа» разделена на «базовую комиссию», установленную протоколом, и «приоритетную», которую добавляет пользователь для ускорения обработки транзакций с помощью валидаторов. "Общая плата" будет = "Единицы используемого газа" \* (базовый сбор + `приоритет`).
Кроме того, хранение в Ethereum по сути свободно, то есть после того, как данные хранятся в блокчейне, не существует постоянных расходов на их сохранение.

В ТОН расчет комиссии за транзакции является сложным и включает в себя несколько видов комиссий: для хранения смарт-контрактов в блокчейне, для импорта сообщений в блокчейн, для выполнения кода на виртуальной машине, для обработки действий после выполнения кода и для отправки сообщений вне TON blockchain. Цена на газ и некоторые другие параметры могут быть изменены путем голосования в основной сети. В отличие от Ethereum, пользователи TON не могут установить цену на газ сами. Кроме того, разработчику необходимо вернуть владельцу оставшиеся средства на газе вручную, в противном случае они останутся заблокированными. Использование хранилища смарт-контрактов также влияет на цену: если смарт-контракт кошелька длительное время не используется, следующая транзакция будет стоить больше.
