# Сериализация канонических ячеек

## Вес ячейки

«Вес» — это характеристика каждой ячейки в дереве клеток, определяемая следующим образом:

- Если ячейка является узлом оставления в дереве ячейки: `weight = 1`;
- Для обычных клеток (без листьев) вес представляет собой сумму: "Вес клеток = вес детей + 1";
- Если ячейка _special_, его вес равно нулю.

Приведенный ниже алгоритм объясняет, как и когда мы присваиваем вес каждой клетке для создания сбалансированного дерева.

## Алгоритм изменения веса

Каждая ячейка - сбалансированное дерево весов и [reorder_cells()](https://github.com/ton-blockchain/ton/blob/15088bb8784eb0555469d223cd8a71b4e2711202/crypto/vm/boc.cpp#L249) метод
переназначения веса на суммарном весе ребенка. Траверский порядок - корни -> дети. Это первый поиск, _видимый_ используемый для сохранения линейности кэша. Это также вызывает пересчет размера хэшей и переиндексации сумки (roots) и каждого дерева, устанавливает новые индексы для пустых ссылок. Однако, переиндексация - это сначала глубина, возможно, есть то, что зависит от этого порядка индексации, так как whitepaper указывает, что это предпочтительно.

Чтобы следить за исходным узлом сериализации клеток, вам следует:

- Во-первых, если вес ячейки не задан (узел при импорте ячейки), мы устанавливаем вес для каждой ячейки `1 + sum_child_weight`, где `sum_child_weight` — сумма весов ее дочернего узла. Мы добавим один так, что листья имеют вес 1.

- Итерация всех корней для каждой корневой ячейки:
  - Проверьте, есть ли у каждого из его ссылок вес меньше `maximum_possible_weight - 1 + ref_index`, разделенный на количество реферов корневой ячейки, чтобы они делились весом родителей равномерно, мы делаем (+ индекс), чтобы убедиться, что язык пропускается к 0 при делении мы всегда получаем математически округлённое число (как для 5 / 3, c++ вернутся 1, но мы хотим 2 здесь)

  - Если некоторые ссылки нарушают это правило, мы добавляем их в список (или более эффективно создавать битрейт, как исходный узел делает), а затем снова поверните его вес в `weight_left / invalid_ref_count`, где `weight_left` является `maximum_possible_weight - 1 - sum_of_valid_refs_weights`. В коде он может выполняться в качестве указа встречной переменной, , который сначала инициализирован в `maximum_possible_weight - 1`, а затем определяется как `counter -= valid_ref_weight`. Так что по сути мы перераспределяем оставшийся вес между этими узлами (баланс их)

- Повторяйте итерацию над корнями:
  - Убедитесь, что новая сумма весов ссылки меньше, чем `maximum_possible_weight`, проверить, стала ли новая сумма меньше веса корневой клетки, и приглушить ее к новой сумме. (если `new_sum < root_cell_weight` установите `root_cell_weight_weight` равный `new_sum`)
  - Если новая сумма больше веса root'а, то она должна быть специальным узлом с нулевым весом. (Увеличить внутренние хэши по количеству хэшей узла)

- Итерация поверх корней снова для каждого корня:
  Если это не специальный узел (если его вес > 0), увеличение количества верхних хэшей по количеству хэшей узла.

- Рекурсивно переиндексировать дерево:
  - Во-первых, мы рассмотрим все корневые ячейки. Если мы не предварительно заходим или не заходим на этот узел раньше, то проверьте все его ссылки рекурсивно для специальных узлов. Если мы найдем специальный узел, мы должны предварительно посетить его перед другими, это означает, что сначала в списке будут приходить потомки специальных узлов (их индексы будут самыми низкими). Затем добавим потомков других узлов (порядок - глубокий -> наивысший). Корни приходят в самом конце списка (у них самые большие индексы). Таким образом, в конце концов мы получаем отсортированный список, где глубже узл, нижний индекс которого у него имеется.

`maximum_possible_weight` — константа 64

## Обозначения

- Специальная ячейка не имеет веса (это 0)

- Убедитесь, что вес при импорте соответствует 8 битам (вес \<= 255)

- Количество внутренних хэшей - сумма количества хэшей всех специальных корневых узлов

- Количество верхних хэшей - сумма количества хэшей всех других корневых узлов (не специальных)
