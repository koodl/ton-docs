# Экзотические Гены

Каждая ячейка имеет свой тип, кодируемый целым числом от 1 до 255.
Ячейка с типом -1 - это "обычная" ячейка, а также все остальные ячейки, называемые "экзотический" или "особый".
Тип экзотической ячейки хранится в виде первых восьми бит данных. Если экзотическая ячейка имеет менее восьми битов данных, она является недействительной.
В настоящее время существует 4 экзотических ячейки:

```json
{
  Перезволенный Филанш: 1,
  Справочник Библиотеки: 2,
  Комплее: 3,
  Обновление Merkle: 4
}
```

### Отрезанная ветка

Ветви - это ячейки, которые представляют удаленные поддеревья клеток.

Они могут иметь уровень `1 <= l <= 3` и содержать ровно `8 + 8 + 256 * l + 16 * l` бит.

Первый байт - это всегда `01` - тип ячейки. Второй - это маска, на уровне сплетенной ветви. Затем идет хэш `l * 32` байт удаленных поддеревьев и после этого `l * 2` байт глубины удаленных поддеревьев.

Уровень 'l' утопленной ячейки можно назвать его индексом De Bruijn, потому что он определяет внешнее подтверждение Меркла или обновление Merkle в ходе строительства, из которого была выведена ветка.

Более высокие хэши урезанных ветвей хранятся в их данных и могут быть получены следующим образом:

```cpp
Hash_i = CellData[2 + (i * 32) : 2 + (i + 1) * 32)]
```

### Ссылка на библиотеку

Библиотечные справочные ячейки используются для использования библиотек в смарт-контрактах.

Они всегда имеют уровень 0, и содержат `8 + 256` биты.

Первый байт всегда `02` - тип ячейки. Следующими 32 байтами являются [Хэш представления](/v3/documentation/data-formats/tlb/cell-boc#standard-cell-representation-hash-calculation) ссылки на библиотечную ячейку.

### Доказательство Меркле

Ячейки Merkle Proof используются для проверки того, что часть данных дерева ячейки принадлежит полному дереву. Этот дизайн позволяет верификатору не хранить весь контент дерева, но при этом он по-прежнему способен проверять содержимое корневым хэшам.

Merkle Proof имеет ровно одну ссылку, а ее уровень `0 <= l <= 3` должен быть `max(Lvl(ref) - 1, 0)`. Эти ячейки содержат ровно `8 + 256 + 16 = 280` бит.

Первый байт - это всегда `03` - тип ячейки. Следующие 32 байта - `Hash_1(ref)` (или `ReprHash(ref)`, если уровень ссылки 0). Следующие 2 байта - глубина удаленного субдерева, который был заменен ссылкой.

Чем выше хэши `Hash_i` из Merkle Proof Cell вычисляются аналогично более высоким хэшам обычной ячейки, но с помощью `Hash_i+1(ref)` используется вместо `Hash_i(ref)`.

### Обновление Merkle

Обновительные ячейки Меркля всегда имеют 2 рефлекса и ведут себя как доказательство для обоих этих ячеек.

Обновление Merkle уровня `0 <= l <= 3` это `max(Lvl(ref1) - 1, Lvl(ref2) - 1, 0)`. Они содержат точно `8 + 256 + 256 + 16 + 16 = 552` биты.

Первый байт всегда `04` - тип ячейки. Следующие 64 байта — `Hash_1(ref1)` и `Hash_2(ref2)` — старый хэш и новый хэш. Затем идет 4 байта с фактической глубиной удаления старого поддерева и удаляет новое поддерево.

## Простой пример проверки проверки

Давайте предположим, что есть ячейка `c`:

```json
24[000078] -> {
	32[0000000F] -> {
		1[80] -> {
			32[0000000E]
		},
		1[00] -> {
			32[0000000C]
		}
	},
	16[000B] -> {
		4[80] -> {
			267[800DEB78CF30DC0C8612C3B3BE0086724D499B25CB2FBBB154C086C8B58417A2F040],
			512[00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000064]
		}
	}
}
```

Но мы знаем только его хэш `44efd0fdfffa8f152339a0191de1e1c5901fdcfe13798af443640af99616b977`, и мы хотим доказать, что ячейка `a` `267[800DEB78CF30DC0C8612C3B3BE0086724D499B25CB2FBBB154C086C8B58417A2F040]на самом деле является частью `c`без получения целого`c\`.
Поэтому мы просим доктора создать Merkle Proof, заменив все ветки, которые нам не интересны с утопленными ветвями ячеек.

Первый потомок `c`, из которого невозможно попасть в `a`, это `ref1`:

```json
32[0000000F] -> {
	1[80] -> {
		32[0000000E]
	},
	1[00] -> {
		32[0000000C]
	}
}
```

Таким образом, проповедник вычисляет свой хэш (`ec7c1379618703592804d3a33f7e120cebe946fa78a6775f6ee2e28d80ddb7dc`), создает утопленную ветку `288[0101EC7C1379618703592804D3A33F7E120CEBE946FA78A6775F6EE2E28D80DDB7DC0002]и заменяет `ref1\` на эту утопленную ветку.

Второй является `512[0000000...00000000064]`, поэтому прослушиватель создает утопленную ветку для замены этой ячейки:

```json
24[000078] -> {
	288[0101EC7C1379618703592804D3A33F7E120CEBE946FA78A6775F6EE2E28D80DDB7DC0002],
	16[000B] -> {
		4[80] -> {
			267[800DEB78CF30DC0C8612C3B3BE0086724D499B25CB2FBBB154C086C8B58417A2F040],
			288[0101A458B8C0DC516A9B137D99B701BB60FE25F41F5ACFF2A54A2CA4936688880E640000]
		}
	}
}
```

Результат Merkle Proof который доказывает, посылает верификатору (нас в этом примере) выглядит так:

```json
280[0344EFD0FDFFFA8F152339A0191DE1E1C5901FDCFE13798AF443640AF99616B9770003] -> {
	24[000078] -> {
		288[0101EC7C1379618703592804D3A33F7E120CEBE946FA78A6775F6EE2E28D80DDB7DC0002],
		16[000B] -> {
			4[80] -> {
				267[800DEB78CF30DC0C8612C3B3BE0086724D499B25CB2FBBB154C086C8B58417A2F040],
				288[0101A458B8C0DC516A9B137D99B701BB60FE25F41F5ACFF2A54A2CA4936688880E640000]
			}
		}
	}
}
```

Когда мы (верификаторы) поймаем ячейку Proof Cell, мы убедимся в том, что ее данные содержат хэш `c`, а затем вычислим `Hash_1` из единственного механизма справки: `44efd0fdfffa8f152339a0191de1e1c5901fdcfe13798af443640af99616b977`, и сравните его с хэшем `c`.

Теперь, когда мы проверили, что хэши совпадают, нам нужно глубоко вглубь ячейки и убедиться, что есть ячейка "а" (мы были заинтересованы).

Такие доказательства многократно снижают вычислительную нагрузку и количество данных, которые необходимо послать или хранить в верификаторе.

## Смотреть также

- [Расширенные проверки примеров](/v3/documentation/data-formats/tlb/proofs)
