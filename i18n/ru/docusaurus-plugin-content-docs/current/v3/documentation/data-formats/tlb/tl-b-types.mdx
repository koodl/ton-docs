import ThemedImage from '@theme/ThemedImage';

# TL-B Types

:::caution продвинутый уровень
Эта информация **очень низкая** и может быть трудно понять для новичков.
Так что не стесняйтесь читать об этом позже.
:::

В этом разделе анализируются сложные и нестандартные типные структуры бинарного языка (TL-B). Для начала мы рекомендуем прочитать [эту документацию](/v3/documentation/data-formats/tlb/tl-b-language), чтобы лучше познакомиться с этой темой.

<img alt="tlb structure" src="/img/docs/tlb.drawio.svg" width={'100%'}/>

## Либо

```tlb
left$0 {X:Type} {Y:Type} значение:X = Either X Y;
right$1 {X:Type} {Y:Type} значение:Y = Either X Y;
```

Любой тип используется, когда возможны два конечных типа. В этом случае выбор типа зависит от отображения бита префикса. Если бит префикса равен 0, левый тип сериализован, в то время как при использовании 1 бита префикса, правый сериализирован.

Он используется, например, при сериализации сообщений, когда тело либо является частью основной ячейки, либо связано с другой ячейкой.

## Может быть

```tlb
ничего$0 {X:Type} = Может быть X;
just$1 {X:Type} значение:X = Может быть X;
```

Тип может использоваться в сочетании с дополнительными значениями. В этих случаях, если первый бит равен 0, значение само по себе не сериализовано (и фактически пропущено), если значение равно 1, то оно сериализовано.

## Оба

```tlb
пара$_ {X:Type} {Y:Type} первый:X секунд:Y = оба X Y;
```

Разновидность обоих типов используется только в сочетании с нормальными парами, и оба типа сериализуются друг за другом, без каких-либо условий.

## Единый

Функциональный тип Unary обычно используется для динамического калибрования в структурах, таких как [hml_short](https://github.com/ton-blockchain/ton/blob/master/crypto/block/block.tlb#L29).

Unary представляет два основных варианта:

```tlb
unary_zero$0 = Unary ~0;
unary_succ$1 {n:#} x:(Unary ~n) = Unary ~(n + 1);
```

### Универсальная сериализация

Обычно использование варианта `unary_zero` довольно просто: если первый бит равен 0, то результат всей десериализации Unary равен 0.

При этом вариант `unary_succ` является более сложным, поскольку он загружен рекурсивно и имеет значение `~(n + 1)`. Это означает, что он последовательно вызывает себя, пока не достигнет `unary_zero`. Другими словами, желаемое значение будет равно количеству единиц в строке.

Например, давайте проанализируем сериализацию bitstring `110`.

Цепочка звонков будет следующей:

```tlb
unary_succ$1 -> unary_succ$1 -> unary_zero$0
```

Как только мы достигнем `unary_zero`, значение возвращается в конец сериализованного битрейта, аналогично вызову рекурсивной функции.

Теперь для более четкого понимания результата давайте получим путь возвращаемого значения, который отображается следующим образом:

`0 -> ~(0 + 1) -> ~(1 + 1) -> 2`, это означает, что мы сериализировали `110` в `Unary 2`.

### Универсальный десериализация

Предположим, что у нас есть тип `Foo`:

```tlb
foo$_  u:(Unary 2) = Foo;
```

В соответствии с вышеизложенным `Foo` будет десериализован в:

<br></br>
<ThemedImage
alt=""
sources={{
light: '/img/docs/data-formats/tl-b-docs-10.png?raw=true',
dark: '/img/docs/data-formats/tl-b-docs-10-dark.png?raw=true',
}}
/>
<br></br>

```tlb
foo u:(unary_succ x:(unary_succ x:(unnary_zero)))
```

## Hashmap

Тип комплекса Hashmap используется для хранения dict из смарт-кода FunC (`dict`).

Для сериализации хэшкарты с фиксированной длиной ключа используются следующие структуры TL-B:

```tlb
hm_edge#_ {n:#} {X:Type} {l:#} {m:#} label:(HmLabel ~l n)
          {n = (~m) + l} node:(HashmapNode m X) = Hashmap n X;

hmn_leaf#_ {X:Type} значение:X = HashmapNode 0 X;
hmn_fork#_ {n:#} {X:Type} слева:^(Hashmap n X)
           вправо:^(Hashmap n X) = HashmapNode (n + 1) X;

hml_short$0 {m:#} {n:#} len:(Unary ~n) {n <= m} s:(n * Bit) = HmLabel ~n m;
hml_long$10 {m:#} n:(#<= m) s:(n * Bit) = HmLabel ~n m;
hml_same$11 {m:#} v:Bit n:(#<= m) = HmLabel ~n m;

unary_zero$0 = Unary ~0;
unary_succ$1 {n:#} x:(Unary ~n) = Unary ~(n + 1);

hme_empty$0 {n:#} {X:Type} = HashmapE n X;
hme_root$1 {n:#} {X:Type} root:^(Hashmap n X) = HashmapE n X;
```

Это означает, что корневая структура использует `HashmapE` и любое из двух его состояний: включая `hme_empty` или `hme_root`.

### Hashmap parsing example

В качестве примера рассмотрите следующую ячейку, приведенную в бинарном виде.

```json
1[1] -> {
  2[00] -> {
    7[1001000] -> {
      25[1010000010000001100001001],
      25[1010000010000000001101111]
    },
    28[1011100000000000001100001001]
  }
}
```

Эта ячейка использует тип структуры «HashmapE» и имеет 8-битный размер ключа, а ее значения используют числовую окружение «uint16» («HashmapE 8 uint16»). Хэшмапп использует три разных типа ключей:

```
1 = 777
17 = 111
128 = 777
```

Чтобы разобрать эту хэшкарту, нам нужно заранее узнать, какой тип структуры использовать, `или hme_empty` или `hme_root`. Это определяется путем определения "правильного префикса". В hme empty variation используется один бит 0 (`hme_empty$0`), а hme root использует один бит 1 (`hme_root$1`). После прочтения первого бита установлено, что он равен одному (`1[1]`), что означает, что это вариант `hme_root`.

Теперь давайте заполним структурные переменные известными значениями, с первоначальным результатом:
`hme_root$1 {n:#} {X:Type} root:^(Hashmap 8 uint16) = HashmapE 8 uint16;`

Здесь уже читается один бит префикс, но в разделе `{}` означают условия, которые не нужно читать. Условие `{n:#}` означает, что n — любое число uint32, а `{X:Type}` означает, что X может использовать любые типы uint32.

Следующая часть должна быть прочитана — `root:^(Hashmap 8 uint16)`, а символ `^` — это загружаемая ссылка.

```json
2[00] -> {
    7[1001000] -> {
      25[1010000010000001100001001],
      25[1010000010000000001101111]
    },
    28[1011100000000000001100001001]
}
```

#### Инициализация парсинга ветки

Согласно нашей схеме, это правильная структура `Hashmap 8 uint16`. Далее заполняем его известными значениями и получаем результат:

```tlb
hm_edge#_ {n:#} {X:Type} {l:#} {m:#} этикетка:(HmLabel ~l 8)
          {8 = (~m) + l} node:(HashmapNode m uint16) = Hashmap 8 uint16;
```

Как показано выше, появились условные переменные `{l:#}` и `{m:#}`, но значения обеих переменных нам неизвестны. Кроме того, прочитав соответствующий `label`, ясно, что `n` вовлечен в уравнение `{n = (~m) + l}`, в этом случае мы вычисляем значения `l` и `m`, знак `показывает нам конечное значение ~`.

Чтобы определить значение `l`, мы должны загрузить последовательность `label:(HmLabel ~l uint16)`. Как показано ниже, `HmLabel` имеет 3 основных структурных варианта:

```tlb
hml_short$0 {m:#} {n:#} len:(Unary ~n) {n <= m} s:(n * Bit) = HmLabel ~n m;
hml_long$10 {m:#} n:(#<= m) s:(n * Bit) = HmLabel ~n m;
hml_same$11 {m:#} v:Bit n:(#<= m) = HmLabel ~n m;
```

Каждый вариант определяется соответствующим префиксом. В настоящее время наша корневая ячейка состоит из 2 нулевых битов, которые отображаются как: (`2[00]`). Поэтому единственным логическим параметром является `hml_short$0`, который использует префикс, начинающийся с 0.

Заполните `hml_short` известными значениями:

```tlb
hml_short$0 {m:#} {n:#} len:(Unary ~n) {n <= 8} s:(n * Bit) = HmLabel ~n 8
```

В этом случае мы не знаем значения `n`, но так как в нем есть символ `~`~`, его можно вычислить. Для этого мы загрузим `len:(Unary ~n)\`, [подробнее об Unary здесь](#unary).

В этом случае мы начинали с `2[00]`, но после определения типа `HmLabel`, только один из двух битов все еще существует.

Таким образом, мы загрузим его и посмотрим, что его значение равно 0, что означает, что он явно использует вариант `unary_zero$0`. Это означает, что значение n, использующее вариант `HmLabel`, равно нулю.

Далее необходимо завершить последовательность вариаций `hml_short`, используя рассчитанное значение n:

```tlb
hml_short$0 {m:#} {n:#} len:0 {n <= 8} s:(0 * Bit) = HmLabel 0 8
```

Получается, что у нас пустой `HmLabel` обозначен, как s = 0, поэтому скачивать нечего.

Далее мы дополняем нашу структуру расчетным значением «l» следующим образом:

```tlb
hm_edge#_ {n:#} {X:Type} {l:0} {m:#} метка:(HmLabel 0 8)
          {8 = (~m) + 0} узел:(HashmapNode m uint16) = Hashmap 8 uint16;
```

Теперь, когда мы рассчитали значение `l`, мы также можем посчитать `m`, используя уравнение `n = (~m) + 0`, i. `m = n - 0`, m = n = 8.

После определения всех неизвестных значений теперь можно загрузить `node:(HashmapNode 8 uint16)`.

Что касается HashmapNode, то у нас есть варианты:

```tlb
hmn_leaf#_ {X:Type} значение:X = HashmapNode 0 X;
hmn_fork#_ {n:#} {X:Type} слева:^(Hashmap n X)
           right:^(Hashmap n X) = HashmapNode (n + 1) X;
```

В этом случае мы определяем опцию не с помощью префикса, а с помощью параметра. Это означает, что если n = 0, то верным конечным будет `hmn_leaf` или `hmn_fork`.
В этом примере результат равен n = 8 (вариация hmn_fork). Мы используем вариацию `hmn_fork` и заполняем известные значения:

```tlb
hmn_fork#_ {n:#} {X:uint16} слева:^(Hashmap n uint16)
           право:^(Hashmap n uint16) = HashmapNode (n + 1) uint16;
```

После ввода известных значений мы должны вычислить `HashmapNode (n + 1) uint16`. Это означает, что результирующее значение n должно быть равно нашему параметру – 8.
Для вычисления локального значения n, нужно вычислить его по следующей формуле: `n = (n_local + 1)` -> `n_local = (n - 1)` -> `n_local = (8 - 1)` -> `n_local = (8 - 1)` -> `n_local = 7`.

```tlb
hmn_fork#_ {n:#} {X:uint16} слева:^(Hashmap 7 uint16)
           право:^(Hashmap 7 uint16) = HashmapNode (7 + 1) uint16;
```

Теперь, когда мы знаем, что приведенная выше формула необходима, получение конечного результата просто.
Далее мы загрузим левую и правую ветки и для каждой последующей ветки [процесс повторяется](#initiating-branch-parsing).

#### Анализ загруженных значений Hashmap

Продолжая предыдущий пример, давайте рассмотрим, как работает процесс загрузки ветвей (для dict values)., то есть \`28[1011100000000000001100001001]

Конечный результат становится `hm_edge` еще раз, а следующий шаг - заполнять последовательность правильными известными значениями следующим образом:

```tlb
hm_edge#_ {n:#} {X:Type} {l:#} {m:#} этикетка:(HmLabel ~l 7)
          {7 = (~m) + l} node:(HashmapNode m uint16) = Hashmap 7 uint16;
```

Далее загружается ответ `HmLabel`, используя вариант `HmLabel`, поскольку префикс `10`.

```tlb
hml_long$10 {m:#} n:(#<= m) s:(n * Bit) = HmLabel ~n m;
```

Теперь давайте заполним последовательность:

```tlb
hml_long$10 {m:#} n:(#<= 7) s:(n * Bit) = HmLabel ~n 7;
```

Новая конструкция - `n:(#<= 7)` четко обозначает значение калибровки, соответствующее номеру 7, , что на самом деле является log2 от числа + 1. Но для простоты мы могли бы посчитать количество битов, необходимое для написания числа 7.
Относительно номер 7 в бинарной форме `111`, поэтому требуется 3 бита, что означает значение `n = 3`.

```tlb
hml_long$10 {m:#} n:(## 3) s:(n * Bit) = HmLabel ~n 7;
```

Далее мы загрузим `n` в последовательность с конечным результатом `111`, который, как мы отметили выше = 7 одновременно. Затем мы загрузим `s` в последовательность, 7 бит - `0000000`. Помните, что «s» является частью ключа.

Далее мы возвращаемся к началу последовательности и заливаем получившееся «l»:

```tlb
hm_edge#_ {n:#} {X:Type} {l:#} {m:#} метка:(HmLabel 7 7)
          {7 = (~m) + 7} узел:(HashmapNode m uint16) = Hashmap 7 uint16;
```

Затем мы рассчитываем значение `m`, `m = 7 - 7`, поэтому значение `m = 0`.
Поскольку значение `m = 0`, структура идеально подходит для использования с HashmapNode:

```tlb
hmn_leaf#_ {X:Type} значение:X = HashmapNode 0 X;
```

Далее мы заменяем наш тип uint16 и загружаем значение. Остальные 16 битов `00001100001001` в десятичной форме 777, поэтому наша стоимость.

Теперь давайте восстановим ключ, мы должны объединить упорядоченный список всех частей ключа, которые были рассчитаны ранее.
Каждая из двух связанных ключевых частей объединяется с одной битой на основе использования ветвей типа.
Для правой ветки добавляется бит '1', для левой ветки добавляется бит. Если выше существует полный HmLabel , то его биты добавляются к ключу.

В этом случае конкретно 7 битов берутся из HmLabel `0000000` и бит ‘1’ добавляется перед последовательностью нулей, потому что значение было получено из правой ветки. Конечный результат составляет 8 бит всего или `10000000`, что означает, что ключевое значение равно `128`.

## Другие типы хэшматов

Теперь, когда мы обсуждали карты Hashmaps и как загрузить стандартизированный тип Hashmap, давайте объясним как работают дополнительные типы Hashmap.

### HashmapAugE

```tlb
ahm_edge#_ {n:#} {X:Type} {Y:Type} {l:#} {m:#}
  label:(HmLabel ~l n) {n = (~m) + l}
  node:(HashmapAugNode m X Y) = HashmapAug n X Y;

ahmn_leaf#_ {X:Type} {Y:Type} extra:Y значение:X = HashmapAugNode 0 X Y;

ahmn_fork#_ {n:#} {X:Type} {Y:Type} слева:^(HashmapAug n X Y)
  справа:^(HashmapAug n X Y) extra:Y = HashmapAugNode (n + 1) X Y;

ahme_empty$0 {n:#} {X:Type} {Y:Type} extra:Y
          = HashmapAugE n X Y;

ahme_root$1 {n:#} {X:Type} {Y:Type} root:^(HashmapAug n X Y)
  extra:Y = HashmapAugE n X Y;
```

Основной разницей между `HashmapAugE` и обычным `Hashmap` является наличие поля `extra:Y` в каждом узле (не только в листах со значениями).

### PfxHashmap

```tlb
phm_edge#_ {n:#} {X:Type} {l:#} {m:#} метка:(HmLabel ~l n)
           {n = (~m) + l} узла:(PfxHashmapNode m X)
           = PfxHashmap n X;

phmn_leaf$0 {n:#} {X:Type} значение:X = PfxHashmapNode n X;
phmn_fork$1 {n:#} {X:Type} слева:^(PfxHashmap n X)
            справа:^(PfxHashmap n X) = PfxHashmapNode (n + 1) X;

phme_empty$0 {n:#} {X:Type} = PfxHashmapE n X;
phme_root$1 {n:#} {X:Type} root:^(PfxHashmap n X)
            = PfxHashmapE n X;
```

Основная разница между PfxHashmap и обычным Hashmap — возможность хранить разные длины ключей из-за наличия узлов `phmn_leaf$0` и `phmn_fork$1`.

### VarHashmap

```tlb
vhm_edge#_ {n:#} {X:Type} {l:#} {m:#} метка:(HmLabel ~l n)
           {n = (~m) + l} node:(VarHashmapNode m X)
           = VarHashmap n X;
vhmn_leaf$00 {n:#} {X:Type} значение:X = VarHashmapNode n X;
вчмн_форк$01 {n:#} {X:Type} слева:^(VarHashmap n X)
             вправо:^(VarHashmap n X) значение:(Maybe X)
             = VarHashmapNode (n + 1) X;
vhmn_cont$1 {n:#} {X:Type} ветви:Bit child:^(VarHashmap n X)
            значение:X = VarHashmapNode (n + 1) X;

// nothing$0 {X:Type} = Может быть X;
// just$1 {X:Type} value:X = Может быть X;

vhme_empty$0 {n:#} {X:Type} = VarHashmapE n X;
vhme_root$1 {n:#} {X:Type} root:^(VarHashmap n X)
            = VarHashmapE n X;
```

Основное различие между VarHashmap и обычным Hashmap - возможность хранить разные длины ключей из-за наличия узлов `vhmn_leaf$00` и `vhmn_fork$01`. Кроме того, `VarHashmap` способен сформировать общий префикс значений (дочерняя карта) за счет `vhmn_cont$1`.

### БинДерево

```tlb
bta_leaf$0 {X:Type} {Y:Type} extra:Y leaf:X = BinTreeAug X Y;
bta_fork$1 {X:Type} {Y:Type} слева:^(BinTreeAug X Y)
           право:^(BinTreeAug X Y) extra:Y = BinTreeAug X Y;
```

Двоичный механизм генерации ключей дерева работает таким же образом, как и стандартный фреймворк Hashmap, но не использует этикетки и содержит только префиксы филиалов.

## Адреса

Адреса TON формируются с помощью механизма ша256 хэширования с использованием структуры StateInit. Это означает, что адрес может быть рассчитан до развертывания сетевого контракта.

### Сериализация

Стандартные адреса, такие как `EQBL2_3lMiywU17g-or8N7v9hDmPCpttzBPE2isF2GTzpK4` используют base64 uri для байтовой кодировки.
Обычно они имеют длину 36 байт, последним 2 из которых являются контрольная сумма crc16, рассчитанная с помощью таблицы XMODEM, в то время как первый байт представляет флаг, второй представляет цепочку.
32 байта в середине - это данные самого адреса (также называемые AccountID), часто представляемые в схемах, таких как int256.

[Decoding example](https://github.com/xssnick/tonutils-go/blob/3d9ee052689376061bf7e4a22037ff131183afad/address/addr.go#L156)

## Справочная литература

_Здесь [ссылка на оригинальную статью](https://github.com/xssnick/ton-deep-doc/blob/master/TL-B.md) от [Oleg Baranov](https://github.com/xssnick)._
