import ThemedImage from '@theme/ThemedImage';

# Ячейка и сумка клеток (БК)

## Ген

Ячейка представляет собой структуру данных в TON Blockchain. Гены могут хранить до 1023 бит и иметь до 4 ссылок на другие клетки.

<br></br>
<ThemedImage
alt=""
sources={{
    light: '/img/docs/data-formats/tl-b-docs-5.png?raw=true',
    dark: '/img/docs/data-formats/tl-b-docs-5-dark.png?raw=true',
}}
/>
<br></br>

## Мешок ячеек

Мешок ячеек (BoC) — это формат сериализации ячеек в массивы байтов, который далее описан в [схеме TL-B](https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/tl/boc.tlb#L25).

<br></br>
<ThemedImage
alt=""
sources={{
    light: '/img/docs/data-formats/tl-b-docs-6.png?raw=true',
    dark: '/img/docs/data-formats/tl-b-docs-6-dark.png?raw=true',
}}
/>
<br></br>

На TON, все состоит из ячеек, включая код контракта, хранимые данные, блоки, достигая упорядоченной и надежной гибкости в процессе.

<br></br>
<ThemedImage
alt=""
sources={{
    light: '/img/docs/data-formats/tl-b-docs-4.png?raw=true',
    dark: '/img/docs/data-formats/tl-b-docs-4-dark.png?raw=true',
}}
/>
<br></br>

### Сериализация ячеек

Давайте проанализируем наш первый пример мешка ячеек :

<br></br>
<ThemedImage
alt=""
sources={{
    light: '/img/docs/data-formats/tl-b-docs-7.png?raw=true',
    dark: '/img/docs/data-formats/tl-b-docs-7-dark.png?raw=true',
}}
/>
<br></br>

```json
1[8_] -> {
  24[0AAAAA],
  7[FE] -> {
    24[0AAAAA]
  }
}
```

В данном примере у нас есть 1-битная корневая ячейка, которая имеет 2 ссылки: первая к 24-битной ячейке и вторая к 7-битной ячейке, которая имеет 1 ссылку на 24-битную ячейку.

Для этого фреймворка необходимо преобразовать ячейки в одну последовательность байтов. Для достижения этой цели сначала мы используем только уникальные типы ячеек, ниже 3 из 4 представлены следующим образом:

```json
1[8_]
24[0AAAAA]
7[FE]
```

:::note
Для того чтобы оставить только уникальные клетки, их нужно сравнить. To do this, we need to compare the [hashes](#cell-hash) of the cells.
:::

```json
1[8_]      -> индекс 0 (корневая ячейка)
7[FE]      -> индекс 1
24[0AAAAA] -> индекс 2
```

Теперь давайте посчитаем описания для каждого из трех ячеек, прикоснувшихся выше. Эти описания состоят из 2 байт, в которых флаги хранят информацию о длине данных и количестве ссылок на данные.

The first byte - **refs descriptor** - is calculated as `r+8s+32l`, where `0 ≤ r ≤ 4` is amount of the Cell references (links), `0 ≤ s ≤ 1` is 1 for [exotic](#special-exotic-cells) cells and 0 for ordinary ones, and `0 ≤ l ≤ 3` is the [level](#cell-level) of the Cell.

Второй - **битный дескриптор** - равен `floor(b / 8) + потолку (b / 8)`, где `0 <= b <= 1023` — количество битов в ячейке. Этот дескриптор отображает длину всех 4-х битных групп данных ячейки (но не менее 1, если она не пуста).

Результат:

```json
1[8_]      -> 0201 -> 2 refs, длина 1
7[FE]      -> 0101 -> 1 ref, длина 1
24[0AAAAA] -> 0006 -> 0 refs, длина 6
```

Для данных с неполными 4-х битными группами добавляется 1 бит в конец последовательности. Это означает, что он обозначает конечный бит группы и используется для определения истинного размера неполных групп. Давайте добавим биты ниже:

```json
1[8_]      -> C0 -> 0b10000000->0b1100000000
7[FE]      -> FF -> 0b11111110->0b111111
24[0AAAAA] -> 0AAAA -> не изменять (полные группы)
```

Теперь давайте добавим реф-индексы:

```json
0 1[8_]      -> 0201 -> ссылается на 2 ячейки с такими индексами
1 7[FE]      -> 02 -> ссылается на ячейки с индексом 2
2 24[0AAAAA] -> не возвращает
```

И поместите все вместе:

```json
0201 C0     0201
0101 FF     02
0006 0AAAAA
```

И сокопайте его, присоединив соответствующие строки в единый массив байтов:
`0201c002010101ff0200060aaaa`, размер 14 байт.

<details>
  <summary><b>Показать пример</b></summary>

```golang
func (c *Cell) descriptors() []byte {
  ceilBytes := c.bitsSz / 8
  if c. itsSz%8 ! = 0 {
    ceilBytes++
  }

	// calc size
	ln := ceilBytes + c. itsSz / 8

	спецификация := byte(0)
	если c. pecial {
	  specBit = 8
	}

	return []byte{byte(len(c.refs)) + specBit + c.level*32, byte(ln)}
}
```

[Source](https://github.com/xssnick/tonutils-go/blob/3d9ee052689376061bf7e4a22037ff131183afad/tvm/cell/serialize.go#L205)

</details>

### Упаковка мешка ячеек

Давайте упакуем ячейку из секции прямо выше. Мы уже сериализовали его в плоский 14-байтный массив.

Поэтому мы строим заголовок согласно его [schema](https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/tl/boc.tlb#L25).

```
b5ee9c72 -> id tl-b структуры BoC
01 -> флаги и размер:(## 3), в нашем случае все флаги - 0,
                                 и количество байт, необходимых для хранения ячеек равно 1.
                                 получим - 0b0_0_0_00_001
01 -> количество байт для хранения размера сериализованных ячеек
03 -> количество ячеек, 1 байт (определяется 3 бит размер:(## 3), равный 3.
01 -> количество корневых ячеек - 1
00 -> отсутствие, всегда 0 (в текущих реализациях)
0e -> размер сериализованных ячеек, 1 байт (указанный выше размер), равно 14
00 -> индекс корневых ячеек, - размер 1 (определяется 3 размера:(## 3) бит от заголовка),
                                 всегда 0
0201c002010101ff0200060aaaaa -> сериализованные ячейки
```

Далее мы соединяем всё выше в массив байтов в наш финальный BoC:
`b5ee9c7201010301000e000201c002010101ff0200060aaaa`

Примеры реализации генов: [Serialization](https://github.com/xssnick/tonutils-go/blob/master/tvm/cell/serialize.go), [Deserialization](https://github.com/xssnick/tonutils-go/blob/master/tvm/cell/parse.go)

## Специальные (дополнительные) Гены

Как правило, клетки, работающие на ТОН, подразделяются на два основных типа: обычные клетки и специальные клетки. Большинство камер, с которыми работают пользователи, являются обычными клетками, ответственными за перенос информации.

Тем не менее для реализации внутренней функциональности сети, иногда требуются специальные клетки и используются для различных целей в зависимости от их субтитра.

## Уровень ячейки

Каждая ячейка имеет атрибут «Level», который представлен целым числом от 0 до 3.

### Обычный уровень ячеек

Уровень обычной ячейки всегда равен максимальному уровню всех его ссылок:

```cpp
Lvl(c) = max(Lvl(r_0), ..., Lvl(r_i), ..., Lvl(r_e))
```

Где `i` - справочный индекс `c`, `e` - это исходная сумма `c`.

_Ген обычного, без уровня рефератов равна нулю_

### Уровень экзотических клеток

Экзотические ячейки имеют разные правила установки их уровня, которые описаны в статье [this](/v3/documentation/data-formats/tlb/exotic-cells).

## Хэш ячейки

В большинстве случаев пользователи работают с обычными клетками с уровнем 0, который имеет только один хэш, называемый хэш представления (или хэш бесконечность).

Ячейка `c` с уровнем `Lvl(c) = l`, где `1 ≤ l ≤ 3` имеет представление хэша и `l` **"выше"** хэшей.

### Стандартный расчет хэша представления ячеек

Во-первых, нам необходимо рассчитать представительство ячеек (аналогично приведенной выше сериализации)

1. Вычислить байты дескрипторов
2. Добавить сериализованные данные ячейки
3. Для каждой рефлектограммы добавить глубину
4. Для каждой рефералы добавить его хэш представительства
5. Вычислить SHA256 хэш результата

Давайте проанализируем следующие примеры:

#### Ячейка без ссылок

```json
32[0000000F]
```

1. Расчет дескрипторов

Исходный дескриптор равен `r+8s+32l = 0 + 0 + 0 = 0 = 00`

Дескриптор бит равен `floor(b / 8) + потолку (b / 8) = 8 = 08`

Объединение этих байтов мы получим `0008`

2. Сериализация данных в ячейках

В этом случае мы завершили 4-х битные группы, поэтому нам не нужно добавлять какие-либо биты в данные ячеек. Результат `0000000f`

3. Глубина обращений

Мы пропустили эту часть, потому что у нашей ячейки нет никаких рефералов

4. Хэш ссылок

Мы пропустили эту часть, потому что у нашей ячейки нет никаких рефералов

5. Расчет SHA256

Захватывающие байты от предыдущих шагов мы получаем `00080000000f` и SHA256 из этого байта `57b520dbcb9d135863fc33963cde9f6db2ded1430d88056810a2c9434a3860f9` - вот что Клеток представляет хэш.

#### Ген со ссылками

```json
24[00000B] -> {
	32[0000000F],
	32[0000000F]
}
```

1. Расчет дескрипторов

Исходный дескриптор равен `r+8s+32l = 2 + 0 + 0 = 0 = 02`

Дескриптор бит равен `floor(b / 8) + потолку (b / 8) = 6 = 06`

Объединение этих байтов мы получим `0206`

2. Сериализация данных в ячейках

В этом случае мы завершили 4-х битные группы, поэтому нам не нужно добавлять какие-либо биты в данные ячеек. Результат `00000b`

3. Глубина обращений

Глубина представлена 2 байтами. Наша ячейка имеет 2 ответа и глубина каждого равна нулю, поэтому результат этого шага составляет `00000000`.

4. Хэш ссылок

Для каждого упоминания добавим его хэш (мы вычислили выше), поэтому результатом является `57b520dbcb9d135863fc33963cde9f6db2ded1430d88056810a2c9434a3860f957b520dbcb9d135863fc33963cde9f6db2ded1430d88056810a2c9434a3860f9`

5. Расчет SHA256

Захватывая байты от предыдущих шагов, мы получим `020600000b00000057b520dbcb9d135863fc33963cde9f6db2ded1430d88056810a2c9434a3860f957b520dbcb9d135863fc33963cde9f6db2ded1430d88056810a2c9434a3860f9`
и SHA256 этого байта `f345277cc6cfa747f001367e1e873dcfa8a936b8492431248b7a3eeafa8030e7` - это хэш для представления ячей.

### Более высокий расчет хэшей

Более высокие хэши обычных ячеек `c` вычисляются аналогично его хешу представления,
но используя более высокие хэши в своих ссылках вместо хэшей представления.

Exotic cells have their own rules for computing their higher hashes, which are described in [this](/v3/documentation/data-formats/tlb/exotic-cells) article.

## Смотреть также

[//]: # "* [Оригинальная статья на RU](https://github.com/xssnick/ton-deep-doc/blob/master/Cells-BoC.md)"

- [Экзотические (особенные) ячейки](/v3/documentation/data-formats/tlb/exotic-cells)
- [Проверка проверки](/v3/documentation/data-formats/tlb/proofs)
