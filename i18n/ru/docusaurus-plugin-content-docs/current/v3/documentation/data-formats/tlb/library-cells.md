# Библиотечные клетки

## Введение

Одна из особенностей хранения данных TON в ячейках deduplication: в хранилище, сообщения, блоки, транзакции и так далее дублирующиеся ячейки хранятся только один раз. Это значительно уменьшает размер сериализованных данных и позволяет эффективно хранить обновленные данные поэтапно.

По той же причине многие структуры в TON одновременно богаты, удобная и эффективная: структура блоков содержит одну и ту же копию каждого сообщения во многих местах: в очереди сообщений, в списке транзакций, в обновлениях Merkle и так далее: так как дублирование не имеет накладных накладных расходов, мы можем хранить данные несколько раз, где нам это необходимо, не опасаясь за эффективность.

Библиотечные клетки используют механизм дедупликации в цепочке, позволяя интегрировать эту технологию в пользовательские смарт-контракты.
::info
Если вы храните код Jetton-кошелька в качестве библиотечной ячейки (1 ячейка и 256+8 бит, вместо ~20 ячеек и 6000 битов), например, форвардная плата за сообщение, содержащее `init_code` будет уменьшена с 0. 11-0,003 TON.
:::

## Общая информация

Рассмотрим базовый шаг от блока 1'000'000 до блока 1'000'001. Хотя каждый блок содержит небольшое количество данных (обычно менее 1000 транзакций), всё состояние Basechain содержит миллионы учетных записей, и поскольку блокчейн должен сохранять целостность данных (в частности, для того, чтобы сохранить корневой хэш всего состояния в блоке) необходимо обновить дерево состояния.

Для блокчейнов предыдущих поколений это означает, что обычно вы отслеживаете только последние состояния, так как для хранения отдельных состояний цепи для каждого блока потребуется слишком много места. Но в TON Blockchain из-за deduplication, для каждого блока вы добавляете только для хранения новых генов. Это не только ускоряет обработку, но и позволяет эффективно работать с историей: проверять балансы, состояний и даже запуска получить методы для любой точки в истории без больших наклад!

Для случая, когда у нас есть семейство аналогичных контрактов (например, Jetton-кошельков), узел сохраняет повторяющиеся данные (один и тот же код каждого Jetton-кошелька) только один раз. Библиотечные ячейки позволяют использовать механизм дедупликации для таких контрактов для уменьшения платы за хранение и пересылку.

:::info Высокоуровневая аналогия
Вы можете рассматривать библиотечный ген как C++ указатель: одна маленькая ячейка, которая указывает на ген (возможно) много рефералов. Справочная ячейка (ячейка, к которой библиотек) должна существовать и регистрироваться в публичном контексте (_"published"_).
:::

## Структура библиотечных ячеек

Библиотечная ячейка [экзотическая ячейка](/v3/documentation/data-formats/tlb/exotic-cells), которая содержит ссылку на другую статическую ячейку. В частности, он содержит 256 бит хэша ссылаемой ячейки.

Для ТВМ библиотечные камеры работают следующим образом: когда ТВМ получает команду открыть ячейку в кусочек (Инструкция ТВМ: `CTOS`, метод funC: `. egin_parse()`) ищет ячейку с помощью соответствующего хэша из библиотечной ячейки в контексте библиотеки Masterchain. Если обнаружить его, он открывает ссылающуюся ячейку и возвращает ее ломтик.

Открывая библиотечную ячейку стоит так же, как открытие обычной ячейки, так что он может использоваться как прозрачная замена статических клеток, которые, однако, занимают гораздо меньше места (и, следовательно, стоит меньше платы за хранение и отправку).

Обратите внимание, что можно создать библиотечную ячейку, которая ссылается на другую ячейку библиотеки, которая в свою очередь ссылается на другую, и так далее. Для такого случая `.begin_parse()` будет увеличивать исключение. Однако такая библиотека может быть распакована пошагово с опкодом `XLOAD`.

Еще одна важная особенность решетки библиотеки заключается в том, что, поскольку она содержит хэш ссылаемых ячеек, она в конечном итоге содержит ссылки на некоторые статические данные. Вы не можете изменить данные, на которые ссылается эта ячейка библиотеки.

Чтобы найти его в контексте библиотеки Masterchain и ссылаться на нее в Библиотечной ячейке, исходная ячейка должна быть опубликована в сети Masterchain.  Это означает, что смарт-контракт, существующий в Masterchin, должен добавить эту ячейку в свое состояние с флагом `public=true`. Это можно сделать с помощью опкода `SETLIBCODE`.

## Использование в умных контрактах

Поскольку библиотечная ячейка ведет себя так же, как обычная ячейка, на нее ссылаются во всех контекстах, за исключением расчетов комиссии, вы можете просто использовать ее вместо любой ячейки со статическими данными. Например, вы можете хранить код Jetton-бумажника в качестве библиотечной ячейки (таким как 1 ячейка и 256+8 бит, вместо того, как правило, ~20 ячеек и 6000 битов), что приведет к порядку меньше хранения и вперед. В частности, форвардная плата за сообщение `internal_transfer`, содержащее `init_code` будет уменьшена с 0.011 до 0.003 TON.

### Хранить данные в ячейке библиотеки

Рассмотрим пример сохранения кода jetton-кошелька в качестве библиотечной ячейки для уменьшения комиссии. Сначала нужно скомпилировать Jetton-кошелек в обычную ячейку, которая содержит его код.

Тогда вам нужно создать библиотечный ген по отношению к обычной ячейке. Библиотечная ячейка содержит 8-битный тег библиотеки «0x02», за которым следуют 256-битные ссылки на хэш ячеек.

### Использование в Fift

В основном вам нужно поместить тег и хэш конструктору, а затем "закрыть конструктор как экзотические ячейки".

It can be done in Fift-asm construction like [this](https://github.com/ton-blockchain/multisig-contract-v2/blob/master/contracts/auto/order_code.func), example of compilation some contract directly to library cell [here](https://github.com/ton-blockchain/multisig-contract-v2/blob/master/wrappers/Order.compile.ts).

```fift
;; https://docs.ton.org/tvm. df, страница 30
;; Справочная ячейка библиотеки — Всегда имеет уровень 0, и содержит 8+256 битов данных, включая ее 8-битный тип integer 2 
; и хэш представительств в библиотечной ячейке. При загрузке библиотека
;; эталонная ячейка может быть заменена на ячейку, если она найдена в текущем контексте библиотеки.

cell order_code() asm "<b 2 8 u, 0x6305a8061c856c2ccf05dcb0df5815c71475870567cab5f049e340bcf59251f3 256 u, b>spec PUSHREF";
```

### Использование в @ton/ton

Кроме того, вы можете сформировать группу библиотеки целиком на ts-уровне в чертеже с помощью библиотеки `@ton/ton`:

```ts
импорт { Cell, beginCell } из '@ton/core';

let lib_prep = beginCell().storeUint(2,8).storeBuffer(jwallet_code_raw.hash()).endCell();
jwallet_code = новая Cell({ exotic:true, bits: lib_prep.bits, refs:lib_prep.refs});
```

- Изучение исходного кода [here](https://github.com/ton-blockchain/stablecoin-contract/blob/de08b905214eb253d27009db6a124fd1feadbf72/sandbox_tests/JettonWallet.spec.ts#L104C1-L105C90).

### Опубликовать обычную ячейку в контексте библиотек masterchain

Practical example is available [here](https://github.com/ton-blockchain/multisig-contract-v2/blob/master/contracts/helper/librarian.func). Ядром этого контракта является \`set_lib_code(lib_to_publish, 2); - она принимает обычные входные ячейки, которые должны быть опубликованы и флаг =2 (это означает, что все могут использовать его).

Заметьте, что контракт на публикацию ячейки платит за ее хранение и хранение в masterchain 1000x выше, чем в basechain. Поэтому использование библиотечных сетей является эффективным только для контрактов, используемых тысячами пользователей.

### Тестирование чертежа

Чтобы проверить, как контракт работает в чертеже, необходимо вручную добавить ссылки ячейки в библиотечный контекст эмулятора чертежа. Это можно сделать следующим образом:

1. нужно создать контекстный словарь библиотек (Hashmap) `uint256->Cell`, где `uint256` хэш соответствующей ячейки.
2. установить контекст библиотеки в настройки эмулятора.

Пример того, как это можно сделать, показан [here](https://github.com/ton-blockchain/stablecoin-contract/blob/de08b905214eb253d27009db6a124fd1feadbf72/sandbox_tests/JettonWallet.spec.ts#L100C9-L103C32).

:::info
Обратите внимание, что текущая версия чертежа (`@ton/blueprint:0.19.0`) не обновляется автоматически, если в ходе эмуляции некоторого контракта на публикацию новой библиотеки, необходимо сделать это вручную.
Фактически по 04.2024 и предполагается улучшить в ближайшем будущем.
:::

### Получить контракты на основе библиотечных ячеек

У вас есть Jetton-кошелек с его кодом, сохраненным в библиотечной ячейке и желанием проверить баланс.

Чтобы проверить его баланс, необходимо выполнить получение метода в коде. Это включает в себя:

- доступ к камере библиотеки
- получение хэша указанной ячейки
- поиск ячейки с этим хэшем в коллекции библиотек masterchain's
- выполнение кода оттуда.

В Layered Solutions (LS) все эти процессы происходят за сценой без информации пользователя о конкретном методе хранения кода.

Однако, работая на местном уровне, все по-разному. Например, если вы используете обозреватель или кошелек, вы можете принять состояние счета и попытаться определить его тип – будь то NFT, бумажник, токен или аукцион.

Для обычных контрактов вы можете посмотреть доступные методы, то есть интерфейс, чтобы понять это. Или вы можете "украсть" состояние счета в моем местном псевдонете и выполнить методы там.

В библиотечной ячейке это невозможно, так как она сама не содержит данных. Вы должны вручную определить и извлечь необходимые ячейки из контекста. Это можно сделать через LS (хотя привязки пока не поддерживают это) или через DTon.

#### Получение Ген Библиотеки с Liteserver

Liteserver при запуске методов автоматически задает правильный контекст библиотеки. Если вы хотите определить тип контракта с помощью получения методов или запустить getmethods локально, вам нужно загрузить соответствующие ячейки с помощью метода LS [liteServer.getLibraries](https://github. om/ton-blockchain/ton/blob/4cfe1d1a96acf956e28e2bbc696a143489e23631/tl/generate/scheme/lite_api.tl#L96).

#### Получение Ген Библиотеки с DTon

Вы также можете получить библиотеку из [dton.io/graphql](https://dton.io/graphql):

```
{
  get_lib(
    lib_hash: "<HASH>"
  )
}
```

а также список библиотек для конкретного блока masterchin:

```
{
  blocks{
    libs_publishers
    libs_hash
  }
}
```

## Смотреть также

- [Экзотические ячейки](/v3/documentation/data-formats/tlb/exotic-cells)
- [Инструкции TVM](/v3/documentation/tvm/instructions)
