import ThemedImage from '@theme/ThemedImage';

# Язык TL-B

TL-B (Тип языка - Binary) служит для описания типовой системы, конструкторов и существующих функций. Например, мы
можем использовать TL-B схемы для построения бинарных структур, связанных с TON Blockchain. Специальные парсеры TL-B могут читать схемы
десериализации двоичных данных в различные объекты. TL-B описывает схемы данных для объектов «Cell». If you not familiar
with `Cells`, please read [Cell & Bag of Cells(BOC)](/v3/documentation/data-formats/tlb/cell-boc#cell) article.

## Общий обзор

Мы называем любой набор TL-B документами TL-B. A TL-B document usually consists of declarations of types (
i.e. their constructors) and functional combinators. Объявление каждого комбинатора заканчивается точкой с запятой (`;`).

Вот пример возможного объявления комбинатора:

<br></br>
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/data-formats/tl-b-docs-2.png?raw=true',
    dark: '/img/docs/data-formats/tl-b-docs-2-dark.png?raw=true',
  }}
/>
<br></br>

## Построители

The left-hand side of each equation describes the way to define, or serialize, a value of the type indicated on the
right-hand side. Такое описание начинается с названия конструктора.

<br></br>
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/data-formats/tl-b-docs-3.png?raw=true',
    dark: '/img/docs/data-formats/tl-b-docs-3-dark.png?raw=true',
  }}
/>
<br></br>

Конструкторы используются для указания типа комбинатора, в том числе состояния при сериализации. Например, конструкторы
также могут использоваться когда вы хотите указать `op`(операционный код) в запросе к смарт-контракту в TON.

```tlb
// ....
transfer#5fcc3d14 <...> = InternalMsgBody;
// ....
```

- имя конструктора: `transfer`
- префикс конструктора: `#5fcc3d14`

Заметьте, что имя конструктора сразу же за ним следует необязательный тег конструктора, например `#_` или `$10`, который
описывает битрейт, используемый для кодирования (сериализации) соответствующего конструктора.

```tlb
message#3f5476ca значение:# = Крутое сообщение;
bool_true$0 = Бул;
bool_false$1 = Бул;
```

The left-hand side of each equation describes the way to define, or serialize, a value of the type indicated on the
right-hand side. Such a description begins with the name of a constructor, such as `message` or `bool_true`, immediately
followed by an optional constructor tag, such as `#3f5476ca` or `$0`, which describes the bits used to encode (
serialize)
the constructor in question.

| конструктор                      | сериализация                                                       |
| -------------------------------- | ------------------------------------------------------------------ |
| `некоторый#3f5476ca`             | 32-разрядная сериализация uint из шестнадцатеричного значения      |
| `некоторый#5fe`                  | 12-битная сериализация uint из шестнадцатибитного значения         |
| `некоторые$0101`                 | сериализовать сырые биты `0101`                                    |
| `some` или `some#`               | сериализовать `crc32(уравнение) \| 0x80000000`                     |
| `some#_` или `some$_` или `_`    | сериализовать ничего                                               |

Имена конструкторов (`некоторые` в этом примере) используются в качестве переменных в коде. Например:

```tlb
bool_true$1 = Bool;
bool_false$0 = Bool;
```

Тип `Bool` имеет два тега `0` и `1`. Псевдокод кодега может выглядеть так:

```python3

class Bool:
    tags = [1, 0]
    tags_names = ['bool_true', 'bool_false']
```

Если вы не хотите определить любое имя текущего конструктора, просто передайте `_`, например `_ a:(## 32) = 32Int;`

Тэги конструктора могут быть введены либо в двоичном (после указателя доллара), либо в шестнадцатеричном (после знака хэша). Если
тег не
явно предоставлен, парсер TL-B должен вычислить 32-битный конструкторский тэг по умолчанию, хэшируя с помощью алгоритма CRC32
текста «уравнения» с `| 0x80000000` определенно определяющим этого конструктора. Поэтому пустые теги
должны быть явно предоставлены `#_` или `$_`.

Этот тег используется для угадывания текущего типа битрейта в процессе десериализации. Например, у нас есть 1 бит битрейт `0`,
если мы покажем TLB разобрать этот битрейт в типе `Bool`, он будет разбирать его как `Bool.bool_false`.

Давайте скажем, что у нас есть более сложные примеры:

```tbl
tag_a$10 val:(## 32) = A;
tag_b$00 val(## 64) = A;
```

Если мы разобраем `100000000000000000000000000000000001` (1 и 32 ноли и 1) в типе TLB `A` - сначала нам нужно получить первые
два бита для определения тега. В этом примере `10` есть два первых бита, которые представляют `tag_a`. Итак, теперь мы знаем, что следующие 32
бита являются переменной `val`, `1` в нашем примере. Некоторые переменные "parsed" могут выглядеть так:

```python3
A.tag = 'tag_a'
A.tag_bits = '10'
A.val = 1
```

All constructor names must be distinct and constructor tags for the same type must constitute a prefix code (otherwise
the deserialization would not be unique); i.e. no tag can be a prefix of any other in same type.

Максимальное количество конструкторов одного типа: `64`
Максимальное количество битов для тега: `63`

<b>Двоичный пример:</b>

```tlb
example_a$10 = A;
example_b$01 = A;
example_c$11 = A;
example_d$00 = A;
```

Псевдокод кодега может выглядеть так:

```python3

класса A:
    тегов = [2, 1, 3, 0]
    tags_names = ['example_a', 'example_b', 'example_c', 'example_d']
```

<b>Hex тег:</b>

```tlb
example_a#0 = A;
example_b#1 = A;
example_c#f = A;
```

Псевдокод кодега может выглядеть так:

```python3

класса A:
    тегов = [0, 1, 15]
    tags_names = ['example_a', 'example_b', 'example_c']
```

Если вы используете тег `hex`, имейте в виду, что он будет сериализован как 4 бит для каждого шестнадцатеричного символа. Максимальное значение 63-битного
не знакомого целого. Это означает:

```tlb
a#32 a:(## 32) = AMultiTagInt;
b#1111 a:(## 32) = AMultiTagInt;
c#5FE a:(## 32) = AMultiTagInt;
d#3F5476CA a:(## 32) = AMultiTagInt;
```

| конструктор  | сериализация                                                  |
| ------------ | ------------------------------------------------------------- |
| `a#32`       | 8-битная сериализация uint из шестнадцатеричного значения     |
| `b#1111`     | 16-битная сериализация uint из шестнадцатибитного значения    |
| `c#5FE`      | 12-битная сериализация uint из шестнадцатибитного значения    |
| `d#3F5476CA` | 32-разрядная сериализация uint из шестнадцатеричного значения |

Также шестнадцатеричные значения допускаются как в верхнем числе, так и в нижнем регистре.

#### Подробнее о шестнадцатеричных тегах

В дополнение к классическому определению шестнадцатеричного тега за ним может последовать шестнадцатеричный номер подчеркивания.
Это означает, что тег равен указанному шестнадцатеричному числу, без наименьшего значения.
Например, существует схема:

```tlb
vm_stk_int#0201_ значение:int257 = VmStackValue;
```

И тег на самом деле не равен `0x0201`. Для вычисления необходимо удалить LSb из двоичного представления `0x0201`:

```
0000001000000001 -> 000000100000000
```

Таким образом, тэг равен 15-битному битному числу `0b000010000000000`.

## Определения полей

За конструктором и его дополнительным тегом следуют определения полей. Each field definition is of the
form `ident:type-expr`, where ident is an identifier with the name of the field (replaced by an underscore for
anonymous fields), and type-expr is the field’s type. Здесь указан тип выражения, который может включать
простые типы, параметры с подходящими параметрами или сложными выражениями.

<b>В сумме все поля, заданные типом не должны быть больше, чем ячейка (`1023` бит и `4` refs)</b>

### Простые типы

- `_ a:# = Type;` - `Type.a` здесь 32-битное целое число
- `_ a:(## 64) = Type;` - `Type.a` здесь 64-битное целое число
- `_ a:Владелец = NFT;` - `NFT.a` тип `Владелец`
- `_ a:^Владелец = NFT;` - `NFT.a` здесь ячейка типа `Владелец` означает `Владелец` хранится в следующей ссылке.

### Анонимные поля

- `_ _:# = A;` - первое поле анонимно 32-битное целое

### Расширить ячейку со ссылками

```tlb
_ а:(##32) ^[ b:(##32) c:(## 32) d:(## 32)] = A;
```

- Если по какой-то причине мы хотим разделить некоторые поля на другую ячейку
  мы можем использовать `^[ ... ]` синтаксис.
  В данном примере `A.a` / `A.b` / `A.c` / `A.d` - 32-битные числа, но `A. ` хранится в первой ячейке,
  и `A.b` / `A.c` / `A.d` хранится в следующей ячейке (1 ref)

```tlb
_ ^[ a:(## 32) ^[ b:(## 32) ^[ c:(## 32) ] ] ] = A;
```

- Также разрешена цепочка ссылок. В этом примере каждая из переменныхformat@@0
  (`a`, `b`, `c`) хранится в разделенных ячейках

### Типы параметров

Предположим, у нас есть тип `IntWithObj`:

```tlb
_ {X:Type} a:# b:X = IntWithObj X;
```

Теперь мы можем использовать его другими типами:

```tlb
_ a:(IntWithObj uint32) = IntWithUint32;
```

### Сложные выражения

- Условные поля (только для `Nat`) (`E?T` означает если выражение `E` верно, чем поле `T`)
  ```tlb
  _ а:(## 1) b:a?(## 32) = Пример;
  ```
  В «Пример» сериализована переменная `b`, только если `a` является `1`

- Умножение выражения для создания труб (`x * T` означает создание трубки длины `x` типа `T`):

  ```tlb
  a$_ a:(## 32) = A;
  b$_ b:(2 * A) = B;
  ```

  ```tlb
  _ (## 1) = Bit;
  _ 2бит:(2 * бит) = 2бит;
  ```

- Выбор битов (только для `Nat`) (\`E . B" означает «B» из «Nat» «E»
  ```tlb
  _ а:(## 2) b:(a . 1)?(## 32) = Пример;
  ```
  В `Пример` сериализована переменная `b` только если второй бит `a` это `1`

- Другие операторы «Nat» также разрешены (см. «Разрешенные константы»)

Примечание: вы можете комбинировать несколько сложных выражений:

```tlb
_ а:(## 1) b:(## 1) c:(## 2) d:(a?(b?(c . 1)?(## 64)))) = A;
```

## Встроенные типы

- `#` - `Nat` 32 бит беззнакомое целое число
- `## x` - `Nat` с `x` битами
- `#< x` - `Nat` меньше, чем `x` бит без знаков числа, хранимый как `lenBits(x - 1)` бит, до 31 бит
- `#<= x` - `Nat` меньше или равен биту `x` без знаков числа, хранимое как `lenBits(x)` бит, до 32 бит
- `Any` / `Cell` - остаток битов ячеек
- `Int` - 257 бит
- `UInt` - 256 бит
- `Bits` - 1023 бита
- `uint1` - `uint256` - 1 - 256 бит
- `int1` - `int257` - 1 - 257 бит
- `bits1` - `bits1023` - 1 - 1023 бит
- `uint X` / `int X` / `bits X` - то же самое, что и `uintX`, но вы можете использовать параметр `X` в этом типе

## Ограничения

```tlb
_ флаги:(## 10) { flags <= 100 } = Flag;
```

Поле `Nat` разрешено в ограничениях. В данном примере ограничение `{ flags <= 100 }` означает, что переменная `flags` меньше
или
равняется `100`.

Допустимые константы: `E` | `E = E` | `E <= E` | `E < E` | `E >= E` | `E > E` | `E + E` | `E * E` | `E * E` | `E ? E`

## Неявные поля

Некоторые поля могут быть неявными. Their definitions are surrounded by curly
brackets(`{`, `}`), which indicate that the field is not actually present in the serialization, but that its value must
be deduced from other data (usually the parameters of the type being serialized). Например:

```tlb
ничего$0 {X:Type} = Может быть X;
just$1 {X:Type} значение:X = Может быть X;
```

```tlb
_ {x:#} a:(## 32) { ~x = a + 1 } = Пример;
```

## Типы параметров

Variables — i.e. the (identifiers of the) previously
defined fields of types `#` (natural numbers) or `Type` (type of types) — may be used as parameters for the parametrized
types. Процесс сериализации рекурсивно сериализует каждое поле в соответствии с его типом и сериализацией значения
в конечном итоге состоит из объединения битов, представляющих конструктор (i. . тег конструктора) и значения
полей.

### Природные числа (`Прит`)

```tlb
_ {x:#} my_val:(## x) = A x;
```

Это означает, что «A» параметризовано «x» «Nat». При десериализации мы получим `x`-bit unsigned integer E.g.:

```tlb
_ значение:(A 32) = My32UintValue;
```

Средства, чем в процессе десериализации типа `My32UintValue`, мы получим 32-битное неподписанное целое (из-за параметра `32`
в тип `A`)

### Типы

```tlb
_ {X:Type} my_val:(## 32) next_val:X = A X;
```

Это означает, что `A` параметризован по типу `X`. В процессе десериализации мы получим 32-битное неподписанное целое и чем
разбор
битов типа `X`.

Пример использования таких параметров может быть:

```tlb
_ bit:(## 1) = Bit;
_ 32intwbit:(A Bit) = 32IntWithBit;
```

В этом примере мы передаем тип `Bit` в `A` в качестве параметра.

Если вы не хотите определять тип, но хотите десериализовать с помощью этой схемы, вы можете использовать «Любое слово»:

```tlb
_ my_val:(A Any) = Пример;
```

Это означает, что если мы десериализуем тип `Example`, мы получим 32-битное целое, а затем оставляем ячейку (bits&refs) в `my_val`.

Вы можете создать сложные типы с несколькими параметрами:

```tlb
_ {X:Type} {Y:Type} my_val:(## 32) next_val:X next_next_val:Y = A X Y;
_ bit:(## 1) = Bit;
_ a_with_two_bits:(A Bit Bit) = AWithTwoBits;
```

Также можно использовать частичное применение таких параметров:

```tlb
_ {X:Type} {Y:Type} v1:X v2:Y = A X Y;
_ bit:(## 1) = Bit;
_ {X:Type} bits:(A Bit X) = BitA X;
```

Или даже сами параметры типов:

```tlb
_ {X:Type} v1:X = A X;
_ {X:Type} d1:X = B X;
_ {X:Type} бит:(A (B X)) = AB X;
```

### Использование полей NAT для параметризованных типов

Вы можете использовать поля, определенные ранее похожие на параметры для типов. Сериализация будет определяться во время выполнения.

Простой пример:

```tlb
_ а:(## 8) b:(## a) = A;
```

Это означает, что мы храним размер поля `b` внутри поля `a`. Таким образом, когда мы хотим сериализовать тип `A` нам нужно загрузить 8
бит беззнаковое целое поле `a`, а затем использовать это число для определения размера поля `b`.

Эта стратегия работает также и в отношении параметров типов:

```tlb
_ {input:#} c:(## input) = B input;
_ a:(## 8) c_in_b:(B a) = A;
```

### Выражение в параметрах типов

```tlb
_ {x:#} значение:(## x) = Пример (x * 2);
_ _:(Пример 4) = 2BitInteger;
```

В этом примере определен тип `Example.value` во время выполнения.

В определении `2BitInteger` мы устанавливаем значение типа `Example 4`. Для определения этого типа мы используем определение `Пример (x * 2)`
и вычисляем `x` по формуле (`y = 2`, `z = 4`):

```c++
static inline bool mul_r1(int& x, int y, int z) {
  return y && ! z % y) && (x = z / y) >= 0;
}
```

Мы также можем использовать добавить оператора:

```tlb
_ {x:#} значение:(## x) = Пример Sum (x + 3);
_ _:(Пример 4) = 1BitInteger;
```

В определении `1BitInteger` задаем значение типа `ExampleSum 4`. Для определения этого типа мы используем `ExampleSum (x + 3)`
и вычисляем `x` по формуле (`y = 3`, `z = 4`):

```c++
static inline bool add_r1(int& x, int y, int z) {
  return z >= y && (x = z - y) >= 0;
}
```

## Отрицательный оператор (`~`)

Некоторые случаи "переменных" (т.е. уже определенные поля) префиксы префикса tilde(`~`). Это означает, что вхождение переменной
используется противоположным способом к поведению по умолчанию: слева от уравнения, это
означает, что переменная будет вычтена (вычисленная) на основе этого случая, вместо замены ранее вычисленного значения
; в правой стороне, наоборот, это означает, что переменная не будет вычтена из типа
сериализована, но скорее то, что он будет вычислен в ходе процесса десериализации. In other words, a tilde transforms
an “input argument” into an “output argument” or vice versa.

Простой пример для negate оператора - определение новой переменной базы на другой переменной:

```tlb
_ а:(## 32) { b:# } { ~b = a + 100 } = B_Calc_Example;
```

После определения вы можете использовать новую переменную для передачи в `Nat` типы:

```tlb
_ a:(## 8) { b:# } { ~b = a + 10 }
  example_dynamic_var:(## b) = B_Calc_Example;
```

The size of `example_dynamic_var` will be computed in runtime, when we load `a` variable and use it value for
determination of `example_dynamic_var` size.

Или другим типам:

```tlb
_ {X:Type} a:^X = PutToRef X;
_ a:(## 32) { b:# } { ~b = a + 100 }
  my_ref: (PutToRef b) = B_Calc_Example;
```

Также вы можете определить переменные с помощью отрицательного оператора в добавлении или умножении сложных выражений:

```tlb
_ а:(## 32) { b:# } { ~b + 100 = a } = B_Calc_Example;
```

```tlb
_ a:(## 32) { b:# } { ~b * 5 = a } = B_Calc_Example;
```

### Отрицать оператора (`~`) в определении типа

```tlb
_ {m:#} n:(## m) = Определение ~n м;
_ {n_from_define:#} defined_val:(Определите ~n_from_define 8) real_value:(## n_from_define) = Пример;
```

Предположим, у нас есть класс `Определить ~n m`, который принимает `m` и вычисляет его загрузку из числа `m` бит не подписанного числа.

В типе `Пример` мы храним переменную, рассчитанную по типу `Define` в `n_from_define`, также мы знаем, что это `8` бит
unsigned integer, потому что мы применяем тип `Define` с помощью `Define ~n_from_define 8`. Теперь мы можем использовать `n_from_define` переменную
в других типах для определения процесса сериализации.

Эта техника приводит к более сложным определениям типов (например, Unions, Hashmaps).

```tlb
unary_zero$0 = Unary ~0;
unary_succ$1 {n:#} x:(Unary ~n) = Unary ~(n + 1);
_ u:(Unary Any) = UnaryChain;
```

Этот пример хорошо описывает [типы TL-B](/v3/documentation/data-formats/tlb/tl-b-types#unary)
статью. Основная идея здесь заключается в том, что `UnaryChain` рекурсивно десериализует до достижения `unary_zero$0` (потому что мы
знаем последний элемент типа `unary X` по определению `unary_zero$0 = Unary ~0; и `X`рассчитывается в режиме runtime
due`Unary ~(n + 1)\`).

Примечание: `x:(Unary ~n)` означает, что `n` определен в процессе сериализации класса `Unary`.

## Специальные типы

В настоящее время TVM разрешает типы камер:

- Обычный
- ПруннедВетвь
- Библиотека
- MerkleProof
- MerkleUpdate

По умолчанию все ячейки являются `Обычными`. И все клетки, описанные в tlb, являются "обычными".

Чтобы разрешить загрузку специальных типов в конструкторе, необходимо добавить `!` перед конструктором.

Например:

```tlb
!merkle_update#02 {X:Type} old_hash:bits256 new_hash:bits256
  old:^X new:^X = MERKLE_UPDATE X;

!merkle_proof#03 {X:Type} virtual_hash:bits256 depth:uint16 virtual_root:^X = MERKLE_PROOF X;
```

This technic allow codegen code to mark `SPECIAL` cells when you want to print structure, also it allow to correctly
validate structures with special cells.

## Несколько экземпляров одного типа без проверки уникальности конструкции

Допускается создание нескольких экземпляров одного типа в зависимости только от параметров типа.
Таким образом определение конструкторского тэга уникальная проверка не применяется.

Например:

```tlb
_ = A 1;
a$01 = A 2;
b$01 = A 3;
_ test:# = A 4;
```

Это означает, что фактический тег для десериализации будет определяться параметром типа `A`:

```python3
# класс для типа `A`
класса A(TLBComplex):
    тег класса (Enum):
        a = 0
        b = 1
        cons1 = 2
        cons4 = 3

    cons_len = [2, 2, 0, 0]
    cons_tag = [1, 1, 0, 0, 0]

    m_: int = None

    def __init__(себя, самое, m: int):
        себя. _ = m

    def get_tag(self, cs: CellSlice) -> Необязательно["A. ag"]:
        тэг = себя. _

        if tag == 1:
            return A. ag. ons1

        if tag == 2:
            return A. ag.a

        if tag == 3:
            return A. ag.

        если тег == 4:
            возврат А. ag.cons4

        не возвращает
```

То же самое работает с несколькими параметрами:

```tlb
_ = A 1 1;
a$01 = A 2 1;
b$01 = A 3 3;
_ тест:# = A 4 2;
```

Имейте в виду, что при добавлении определения типа параметра теги между предопределенным определением типа (`a`
и `b` в нашем примере) и
параметризованное определение типа (`c` в нашем примере) должны быть уникальными:

_Неправильный пример:_

```
a$01 = A 2 1;
b$11 = A 3 3;
c$11 {X:#} {Y:#} = A X Y;
```

_Допустимый пример:_

```tlb
a$01 = A 2 1;
b$01 = A 3 3;
c$11 {X:#} {Y:#} = A X Y;
```

## Комментарии

Комментарии совпадают с C++

```tlb
/*
Это
комментарий
*/

// Это комментарий в одной строке
```

## Полезные источники

- [Описание старой версии TL](https://core.telegram.org/mtproto/TL)
- [block.tlb](https://github.com/ton-blockchain/ton/blob/master/crypto/block/block.tlb)
- [tlbc tool](https://github.com/ton-blockchain/ton/blob/master/crypto/tl/tlbc.cpp)
- [Код CPP](https://github.com/ton-blockchain/ton/blob/master/crypto/tl/tlbc-gen-cpp.cpp)
- [тесты tlb тонны](https://github.com/disintar/tonpy/blob/main/src/tonpy/tests/test_tlb.py)
- [кодовый код](https://github.com/disintar/ton/blob/master/crypto/tl/tlbc-gen-py.cpp)

<hr/>

Документация предоставлена командой [Disintar](https://dton.io/).
