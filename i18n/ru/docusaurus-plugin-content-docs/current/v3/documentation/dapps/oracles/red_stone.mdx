import ThemedImage from '@theme/ThemedImage';

# Красный Оракл

## Как работают красные оракулы с TON

RedStone oracles используют альтернативный дизайн предоставления данных оракула для смарт-контрактов. Вместо постоянного хранения данных о договоре (поставщиками данных), информация передается в цепь только при необходимости (конечными пользователями). До этого момента данные остаются в децентрализованном слое кэша, который питается от шлюзов кэша RedStone и протоколом трансляции данных
потоков. Data is transferred to the contract by end users, who should attach signed data
packages to their function invocations. Целостность информации проверяется в цепочке через проверку подписи.

Чтобы узнать больше о дизайне оракулов RedStone перейдите на [документы RedStone](https://docs.redstone.finance/docs/introduction)

## Ссылки на документацию

- [Коннектор с редстоун](https://github.com/redstone-finance/redstone-oracles-monorepo/tree/main/packages/ton-connector)

## Умные контракты

### price_manager.fc

- Пример контракта на оракул, потребляющий данные об oracles RedStone [price_manager.fc](https://github.com/redstone-finance/redstone-oracles-monorepo/blob/main/packages/ton-connector/contracts/price_manager.fc) написано в
  FunC. Требуется [Обновление TVM 2023.07](/v3/documentation/tvm/changelog/tvm-upgrade-2023-07).

#### начальные данные

Как уже упоминалось выше, комплекты данных, переданные к контракту, проверяются посредством проверки подписи.
Для того, чтобы получить значение `signer_count_threshold`, подписавший передаваемые данные
должен быть одним из `signer_count_threshold`, передаваемых в начальных данных. Для прохождения
необходим `signer_count_threshold`.

Из-за архитектуры контрактов TON, начальные данные должны созываться с структурой хранения контракта,
который построен следующим образом:

```ts
  begin_cell()
    .store_uint(signer_count_threshold, 8) /// число, как передано ниже
    . tore_uint(timestamp, TIMESTAMP_BITS) /// изначально 0 представляет эпоху 0
    . tore_ref(signers) /// сериализованный трубок значений передаваемых ниже
  . nd_cell();
```

Значение `signers` должно быть передано в виде сериализованного `tuple` из `int`s.
See [tuple](https://github.com/ton-core/ton-core/blob/main/src/tuple/tuple.ts).

<!-- Для определения первоначальных данных (хранилища) для заключения договора о ценах используйте предопределенный
класс [PriceManagerInitData.ts](../src/price-manager/PriceManagerInitData.ts). -->

In the function parameters below, each `feed_id` is a string encoded to `int` which means, that's a value
consisting of hex-values of the particular letters in the string. Например:
`ETH'` как `int` — это `0x455448` в шестнадцатеричном режиме или `4543560` в десятичной, как `256*256*ord('E')+256*ord('T')+ord('H')`.

Вы можете использовать: `feed_id=hexlify(toUtf8Bytes(feed_string))` для преобразования конкретных значений или
 [endpoint](https://cairo-utils-web.vercel.app/)

Значение `feed_ids` должно быть передано в виде сериализованного `tuple` из `int`s.

Значение `payload` упаковано из массива байт, представляющих сериализованный RedStone полезный груз.
См. раздел [TON RedStone payload-packing](#ton-redstone-payload-packing), а также файл [constants.fc](https://github.com/redstone-finance/redstone-oracles-monorepo/blob/main/packages/ton-connector/contracts/redstone/constants.fc), содержащий все необходимые константы `int`-длины.

#### получить цены

```func
(ячейка) get_prices_v2 (данные ячейки_feed_ids, полезная нагрузка) method_id;
```

Функция обрабатывает on-chain `payload` передается в качестве аргумента
и возвращает `cell` агрегированных значений каждого канала, передаваемого как идентификатор внутри `feed_ids`.

Из-за ограничения длины метода HTTP GET в TON API v4, функция написана для TON API v2.

Это всего лишь функции `method_id` - они не изменяют хранилище контракта и не потребляют TON.

#### OP_REDSTON_WRITE_PLAYLIST

Независимо от процесса обработки на лете, существует также метод обработки цепочки `payload`, но
сохранения/записи агрегированных значений на хранилище контракта. Значения сохраняются в хранилище контракта, а затем могут быть прочитаны с помощью функции `read_prices`. Дата последнего сохранения/написания в контракте может читать с помощью функции `read_timestamp`.

Метод должен быть использован как внутреннее сообщение TON. Аргументами сообщения являются:

- `int`, представляющий имена RedStone_Write_Цены, хэшированные keccak256, как определено
  в [constants.ts](https://github.com/redstone-finance/redstone-oracles-monorepo/blob/main/packages/ton-connector/src/config/constants.ts)
- `cell` - ссылка, представляющая `data_feed_ids` в виде сериализованного `tuple` из `int`s.\
- `cell` - реф-файл, представляющий упакованную полезную нагрузку RedStone

```func
    int op = in_msg_body~load_uint(OP_NUMBER_BITS);

    if (op == OP_REDSTONE_WRITE_PRICES) {
        клеток data_feeds_cell = in_msg_body~load_ref();
        клеток payload_cell = in_msg_body~load_ref();

    // ...
}
```

Это внутреннее сообщение - оно потребляет ГАС и изменяет хранение договора, поэтому оплачивается TON.

Узнайте, как это работает: https://ton-showroom.redstone.finance/

#### чита_цены

```func
(tuple) read_prices(tuple data_feed_ids) method_id;
```

Функция считывает значения, сохраняющиеся в хранилище контракта, и возвращает трубочку, соответствующий
прошедшему `feed_ids`.
Функция не изменяет хранилище и может читать только агрегированные значения `feed_ids`, сохраненные
с помощью функции `write_prices`.

Это всего лишь функция `method_id` - она не изменяет хранилища контракта и не потребляет TON.

#### read_timestamp

```func
int) read_timestamp() method_id;
```

Возвращает дату последнего сохранения/записи данных в хранилище контракта, используя сообщение `OP_REDSTONE_WRITE_PRICES`.

Это всего лишь функция `method_id` - она не изменяет хранилища контракта и не потребляет TON.

### price_feed.fc

Из-за архитектуры контрактов TON, начальные данные должны созываться с структурой хранения контракта,
который построен следующим образом:

```ts
beginCell()
  .storeUint(BigInt(hexlify(toUtf8Bytes(this.feedId))), consts.DATA_FEED_ID_BS * 8)
  .storeAddress(Address.parse(this.managerAddress))
  . toreUint(0, consts.DEFAULT_NUM_VALUE_BS * 8) /// изначально 0 представляющего эпоху 0
  .storeUint(0, consts.TIMESTAMP_BS * 8)
  .endCell();
```

Для определения первоначальных данных (хранилища) для контракта о ценовом фиде, используйте предопределенные
класса [PriceFeedInitData.ts](https://github.com/redstone-finance/redstone-oracles-monorepo/blob/main/packages/ton-connector/src/price-feed/PriceFeedInitData.ts).

#### OP_REDSTON_FETCH_DATA

Независимо от того, читаются ли значения контракта сохраняются вне сети,
существует возможность получения значения, хранимого в контракте для прямой цепочки `feed_id`.
Необходимо вызвать внутреннее сообщение `OP_REDSTONE_FETCH_DATA`. Аргументами сообщения являются:

- `int`, представляющий имя `RedStone_Fetch_Data`, хэшированное keccak256, как определено
  в [constants.ts](https://github.com/redstone-finance/redstone-oracles-monorepo/blob/main/packages/ton-connector/src/config/constants.ts)
- `int` представляющий значение `feed_id`.
- `slice`, представляющий сообщение `initial_sender`, чтобы позволить им перенести оставшийся баланс транзакций
  при возвращении транзакции.

```func
    int op = in_msg_body~load_uint(OP_NUMBER_BITS);

    if (op == OP_REDSTONE_FETCH_DATA) {
        int feed_id = in_msg_body~load_uint(DATA_FEED_ID_BITS);
        cell initial_payload = in_msg_body~load_ref();

        // ...
}
```

Сообщение `OP_REDSTONE_DATA_FETCHED` отправлено отправителю, содержащему `value` и
сохраненный `timestamp` значения. The message can be then fetched in the sender and processed or saved in the
sender's storage.
The initial payload's `ref` (`initial_payload`) is added as a ref - containing for example the first message's sender,
to allow they carry the remaining transaction balance.

```ts
begin_cell()
  .store_uint(value, MAX_VALUE_SIZE_BITS)
  .store_uint(timestamp, TIMESTAMP_BITS)
  .store_ref(initial_payload)
  .end_cell()
```

Это внутреннее сообщение - оно потребляет ГАС и изменяет хранение договора, поэтому оплачивается TON.

#### get_price_and_timestamp

```func
(int, int) get_price_and_timestamp() method_id;
```

Возвращает значение и дату последнего сохранения/записи данных в хранилище адаптера, отправив сообщение `OP_REDSTONE_FETCH_DATA` и получив возвращаемое значение сообщения `OP_REDSTONE_DATA_FETCHED`.

Это всего лишь функция `method_id` - она не изменяет хранилища контракта и не потребляет TON.

### single_feed_man.fc

#### начальные данные

Схожи с начальными ценами и "price_feed". В связи с архитектурой контрактов TON, первоначальные данные должны созываться с структурой хранения контракта, которая построена следующим образом:

```ts
beginCell()
  .storeUint(BigInt(hexlify(toUtf8Bytes(this.feedId))), consts.DATA_FEED_ID_BS * 8)
  .storeUint(this.signerCountThreshold, SIGNER_COUNT_THRESHOLD_BITS)
  .storeUint(0, consts.DEFAULT_NUM_VALUE_BS * 8)
  .storeUint(0, consts.TIMESTAMP_BS * 8)
  .storeRef(serializeTupleItems(this.signers)))
  .endCell();
```

Для определения первоначальных (хранилища) данных для контракта о ценах используйте предопределенные
класса [SingleFeedManInitData.ts](https://github.com/redstone-finance/redstone-oracles-monorepo/blob/main/packages/ton-connector/src/single-feed-man/SingleFeedManInitData.ts).

Контракт типа `price_manager`, но поддержка
только одного канала, чтобы исключить потребности коммуникации между контрактами фида и менеджера.

#### get_price

```func
(int, int) get_price(cell payload) method_id;
```

Как и в `get_prices`, но пропуская первый аргумент (`data_feed_ids`), он настроен во время
инициализации. Возвращает также минимальную отметку времени для переданных пакетов данных.

#### read_price_and_timestamp

```func
(int, int) read_price_and_timestamp() method_id;
```

Работает как функция `get_price_and_timestamp`.

#### OP_REDSTON_WRITE_PLAYLIST

Подобно `OP_REDSTONE_WRITE_PRICES`, но не выполняя первый (`data_feed_ids`) `cell`-ref настроен во время инициализации.

```func
    int op = in_msg_body~load_uint(OP_NUMBER_BITS);

    if (op == OP_REDSTONE_WRITE_PRICE) {
        cell payload_cell = in_msg_body~load_ref();

        // ...
}
```

### sample_consumer.fc

Пример потребителя для данных, хранящихся в `price_feed`. Работает также с `single_feed_man`.
Необходимо передать `price_feed`.

#### начальные данные

Подобно исходным данным `price_feed`. В связи с архитектурой контрактов TON, первоначальные данные должны созываться с структурой хранения контракта, которая построена следующим образом:

```ts
beginCell()
  .storeAddress(Address.parse(this.feedAddress))
  .endCell();
```

Для определения первоначальных данных (хранилища) для договора о ценах используйте предопределенные
класса [SampleConsumerInitData.ts](https://github.com/redstone-finance/redstone-oracles-monorepo/blob/main/packages/ton-connector/src/sample-consumer/SampleConsumerInitData.ts).

Контракт называет один канал.

#### OP_REDSTON_READ_DATA

Существует возможность получения значения, хранящегося в контракте для цепочки `feed_id`.
Необходимо вызвать внутреннее сообщение `OP_REDSTONE_READ_DATA`. Аргументами сообщения являются:

- `slice`, представляющий сообщение `initial_sender`, чтобы позволить им перенести оставшийся баланс транзакций
  при возвращении транзакции.

```func
    int op = in_msg_body~load_uint(OP_NUMBER_BITS);

    if (op == OP_REDSTONE_READ_DATA) {
        cell initial_payload = in_msg_body~load_ref();

        // ...
}
```

Отправляющее сообщение `OP_REDSTONE_DATA_READ` отправляется отправителю, содержащему `feed_id`, `value` и
сохранено значение `timestamp`. The message can be then fetched in the sender and processed or saved in the
sender's storage.
The initial payload's `ref` (`initial_payload`) is added as a ref - containing for example the first message's sender,
to allow they carry the remaining transaction balance.

```ts
begin_cell()
  .store_uint(value, MAX_VALUE_SIZE_BITS)
  .store_uint(timestamp, TIMESTAMP_BITS)
  .store_ref(initial_payload)
  .end_cell()
```

Это внутреннее сообщение - оно потребляет ГАС и изменяет хранение договора, поэтому оплачивается TON.

## Упаковка на нагрузку TON RedStone

Из-за ограничений размера сумки в TON [see](/v3/documentation/data-formats/tlb/cell-boc),
данные полезной нагрузки RedStone - представляемые как шестнадцатеричная строка должны быть переданы контракту более сложным образом.

Наличие нагрузки RedStone как определена [here](https://docs.redstone.finance/img/payload.png),
данные должны передаваться в виде ячейки, построенной следующим образом.

1. Главная _payload_ `cell` состоит из:

   1. метаданные в **битах уровня данных**, состоящих из частей, как на изображении:

     ![payload-metadata.png](/img/docs/oracles/red-stone/payload-metadata.png)

   1. **ref**, содержащий `udict`, индексированный последовательными природными числами (от 0), содержащими список **data_package** `cell`s.
2. Каждый _пакет данных_ `cell` состоит из:

   1. подпись пакета данных в **битах уровня данных**:

     ![payload-metadata.png](/img/docs/oracles/red-stone/payload-metadata.png)

   1. один **ref** к «ячейке», содержащей данные остального пакета данных на его **уровне данных**:

     ![payload-metadata.png](/img/docs/oracles/red-stone/data-package-data.png)

#### Нынешние ограничения по реализации

- The RedStone payload must be fetched by explicitly defining data feeds,
  which leads to **one data point** belonging to **one data package**.
- Размер неподписанных метаданных не должен превышать `127 - (2 + 3 + 9) = 113` байт.

#### Помощник

The `createPayloadCell` method in the [create-payload-cell.ts](https://github.com/redstone-finance/redstone-oracles-monorepo/blob/main/packages/ton-connector/src/create-payload-cell.ts) file
checks the limitations and prepares the data to be sent to the contract as described above.

#### Пример сериализации

Изображение ниже содержит данные для `2` каналов умножения `2` уникальных знаков:
![payload-metadata.png](/img/docs/oracles/red-stone/sample-serialization.png)

## Возможные ошибки транзакции

- Количество подписавших, воспроизведенных из подписей, совпадающих с `addresses` в инициализаторе
  должно быть больше или равно тому, что `signer_count_threshold` в конструкторе, для каждой ленты.
  - В противном случае паника при ошибке `300` увеличилась на первый индекс проданного канала
    , который нарушил проверку.
- Временная метка пакетов данных должна быть не старше 15 минут по отношению к \``block_timestamp`.
  - В противном случае паники при ошибке `200` увеличились на первый индекс пакета данных полезной нагрузки
    , который нарушил проверку, увеличивается дополнительно на `50`, если временная метка пакета слишком мала
    .
- Внутренние сообщения потребляют газ и должны оплачиваться ТОН. The data are available on the contract
  just after the transaction successes.
- Другие коды ошибок определены [here](https://github.com/redstone-finance/redstone-oracles-monorepo/blob/main/packages/ton-connector/src/config/constants.ts)

## Смотреть также

- [Документы внутренних сообщений](/v3/documentation/smart-contracts/message-management/internal-messages)
- [Упаковка данных RedStone](https://docs.redstone.finance/docs/smart-contract-devs/how-it-works)
- [RedStone oracles smart-contracts](https://github.com/redstone-finance/redstone-oracles-monorepo/tree/main/packages/ton-connector/contracts)
