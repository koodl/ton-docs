import Button from '@site/src/components/button'

# TON Connect для роботов Telegram

:::warning устаревшее
В этом руководстве описывается устаревший метод интеграции TON Connect с Telegram Bots. Для более безопасного и современного подхода попробуйте использовать [Telegram Mini Apps](/v3/guidelines/dapps/tma/overview для более современной и безопасной интеграции.
:::

В этом уроке мы разработаем образец Telegram бота с помощью JavaScript TON Connect SDK, который поддерживает TON Connect 2.0.
Это руководство описывает соединения с кошельками, отправку транзакций, получение информации о кошельке и отключение кошельков.

<Button href="https://t.me/ton_connect_example_bot" colorType={'primary'} sizeType={'sm'}>

Открыть демо бота

</Button>

<Button href="https://github.com/ton-connect/demo-telegram-bot" colorType={'secondary'} sizeType={'sm'}>

Check out GitHub

</Button>

## Ссылки на документацию

- [TON Connect SDK documentation](https://www.npmjs.com/package/@tonconnect/sdk)

## Предпосылки

- Вам нужно создать телеграмму бота используя [@BotFather](https://t.me/BotFather) и сохранить его токен.
- Узел JS должен быть установлен (мы используем в этом учебнике версию 18.1.0).
- Докер должен быть установлен.

## Создание проекта

### Настройка зависимостей

Начните с создания проекта Node.js. Мы будем использовать библиотеку TypeScript и [node-telegram-bot-api](https://www.npmjs.com/package/node-telegram-bot-api), хотя вы можете выбрать альтернативную библиотеку, если хотите. Также мы будем использовать библиотеку [qrcode](https://www.npmjs.com/package/qrcode) для генерации QR-кодов, но вы можете заменить ее на любую другую библиотеку.

Давайте создадим каталог `ton-connect-bot`. Добавьте туда следующий файл package.json:

```json
{
  "name": "Тон-connect-bot",
  "версия": "1.0. ",
  "scripts": {
    "compile": "npx rimraf dist && tsc",
    "run": "node . dist/main.js"
  },
  "dependencies": {
    "@tonconnect/sdk": "^3.0.0-beta.1",
    "dotenv": "^16.0. ",
    "node-telegram-bot-api": "^0.61.0",
    "qrcode": "^1.5. "
  },
  "devDependencies": {
    "@types/node-telegram-bot-api": "^0. 1.4",
    "@types/qrcode": "^1.5.0",
    "rimraf": "^3. .2",
    "typescript": "^4.9.5"
  }
}
```

Запустите `npm i` для установки зависимостей.

### Добавить tsconfig.json

Создать `tsconfig.json`:

<details>
<summary>tsconfig.json код</summary>

```json
{
  "compilerOptions": {
    "объявление": true,
    "lib": ["ESNext", "dom"],
    "resolveJsonModule": true,
    "experimentalDecorators": false,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "target": "es6",
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "strictPropertyInitialization": true,
    "noImplicitThis": true,
    "всегда": true,
    "noUnusedLocals": false,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "module": "commonjs",
    "Разрешение модуля": "node",
    "sourceMap": true,
    "useUnknownInCatchVariables": false,
    "noUncheckedIndexedAccess": true,
    "emitDecoratorMetadata": false,
    "Импортировать Helpers": false,
    "skipLibCheck": true,
    "skipDefaultLibCheck": true,
    "allowJs": true,
    "outDir": ". dist"
  },
  "include": ["src"],
  "Исключить": [
    "./tests","node_modules", "lib", "types"]
}
```

</details>

[Подробнее о tsconfig.json](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html)

### Добавить простой бот код

Создайте файл `.env` и добавьте ваш токен бота, DAppmanifest и кэш списков кошельков там, чтобы он жил:

[Подробнее о tonconnect-manifes.json](https://github.com/ton-connect/sdk/tree/main/packages/sdk#add-the-tonconnect-manifest)

```dotenv
# .env
TELEGRAM_BOT_TOKEN=<YOUR BOT TOKEN, E.G 1234567890:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA>
TELEGRAM_BOT_LINK=<YOUR TG BOT LINK HERE, E.G. https://t.me/ton_connect_example_bot>
MANIFEST_URL=https://raw.githubusercontent.com/ton-connect/demo-telegram-bot/master/tonconnect-manifest.json
WALLETS_LIST_CACHE_TTL_MS=86400000
```

Создайте каталог `src` и файл `bot.ts` внутри. Давайте создадим экземпляр TelegramBot:

```ts
// src/bot.ts

import TelegramBot from 'node-telegram-bot-api';
import * as process from 'process';

const token = process. nv.TELEGRAM_BOT_TOKEN!;

экспорт бота = новый TelegramBot(токен, { polling: true });
```

Теперь мы можем создать файл `main.ts` в папке `src`:

```ts
// src/main.ts
import dotenv from 'dotenv';
dotenv.config();

import { bot } from './bot';

bot. n('message', msg => {
  const chatId = msg.chat.id;

  bot.sendMessage(chatId, 'Получено ваше сообщение');
});
```

Здесь мы идем. Вы можете запустить `npm compile` и `npm запустить start` и отправить любое сообщение вашему боту. Бот ответит «Получено ваше сообщение». Мы готовы к интеграции TonConnect.

На данный момент у нас есть структура файлов:

```text
ton-connect-bot
├── src
│   ├── bot.ts
│   └── main.ts
├── package.json
├── package-lock.json
├── .env
└── tsconfig.json
```

## Подключение кошелька

После установки `@tonconnect/sdk`, мы можем начать с импорта для инициализации подключения к кошельку.

Мы начнем с получения списка кошельков. Нам нужны только http-bridge-совместимые кошельки. Создайте папку `ton-connect` в `src` и добавьте туда файл `wallets.ts`:
Мы также определим функцию `getWalletInfo`, которая запрашивает подробную информацию о кошельке по ссылке `appName`.
Разница между `name` и `appName` состоит в том, что `name` является человеко-читаемым ярлыком кошелька, а `appName` является uniq идентификатором кошелька.

```ts
// src/ton-connect/wallets.ts

import { isWalletInfoRemote, WalletInfoRemote, WalletsListManager } from '@tonconnect/sdk';

const walletsListManager = new WalletsListManager({
    cacheTTLMs: Number(process. nv.WALLETS_LIST_CACHE_TTL_MS)
});

export async function getWallets(): Promise<WalletInfoRemote[]> {
    const кошельки = await walletsListManager. etWallets();
    возвращаемых кошельков. ilter(isWalletInfoRemote);
}

export async function getWalletInfo(walletAppName: string): Promise<WalletInfo | undefined> {
    const кошельки = await getWallets();
    возвращают кошельки. ind(кошелёк => wallet.appName.toLowerCase() === walletAppName.toLowerCase());
}
```

Теперь нам нужно определить хранилище TonConnect. TonConnect использует `localStorage` для сохранения информации о соединении при запуске в браузере, однако в среде NodeJS нет `localStorage`. Поэтому мы должны добавить пользовательскую реализацию простого хранилища.

[Подробнее о памяти TonConnect](https://github.com/ton-connect/sdk/tree/main/packages/sdk#init-connector)

Создайте `storage.ts` внутри папки `ton-connect`:

```ts
// src/ton-connect/storage.ts

import { IStorage } from '@tonconnect/sdk';

const storage = new Map<string, string>(); // реализация временного хранения. Мы заменим его на redis позже

export class TonConnectStorage implements IStorage {
  constructor(private readonly chatId: number) {} // Нам нужны различные магазины для разных пользователей

  private getKey(key: string): string {
    return this. Id. oString() + ключ; // у нас будут просто разные префиксы ключей для разных пользователей
  }

  асинхронного removeItem(key: string): Promise<void> {
    storage. elete(this.getKey(key));
  }

  async setItem(key: string, value: string): Promise<void> {
    storage. et(this.getKey(key), value);
  }

  async getItem(key: string): Promise<string | null> {
    return storage. et(this.getKey(key)) || null;
  }
}
```

Мы движемся по внедрению соединения с кошельком.
Измените команду `src/main.ts` и добавьте `connect`. Мы выполним подключение к кошельку в этом обработчике команд.

```ts
import dotenv from 'dotenv';
dotenv.config();

import { bot } from './bot';
import { getWallets } from '. ton-connect/wallets';
импортирует TonConnect из '@tonconnect/sdk';
импортировать { TonConnectStorage } из './ton-connect/storage';
импортировать QRCode из 'qrcode';

бот. nText(/\/connect/, async msg => {
  const chatId = msg.chat. d;
  Кошельки = ожидать getWallets();

  const connector = new TonConnect({
    storage: new TonConnectStorage(chatId),
    manifestUrl: process. nv.MANIFEST_URL
  });

  коннектора. nStatusChange(wallet => {
    if (wallet) {
      bot. endMessage(chatId, `${wallet.device.appName} кошелек подключен!`);
    }
  });

  const tonkeeper = кошельки. ind(кошелек => wallet.appName === 'tonkeeper')!;

  const link = коннектор. onnect({
    bridgeUrl: tonkeeper.bridgeUrl,
    universalLink: tonkeeper.universalLink
  });
  const image = ожидание QRCode.toBuffer(link);

  await bot.sendPhoto(chatId, image);
});
```

Давайте проанализируем, что мы делаем здесь. Во-первых, мы получаем список кошельков и создаем экземпляр TonConnect.
После этого мы подписываемся на изменение кошелька. Когда пользователь подключается к кошельку, бот отправит сообщение `${wallet.device.appName} кошелек подключен!`.
Далее мы найдем кошелек Tonkeeper и создадим ссылку на соединение. В конце концов, мы генерируем QR-код со ссылкой и отправляем его как фото пользователю.

Теперь вы можете запустить бота (`npm run compile` и `npm run start` then) и отправить сообщение `/connect` боту. Бот должен ответить с QR. Сканируйте это с помощью кошелька Tonkeeper. Вы увидите сообщение `Tonkeeper кошелек подключен!` в чате.

Мы будем использовать коннектор во многих местах, поэтому давайте переместим коннектор для создания кода в отдельный файл:

```ts
// src/ton-connect/connector.ts

import TonConnect from '@tonconnect/sdk';
import { TonConnectStorage } from '. storage;
импортировать * как процесс из процесса;

export function getConnector(chatId: number): TonConnect {
    return new TonConnect({
        manifestUrl: process. nv.MANIFEST_URL,
        хранилище: новый TonConnectStorage(chatId)
    });
}
```

И импортируйте его в `src/main.ts`

```ts
// src/main.ts

import dotenv from 'dotenv';
dotenv.config();

import { bot } from '. bot';
импортировать { getWallets } из './ton-connect/wallets';
импортировать QRCode из 'qrcode';
импортировать { getConnector } из '. ton-connect/connector';

bot.onText(/\/connect/, async msg => {
    const chatId = msg.chat. d;
    Кошельки = ожидать getWallets();

    коннектор = getConnector(chatId);

    коннектор. nStatusChange(wallet => {
        if (wallet) {
            bot. endMessage(chatId, `${wallet.device.appName} кошелек подключен! );
        }
    });

    const tonkeeper = кошельки. ind(кошелек => wallet.appName === 'tonkeeper')!;

    const ссылка = коннектор. onnect({
        bridgeUrl: tonkeeper.bridgeUrl,
        universalLink: tonkeeper.universalLink
    });
    const image = ожидание QRCode.toBuffer(link);

    await bot.sendPhoto(chatId, image);
});
```

На данный момент у нас есть структура файлов:

```text
bot-demo
├── src
│   ├── ton-connect
│   │   ├── connector.ts
│   │   ├── wallets.ts
│   │   └── storage.ts
│   ├── bot.ts
│   └── main.ts
├── package.json
├── package-lock.json
├── .env
└── tsconfig.json
```

## Создание меню подключения кошелька

### Добавить встроенную клавиатуру

Мы завершили подключение к кошельку Tonkeeper. Но мы не установили соединение через универсальный QR-код для всех кошельков и не позволили пользователю выбрать подходящий кошелек. Давайте рассмотрим это сейчас.

Для лучшего UX мы будем использовать телеграммы `callback_query` и `inline_keyboard`. If you don't fill familiar with that, you can read more about it [here](https://core.telegram.org/bots/api#callbackquery).

Мы будем реализовывать следующий UX для подключения к кошельку:

```text
Первый экран:
<Unified QR>
<Open @wallet>, <Choose a wallet button (opens second screen)>, <Open wallet unified link>

Второй экран:
<Unified QR>
<Back (opens first screen)>
<@бумажник (открывает третий экран)>, <Tonkeeper button (opens third screen)>, <Tonhub button (opens third screen)>, <. .>

Третий экран:
<Selected wallet QR>
<Back (opens second screen)>
<Open selected wallet link>
```

Давайте начнем с добавления встроенной клавиатуры в обработчик команды `/connect` в папке `main.ts`

```ts
// src/main.ts
bot.onText(/\/connect/, async msg => {
    const chatId = msg.chat. d;
    const кошельки = await getWallets();

    const коннектор = getConnector(chatId);

    коннектор. nStatusChange(async wallet => {
        if (wallet) {
            const walletName =
                (await getWalletInfo(кошелек). evice.appName)?.name || wallet.device.appName;
            бот. endMessage(chatId, `${walletName} кошелек подключен! );
        }
    });

    const ссылка = коннектор. onnect(кошельки);
    const image = ожидание QRCode.toBuffer(link);

    ожидает бота. endPhoto(chatId, изображение, {
        reply_markup: {
            inline_keyboard: [
                [
                    {
                        text: 'Выберите Wallet',
                        callback_data: JSON. tringify({ method: 'chose_wallet' })
                    },
                    {
                        текст: 'Open Link',
                        url: `https://ton-connect. ithub. o/open-tc? onnect=${encodeURIComponent(
                            link
                        )}`
                    }
                ]
            ]
        }
    });
});
```

Нам нужно обнулить TonConnect как https://ton-connect.github.io/open-tc?connect=${encodeURIComponent(link)}, потому что только ссылки `http` разрешены в Telegram inline клавиатуре.
Сайт https://ton-connect.github.io/open-tc просто перенаправляет пользователя на ссылку, передаваемую в параметре запроса `connect`, так что это только для открытия ссылки `tc://` в Telegram.

Обратите внимание, что мы заменили аргументы вызова `connector.connect`. Теперь мы генерируем единую ссылку для всех кошельков.

Далее мы говорим Telegram вызвать обработчика `callback_query` с помощью значения `{ "method": "chose_wallet" }` при нажатии пользователем кнопки `Choose a Wallet`.

### Добавить обработчик кнопки выбора кошелька

Создайте файл `src/connect-wallet-menu.ts`.

Давайте добавим кнопку «Выбрать кошелёк» там, нажав на обработчик:

```ts
// src/connect-wallet-menu. s

async function onChooseWalletClick(query: CallbackQuery, _: string): Promise<void> {
    const кошельки = await getWallets();

    ожидает бота. ditMessageReplyMarkup(
        {
            inline_keyboard: [
                кошельки. ap(кошелек => ({
                    текст: кошелек. ame,
                    callback_data: JSON. tringify({ method: 'select_wallet', data: wallet.appName })
                })),
                [
                    {
                        текст: '« Назад',
                        callback_data: JSON. tringify({
                            method: 'universal_qr'
                        })
                    }
                ]
            ]
        },
        {
            message_id: запрос. essage!.message_id,
            chat_id: query.message!. hat.id
        }
    );
}
```

Здесь мы заменим сообщение встроенной клавиатурой на новое, которое содержит интерактивный список кошельков и кнопку 'Назад'.

Теперь мы добавим глобальный обработчик `callback_query` и зарегистрируем `onChooseWalletClick`:

```ts
// src/connect-wallet-menu.ts
import { CallbackQuery } from 'node-telegram-bot-api';
import { getWallets } from './ton-connect/wallets';
import { bot } from '. bot';

export const walletMenuCallbacks = { // Определение кнопок вызовов
    chose_wallet: onChooseWalletClick
};

bot. n('callback_query', query => { // Parse callback data and execute corresponding function
    if (!query. ata) {
        return;
    }

    let request: { method: string; data: строка };

    try {
        request = JSON. арсе(запрос). ata);
    } catch {
        return;
    }

    if (! alletMenuCallbacks[request. ethod как ключ типа walletMenuCallbacks]) {
        return;
    }

    walletMenuCallbacks[request. ethod как ключ типа кошелька MenuCallbacks](query, request.data);
});

// ... другой код предыдущего стержня
асинхронная функция onChooseWalletClick ...
```

Здесь мы определяем список обработчиков кнопок и парсер `callback_query`. К сожалению, данные обратного вызова всегда строки, поэтому мы должны передать JSON в `callback_data` и разобрать его позже в обработчике `callback_query`.
Затем мы ищем запрошенный метод и вызываем его с переданными параметрами.

Теперь нам нужно добавить импорт `connect-wallet-menu.ts` в `main.ts`

```ts
// src/main.ts

// ... other imports

import './connect-wallet-menu';

// ... other code
```

Компилировать и запустить бота. Вы можете нажать на кнопку Выбрать кошелек и бот заменит встроенные кнопки клавиатуры!

### Добавить другие обработчики кнопок

Давайте завершим это меню и добавим обработчики команд.

Во-первых, мы создадим утилиту `editQR`. Редактирование медиа сообщения (QR-изображения) немного сложно. Мы должны сохранить изображение в файл и отправить его на сервер Telegram. Затем мы можем удалить этот файл.

```ts
// src/connect-wallet-menu.ts

// ... other code


async function editQR(message: TelegramBot. essage, link: string): Promise<void> {
    const fileName = 'QR-code-' + Math. ound(Math.random() * 1000000000000);

    ждёт QRCode.toFile(`./${fileName}`, link);

    ожидание бота. ditMessageMedia(
        {
            тип: 'photo',
            Медиа: `attach://${fileName}`
        },
        {
            message_id: message?. essage_id,
            chat_id: message?.chat. d
        }
    );

    ожидает нового Promise(r => fs. m(`./${fileName}`, r));
}
```

В обработчике `onOpenUniversalQRClick` мы просто регенерируем QR и изменяем сообщение:

```ts
// src/connect-wallet-menu.ts

// ... other code

async function onOpenUniversalQRClick(query: CallbackQuery, _: string): Promise<void> {
    const chatId = query.message!.chat. d;
    кошельки = await getWallets();

    коннектор = getConnector(chatId);

    коннектор. nStatusChange(wallet => {
        if (wallet) {
            bot. endMessage(chatId, `${wallet.device.appName} кошелек подключен! );
        }
    });

    const ссылка = коннектор. onnect(wallets);

    ожидает editQR(query.message!, ссылка);

    ожидает бота. ditMessageReplyMarkup(
        {
            inline_keyboard: [
                [
                    {
                        text: 'Choose a Wallet',
                        callback_data: JSON. tringify({ method: 'chose_wallet' })
                    },
                    {
                        текст: 'Open Link',
                        url: `https://ton-connect. ithub. o/open-tc? onnect=${encodeURIComponent(
                            link
                        )}`
                    }
                ]
            ]
        },
        {
            message_id: запрос. essage?.message_id,
            chat_id: query.message?.chat. d
        }
    );
}

// ... другой код
```

В обработчике `onWalletClick` мы создаем специальную QR и универсальную ссылку только для выбранного кошелька, а также изменяем сообщение.

```ts
// src/connect-wallet-menu.ts

// ... other code

async function onWalletClick(query: CallbackQuery, data: string): Promise<void> {
    const chatId = query. essage!.chat.id;
    const коннектор = getConnector(chatId);

    коннектор. nStatusChange(wallet => {
        if (wallet) {
            bot. endMessage(chatId, `${wallet.device.appName} кошелек подключен! );
        }
    });

    const selectedWallet = await getWalletInfo(данные);
    if (! electedWallet) {
        Возвращение;
    }

    const ссылка = коннектор. onnect({
        bridgeUrl: selectedWallet.bridgeUrl,
        universalLink: selectedWallet.universalLink
    });

    ожидает editQR(query.message!, ссылка);

    ожидает бота. ditMessageReplyMarkup(
        {
            inline_keyboard: [
                [
                    {
                        text: '"Назад",
                        callback_data: JSON. tringify({ method: 'chose_wallet' })
                    },
                    {
                        текст: `Open ${selectedWallet.name}`,
                        url: ссылка
                    }
                ]
            ]
        },
        {
            message_id: запрос. предание?. essage_id,
            chat_id: chatId
        }
    );
}

// . . другой код
```

Теперь мы должны зарегистрировать эти функции как обратные вызовы (`walletMenuCallbacks`):

```ts
// src/connect-wallet-menu.ts
import TelegramBot, { CallbackQuery } from 'node-telegram-bot-api';
import { getWallets } from './ton-connect/wallets';
import { bot } from '. bot';
import * as s from 'fs';
import { getConnector } from '. ton-connect/connector';
импорт QRCode из 'qrcode';

экспорт const walletMenuCallbacks = {
    chose_wallet: onChooseWalletClick,
    select_wallet: onWalletClick,
    universal_qr: onOpenUniversalQRClick
};

// ... other code
```

<details>
<summary>В настоящее время src/connect-wallet-menu.ts похоже на</summary>

```ts
// src/connect-wallet-menu.ts

import TelegramBot, { CallbackQuery } from 'node-telegram-bot-api';
import { getWallets, getWalletInfo } from './ton-connect/wallets';
import { bot } from './bot';
import { getConnector } from './ton-connect/connector';
import QRCode from 'qrcode';
import * as fs from 'fs';

export const walletMenuCallbacks = {
    chose_wallet: onChooseWalletClick,
    select_wallet: onWalletClick,
    universal_qr: onOpenUniversalQRClick
};

bot.on('callback_query', query => { // Parse callback data and execute corresponing function
    if (!query.data) {
        return;
    }

    let request: { method: string; data: string };

    try {
        request = JSON.parse(query.data);
    } catch {
        return;
    }

    if (!callbacks[request.method as keyof typeof callbacks]) {
        return;
    }

    callbacks[request.method as keyof typeof callbacks](query, request.data);
});


async function onChooseWalletClick(query: CallbackQuery, _: string): Promise<void> {
    const wallets = await getWallets();

    await bot.editMessageReplyMarkup(
        {
            inline_keyboard: [
                wallets.map(wallet => ({
                    text: wallet.name,
                    callback_data: JSON.stringify({ method: 'select_wallet', data: wallet.appName })
                })),
                [
                    {
                        text: '« Back',
                        callback_data: JSON.stringify({
                            method: 'universal_qr'
                        })
                    }
                ]
            ]
        },
        {
            message_id: query.message!.message_id,
            chat_id: query.message!.chat.id
        }
    );
}

async function onOpenUniversalQRClick(query: CallbackQuery, _: string): Promise<void> {
    const chatId = query.message!.chat.id;
    const wallets = await getWallets();

    const connector = getConnector(chatId);

    connector.onStatusChange(wallet => {
        if (wallet) {
            bot.sendMessage(chatId, `${wallet.device.appName} wallet connected!`);
        }
    });

    const link = connector.connect(wallets);

    await editQR(query.message!, link);

    await bot.editMessageReplyMarkup(
        {
            inline_keyboard: [
                [
                    {
                        text: 'Choose a Wallet',
                        callback_data: JSON.stringify({ method: 'chose_wallet' })
                    },
                    {
                        text: 'Open Link',
                        url: `https://ton-connect.github.io/open-tc?connect=${encodeURIComponent(
                            link
                        )}`
                    }
                ]
            ]
        },
        {
            message_id: query.message?.message_id,
            chat_id: query.message?.chat.id
        }
    );
}

async function onWalletClick(query: CallbackQuery, data: string): Promise<void> {
    const chatId = query.message!.chat.id;
    const connector = getConnector(chatId);

    connector.onStatusChange(wallet => {
        if (wallet) {
            bot.sendMessage(chatId, `${wallet.device.appName} wallet connected!`);
        }
    });

    const selectedWallet = await getWalletInfo(data);
    if (!selectedWallet) {
        return;
    }

    const link = connector.connect({
        bridgeUrl: selectedWallet.bridgeUrl,
        universalLink: selectedWallet.universalLink
    });

    await editQR(query.message!, link);

    await bot.editMessageReplyMarkup(
        {
            inline_keyboard: [
                [
                    {
                        text: '« Back',
                        callback_data: JSON.stringify({ method: 'chose_wallet' })
                    },
                    {
                        text: `Open ${selectedWallet.name}`,
                        url: link
                    }
                ]
            ]
        },
        {
            message_id: query.message?.message_id,
            chat_id: chatId
        }
    );
}

async function editQR(message: TelegramBot.Message, link: string): Promise<void> {
    const fileName = 'QR-code-' + Math.round(Math.random() * 10000000000);

    await QRCode.toFile(`./${fileName}`, link);

    await bot.editMessageMedia(
        {
            type: 'photo',
            media: `attach://${fileName}`
        },
        {
            message_id: message?.message_id,
            chat_id: message?.chat.id
        }
    );

    await new Promise(r => fs.rm(`./${fileName}`, r));
}
```

</details>

Компилируйте и запустите бота, чтобы проверить, как сейчас работает подключение к кошельку.

Вы можете отметить, что мы еще не рассмотрели срок действия QR-кода и остановили коннекторы. Мы обработаем это позже.

На данный момент у нас есть структура файлов:

```text
bot-demo
├── src
│   ├── ton-connect
│   │   ├── connector.ts
│   │   ├── wallets.ts
│   │   └── storage.ts
│   ├── bot.ts
│   ├── connect-wallet-menu.ts
│   └── main.ts
├── package.json
├── package-lock.json
├── .env
└── tsconfig.json
```

## Выполнить отправку транзакции

Перед написанием нового кода, который отправляет транзакцию, давайте очистим код. Мы собираемся создать новый файл для обработчиков команд бота ('/connect', '/send_tx', ...)

```ts
// src/commands-handlers.ts

import { bot } from './bot';
import { getWallets } from '. ton-connect/wallets';
импортировать QRCode из 'qrcode';
импортировать TelegramBot из 'node-telegram-bot-api';
импортировать { getConnector } из '. ton-connect/connector';

export async function handleConnectCommand(msg: TelegramBot.Message): Promise<void> {
    const chatId = msg. hat.id;
    const кошельки = ожидать getWallets();

    коннектор = getConnector(chatId);

    коннектор. nStatusChange(wallet => {
        if (wallet) {
            bot. endMessage(chatId, `${wallet.device.appName} кошелек подключен! );
        }
    });

    const ссылка = коннектор. onnect(кошельки);
    const image = ожидать QRCode. oBuffer(link);

    ожидает бота. endPhoto(chatId, изображение, {
        reply_markup: {
            inline_keyboard: [
                [
                    {
                        text: 'Choose a Wallet',
                        callback_data: JSON. tringify({ method: 'chose_wallet' })
                    },
                    {
                        текст: 'Открыть ссылку',
                        url: `https://ton-connect. ithub. o/open-tc? onnect=${encodeURIComponent(
                            link
                        )}`
                    }
                ]
            ]
        }
    });
}
```

Давайте импортируем это в `main.ts` и перемещаем `callback_query` входную точку из `connect-wallet-menu.ts` в `main.ts`:

```ts
// src/main.ts

import dotenv from 'dotenv';
dotenv.config();

import { bot } from '. bot';
import './connect-wallet-menu';
import { handleConnectCommand } from '. команд-обработчики';
импортировать { walletMenuCallbacks } из './connect-wallet-menu';

const callbacks = {
    ...walletMenuCallbacks
};

бот. n('callback_query', query => {
    if (!query. ata) {
        return;
    }

    let request: { method: string; data: строка };

    try {
        request = JSON. арсе(запрос). ata);
    } catch {
        return;
    }

    if (! обратно[запрос]. ethod как ключ типа callbacks]) {
        return;
    }

    обратного вызова. ethod как ключ типа обратных вызовов](query, request.data);
});

bot.onText(/\/connect/, handleConnectCommand);
```

```ts
// src/connect-wallet-menu.ts

// ... imports


export const walletMenuCallbacks = {
    chose_wallet: onChooseWalletClick,
    select_wallet: onWalletClick,
    universal_qr: onOpenUniversalQRClick
};

async function onChooseWalletClick(query: CallbackQuery, _: string): Promise<void> {

// ... другой код
```

Теперь мы можем добавить обработчик команд `send_tx`:

```ts
// src/commands-handlers.ts

// ... other code

export async function handleSendTXCommand(msg: TelegramBot. essage): Promise<void> {
    const chatId = msg.chat. d;

    коннектор = getConnector(chatId);

    ждут коннектора. estoreConnection();
    if (!connector.connected) {
        await bot. endMessage(chatId, 'Подключите кошелек для отправки транзакции');
        возвращение;
    }

    коннектор
        . endTransaction({
            validUntil: Math.round(Date. ow() / 1000) + 600, // тайм-аут является SECONDS
            сообщений: [
                {
                    amount: '1000000',
                    address: '0:0000000000000000000000000000000000000000000000000000000000000000'
                }
            ]
        })
        . hen(() => {
            bot. endMessage(chatId, `Транзакция успешно отправлена`);
        })
        . atch(e => {
            if (e instanceof UserRejectsError) {
                bot. endMessage(chatId, `You rejected the transaction`);
                return;
            }

            бот. endMessage(chatId, `Неизвестная ошибка`);
        })
        . inally(() => коннектор. auseConnection());

    let deeplink = '';
    const walletInfo = await getWalletInfo(connector.wallet!.device. ppName);
    if (walletInfo) {
        deeplink = walletInfo. niversalLink;
    }

    ожидает бота. endMessage(
        chatId,
        `Open ${walletInfo?.name || connector.wallet!.device. ppName} и подтвердите транзакцию`,
        {
            reply_markup: {
                inline_keyboard: [
                    [
                        {
                            text: 'Open Wallet',
                            url: deeplink
                        }
                    ]
                ]
            }
        }
    );
}
```

Здесь мы проверяем, подключен ли пользовательский кошелек и обрабатываем отправку транзакции.
Затем мы отправляем пользователю сообщение с кнопкой, которая открывает пользовательский кошелек (универсальная ссылка кошелька без дополнительных параметров).
Заметим, что эта кнопка содержит пустую deeplink. Это означает, что отправка данных о запросе транзакций проходит через http-мост, и транзакции появятся кошелек пользователя, даже если он просто откроет приложение кошелька, не нажимая на эту кнопку.

Давайте зарегистрируем этот обработчик:

```ts
// src/main.ts

// ... other code

bot.onText(/\/connect/, handleConnectCommand);

bot.onText(/\/send_tx/, handleSendTXCommand);
```

Компилируйте и запустите бота, чтобы убедиться, что отправка транзакций работает корректно.

На данный момент у нас есть структура файлов:

```text
bot-demo
├── src
│   ├── ton-connect
│   │   ├── connector.ts
│   │   ├── wallets.ts
│   │   └── storage.ts
│   ├── bot.ts
│   ├── connect-wallet-menu.ts
│   ├── commands-handlers.ts
│   └── main.ts
├── package.json
├── package-lock.json
├── .env
└── tsconfig.json
```

## Добавить отключение и показать команды подключенного кошелька

Эта реализация команд достаточно проста:

```ts
// src/commands-handlers.ts

// ... other code

export async function handleDisconnectCommand(msg: TelegramBot. essage): Promise<void> {
    const chatId = msg. hat.id;

    const коннектор = getConnector(chatId);

    ждут коннектора. estoreConnection();
    if (!connector.connected) {
        await bot. endMessage(chatId, "Вы не подключили кошелек");
        Возвращение;
    }

    ожидает коннектора. isconnect();

    ожидает бота. endMessage(chatId, 'Кошелек был отключен');
}

export async функция handleShowMyWalletCommand(msg: TelegramBot. essage): Promise<void> {
    const chatId = msg.chat. d;

    коннектор = getConnector(chatId);

    ждут коннектора. estoreConnection();
    if (!connector.connected) {
        ожидает бота. endMessage(chatId, "Вы не подключили кошелек");
        Возвращение;
    }

    const walletName =
        (ожидайте getWalletInfo(коннектор). allet!.device.appName))?. ame ||
        connector.wallet!.device.appName;


    ожидает бота. endMessage(
        чатId,
        `Подключенный кошелек: ${walletName}\nВаш адрес: ${toUserFriendlyAddress(
            коннектор. allet!.account.address,
            connector.wallet!.account. hain === CHAIN.TESTNET
        )}`
    );
}
```

И зарегистрируйте следующие команды:

```ts
// src/main.ts

// ... other code

bot.onText(/\/connect/, handleConnectCommand);
bot.onText(/\/send_tx/, handleSendTXCommand);
bot.onText(/\/disconnect/, handleDisconnectCommand);
bot.onText(/\/my_wallet/, handleShowMyWalletCommand);
```

Компилируйте и запустите бота, чтобы убедиться, что команды выше работают правильно.

## Оптимизация

Мы выполнили все основные команды. Но важно иметь в виду, что каждый коннектор сохраняет открытое SSE соединение до тех пор, пока он не будет приостановлен.
Кроме того, мы не обрабатывали случай, когда пользователь вызывал `/connect` несколько раз, или вызывал `/connect` или `/send_tx` и не сканировал QR. Мы должны установить тайм-аут и закрыть соединение, чтобы сохранить ресурсы сервера.
Затем мы должны уведомить пользователя о истечении срока действия QR / транзакции.

### Отправить оптимизацию транзакций

Давайте создадим вспомогательную функцию, которая завершает promise и отвергнет ее после указанного таймаута:

```ts
// src/utils. s

экспорт const pTimeoutException = Symbol();

экспорт функции pTimeout<T>(
    promise: Promise<T>,
    время: число,
    исключение: неизвестно = pTimeoutException
): Promise<T> {
    let timer: ReturnType<typeof setTimeout>;
    возврат Обещания. ace([
        promise,
        new Promise(_r, rej) => (таймер = setTimeout(rej, time, exception)))
    ]). inally(() => clearTimeout(timer)) как Promise<T>;
}
```

Вы можете использовать этот код или выбрать интересующую вас библиотеку.

Давайте добавим значение параметра таймаута в `.env`

```dotenv
# .env
TELEGRAM_BOT_TOKEN=<YOUR BOT TOKEN, LIKE 1234567890:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA>
MANIFEST_URL=https://raw.githubusercontent.com/ton-connect/demo-telegram-bot/master/tonconnect-manifest.json
WALLETS_LIST_CACHE_TTL_MS=86400000
DELETE_SEND_TX_MESSAGE_TIMEOUT_MS=600000
```

Теперь мы улучшим функцию `handleSendTXCommand` и wrap tx, отправляющую на `pTimeout`

```ts
// src/commands-handlers.ts

// export async function handleSendTXCommand(msg: TelegramBot.Message): Promise<void> { ...

pTimeout(
    connector.sendTransaction({
        validUntil: Math. ound(
            (Date.now() + Number(process.env. ELETE_SEND_TX_MESSAGE_TIMEOUT_MS)) / 1000
        ),
        сообщений: [
            {
                amount: '1000000',
                address: '0:0000000000000000000000000000000000000000000000000000000000000000'
            }
        ]
    }),
    Number(process). nv.DELETE_SEND_TX_MESSAGE_TIMEOUT_MS)
)
    .then(() => {
        bot. endMessage(chatId, `Транзакция успешно отправлена`);
    })
    . atch(e => {
        if (e === pTimeoutException) {
            bot. endMessage(chatId, «Транзакция не была подтверждена»);
            возвращение;
        }

        if (e instanceof UserRejectsError) {
            bot. endMessage(chatId, `Вы отклонили транзакцию`);
            возвращение;
        }

        бот. endMessage(chatId, `Неизвестная ошибка`);
    })
    .finally(() => connector.pauseConnection());

// ... другой код
```

<details>
<summary>Полный код SendTXCommand</summary>

```ts
export async function handleSendTXCommand(msg: TelegramBot.Message): Promise<void> {
    const chatId = msg.chat. d;

    const коннектор = getConnector(chatId);

    ожидающий коннектор.restoreConnection();
    если (!connector. onnected) {
        ожидает бота. endMessage(chatId, 'Подключить кошелек для отправки транзакции');
        возврат;
    }

    pTimeout(
        коннектор. endTransaction({
            validUntil: Math. Повсюду (
                Дата. ow() + Number(process.env. ELETE_SEND_TX_MESSAGE_TIMEOUT_MS)) / 1000
            ),
            сообщения: [
                {
                    amount: '1000000',
                    address: '0:0000000000000000000000000000000000000000000000000000000000000000'
                }
            ]
        }),
        Number(process). nv. ELETE_SEND_TX_MESSAGE_TIMEOUT_MS)
    )
        . hen(() => {
            bot. endMessage(chatId, `Транзакция успешно отправлена`);
        })
        . atch(e => {
            if (e === pTimeoutException) {
                bot. endMessage(chatId, «Транзакция не была подтверждена»);
                Возвращение;
            }

            if (e instanceof UserRejectsError) {
                bot. endMessage(chatId, `Вы отклонили транзакцию`);
                возвращения;
            }

            бот. endMessage(chatId, `Неизвестная ошибка`);
        })
        . inally(() => коннектор. auseConnection());

    let deeplink = '';
    const walletInfo = await getWalletInfo(connector.wallet!.device. ppName);
    if (walletInfo) {
        deeplink = walletInfo. niversalLink;
    }

    ожидает бота. endMessage(
        chatId,
        `Open ${walletInfo?.name || connector.wallet!.device. ppName} и подтвердите транзакцию`,
        {
            reply_markup: {
                inline_keyboard: [
                    [
                        {
                            text: 'Open Wallet',
                            url: deeplink
                        }
                    ]
                ]
            }
        }
    );
}
```

</details>

Если пользователь не подтвердит транзакцию во время `DELETE_SEND_TX_MESSAGE_TIMEOUT_MS` (10мин), транзакция будет отменена, бот пошлет сообщение `Транзакция не была подтверждена`.

Вы можете установить этот параметр на `5000` компилировать и перезапустить бота и проверить его поведение.

### Оптимизация потока подключения кошелька

На данный момент мы создаем новый коннектор на каждом шаге навигации через меню подключения кошелька.
Это плохо, потому что мы не закрываем предыдущее подключение коннекторов при создании новых коннекторов.
Давайте улучшим это поведение и создадим сопоставление кэша для коннекторов пользователей.

<details>
<summary>src/ton-connect/connector.ts код</summary>

```ts
// src/ton-connect/connector.ts

import TonConnect from '@tonconnect/sdk';
import { TonConnectStorage } from '. storage;
импортировать * как процесс из процесса;

тип StoredConnectorData = {
    connector: TonConnect;
    timeout: ReturnType<typeof setTimeout>;
    onConnectorExpired: ((коннектор: TonConnect) => void)[];
};

коннекторов = новая карта<number, StoredConnectorData>();

Экспорт функции getConnector(
    chatId: число,
    onConnectorExpired? (connector: TonConnect) => void
): TonConnect {
    let storedItem: StoredConnectorData;
    if (connectors. as(chatId)) {
        storedItem = connectors.get(chatId)!;
        clearTimeout(storedItem. imeout);
    } else {
        storedItem = {
            connector: new TonConnect({
                manifestUrl: process. nv.MANIFEST_URL,
                хранилище: новое TonConnectStorage(chatId)
            }),
            onConnectorExpired: []
        } неизвестно, как StoredConnectorData;
    }

    if (onConnectorExpired) {
        storedItem. nConnectorExpired.push(onConnectorExpired);
    }

    storedItem. imeout = setTimeout(() => {
        if (коннекторы. as(chatId)) {
            const storedItem = коннекторы. et(chatId)!;
            storedItem. onnector.pauseConnection();
            storedItem.onConnectorExpired.forEach(callback => callback(storedItem. соединителей));
            соединителей. elete(chatId);
        }
    }, Number(process.env. ONNECTOR_TTL_MS));

    connectors.set(chatId, storedItem);
    return storedItem.connector;
}
```

</details>

Этот код может выглядеть немного сложно, но вот мы идем.
Здесь мы храним коннектор, время очистки и список обратных вызовов, которые должны выполняться после тайм-аута для каждого пользователя.

Когда вызывается `getConnector`, мы проверяем существует ли коннектор для этого `chatId` (пользователь) это кэш. Если это существует, мы сбросим время очистки и вернем коннектор.
Это позволяет хранить активные коннекторы пользователей в кэше. В кэше нет коннектора, мы создаем новый коннектор, регистрируем тайм-аут функции и возвращаем этот коннектор.

Для работы нам нужно добавить новый параметр в файл `.env`

```dotenv
# .env
TELEGRAM_BOT_TOKEN=<YOUR BOT TOKEN, LIKE 1234567890:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA>
MANIFEST_URL=https://ton-connect.github.io/demo-dapp-with-react-ui/tonconnect-manifest.json
WALLETS_LIST_CACHE_TTL_MS=86400000
DELETE_SEND_TX_MESSAGE_TIMEOUT_MS=600000
CONNECTOR_TTL_MS=600000
```

Теперь давайте используем его в команде handelConnectCommand

<details>
<summary>src/commands-handlers.ts code</summary>

```ts
// src/commands-handlers.ts

import {
    CHAIN,
    isWalletInfoRemote,
    toUserFriendlyAddress,
    UserRejectsError
} from '@tonconnect/sdk';
import { bot } from './bot';
import { getWallets, getWalletInfo } from './ton-connect/wallets';
import QRCode from 'qrcode';
import TelegramBot from 'node-telegram-bot-api';
import { getConnector } from './ton-connect/connector';
import { pTimeout, pTimeoutException } from './utils';

let newConnectRequestListenersMap = new Map<number, () => void>();

export async function handleConnectCommand(msg: TelegramBot.Message): Promise<void> {
    const chatId = msg.chat.id;
    let messageWasDeleted = false;

    newConnectRequestListenersMap.get(chatId)?.();

    const connector = getConnector(chatId, () => {
        unsubscribe();
        newConnectRequestListenersMap.delete(chatId);
        deleteMessage();
    });

    await connector.restoreConnection();
    if (connector.connected) {
        const connectedName =
            (await getWalletInfo(connector.wallet!.device.appName))?.name ||
            connector.wallet!.device.appName;

        await bot.sendMessage(
            chatId,
            `You have already connect ${connectedName} wallet\nYour address: ${toUserFriendlyAddress(
                connector.wallet!.account.address,
                connector.wallet!.account.chain === CHAIN.TESTNET
            )}\n\n Disconnect wallet firstly to connect a new one`
        );

        return;
    }

    const unsubscribe = connector.onStatusChange(async wallet => {
        if (wallet) {
            await deleteMessage();

            const walletName =
                (await getWalletInfo(wallet.device.appName))?.name || wallet.device.appName;
            await bot.sendMessage(chatId, `${walletName} wallet connected successfully`);
            unsubscribe();
            newConnectRequestListenersMap.delete(chatId);
        }
    });

    const wallets = await getWallets();

    const link = connector.connect(wallets);
    const image = await QRCode.toBuffer(link);

    const botMessage = await bot.sendPhoto(chatId, image, {
        reply_markup: {
            inline_keyboard: [
                [
                    {
                        text: 'Choose a Wallet',
                        callback_data: JSON.stringify({ method: 'chose_wallet' })
                    },
                    {
                        text: 'Open Link',
                        url: `https://ton-connect.github.io/open-tc?connect=${encodeURIComponent(
                            link
                        )}`
                    }
                ]
            ]
        }
    });

    const deleteMessage = async (): Promise<void> => {
        if (!messageWasDeleted) {
            messageWasDeleted = true;
            await bot.deleteMessage(chatId, botMessage.message_id);
        }
    };

    newConnectRequestListenersMap.set(chatId, async () => {
        unsubscribe();

        await deleteMessage();

        newConnectRequestListenersMap.delete(chatId);
    });
}

// ... other code
```

</details>

Мы определили `newConnectRequestListenersMap` для хранения обратного вызова очистки для последнего запроса подключения для каждого пользователя.
Если пользователь вызывает `/connect` несколько раз, бот удалит предыдущее сообщение с помощью QR.
Кроме того, мы подписались на истечение срока действия коннектора, чтобы удалить сообщение QR-кода по истечении срока его действия.

Теперь нам следует удалить `connector.onStatusChange` подписку из меню `connect-wallet-menu. s` функции,
потому что они используют один и тот же экземпляр коннектора и одну подписку в `handleConnectCommand` достаточно.

<details>
<summary>src/connect-wallet-menu.ts код</summary>

```ts
// src/connect-wallet-menu.ts

// ... other code

async function onOpenUniversalQRClick(query: CallbackQuery, _: string): Promise<void> {
    const chatId = query. essage!.chat. d;
    кошельки = await getWallets();

    коннектор = getConnector(chatId);

    const link = коннектор. onnect(wallets);

    ожидает editQR(query.message!, link);

    ожидает бота. ditMessageReplyMarkup(
        {
            inline_keyboard: [
                [
                    {
                        text: 'Choose a Wallet',
                        callback_data: JSON. tringify({ method: 'chose_wallet' })
                    },
                    {
                        текст: 'Открыть ссылку',
                        url: `https://ton-connect. ithub. o/open-tc? onnect=${encodeURIComponent(
                            link
                        )}`
                    }
                ]
            ]
        },
        {
            message_id: запрос. essage?.message_id,
            chat_id: query.message?.chat. d
        }
    );
}

async function onWalletClick(query: CallbackQuery, data: string): Promise<void> {
    const chatId = query. essage!.chat. d;
    коннектор = getConnector(chatId);

    кошельков = await getWallets();

    const selectedWallet = кошельки. ind(кошелёк => кошелек. ame === данные);
    if (! electedWallet) {
        return;
    }

    const ссылка = коннектор. onnect({
        bridgeUrl: selectedWallet.bridgeUrl,
        universalLink: selectedWallet.universalLink
    });

    ожидает editQR(query.message!, ссылка);

    ожидает бота. ditMessageReplyMarkup(
        {
            inline_keyboard: [
                [
                    {
                        text: '« Назад',
                        callback_data: JSON. tringify({ method: 'chose_wallet' })
                    },
                    {
                        текст: `Open ${data}`,
                        url: ссылка
                    }
                ]
            ]
        },
        {
            message_id: запрос. предание?. essage_id,
            chat_id: chatId
        }
    );
}

// . . другой код
```

</details>

Вот и все! Компилируйте и запустите бота и попробуйте вызвать `/connect` дважды.

### Улучшить взаимодействие с @бумажником

Начиная с v3 TonConnect поддерживает подключение к кошелькам TWA как @wallet. На данный момент в руководстве бот может быть подключен к @wallet.
Однако мы должны улучшить стратегию переориентации, с тем чтобы обеспечить более качественный сервис UX. Более того, давайте добавим кнопку `Connect @wallet` к первому ("Universal QR") экрану.

Сначала давайте создадим некоторые вспомогательные функции:

```ts
// src/utils.ts
import { encodeTelegramUrlParameters, isTelegramUrl } from '@tonconnect/sdk';

export const AT_WALLET_APP_NAME = 'telegram-wallet';

// ... other code
export function addTGReturnStrategy(link: string, string): string {
    const parsed = new URL(link);
    обработано. earchParams.append('ret', strategy);
    link = parsed.toString();

    const lastParam = link. lice(link.lastIndexOf('&') + 1);
    return link.slice(0, link. astIndexOf('&')) + '-' + encodeTelegramUrlПараметры (lastParam);
}

export function convertDeeplinkToUniversalLink(link: string, walletUniversalLink: string): string {
    const search = new URL(link). earch;
    const url = new URL(walletUniversalLink);

    if (isTelegramUrl(walletUniversalLink)) {
        const startattach = 'tonconnect-' + encodeTelegramUrlParameters(search. lice(1));
        url.searchParams. ppend('startattach', startattach);
    } else {
        url. search= search;
    }

    return url.toString();
}
```

Параметры TonConnect в Telegram ссылки должны быть закодированы специальным образом, поэтому мы используем `encodeTelegramUrlParameters` для кодирования параметра возврата стратегии.
Мы будем использовать `addTGReturnStrategy` для корректного возврата боту для @wallet.

Поскольку мы используем код создания универсальной QR-страницы в двух местах, мы перемещаем его в отдельную функцию:

```ts
// src/utils.ts

// ... другой код

экспортирует асинхронную функцию buildUniversalKeyboard(
    ссылка: строка,
    кошельки: WalletInfoRemote[]
): Promise<InlineKeyboardButton[]> {
    const atWallet = wallets. ind(кошелёк => кошелек. ppName. oLowerCase() === AT_WALLET_APP_NAME);
    const atWalletLink = atWallet
        ? addTGReturnStrategy(
            convertDeeplinkToUniversalLink(link, atWallet?. niversalLink),
            process.env. ELEGRAM_BOT_LINK!
        )
        : не определено;

    const keyboard = [
        {
            text: 'Choose a Wallet',
            callback_data: JSON. tringify({ method: 'chose_wallet' })
        },
        {
            текст: 'Открыть ссылку',
            url: `https://ton-connect. ithub. o/open-tc? onnect=${encodeURIComponent(link)}`
        }
    ];

    if (atWalletLink) {
        клавиатура. nshift({
            text: '@wallet',
            url: atWalletLink
        });
    }

    возвращает клавиатуру;
}
```

Здесь мы добавляем отдельную кнопку для @бумажника в первый экран (Universal QR screen). Все, что осталось - это использовать эту функцию в
connect-wallet-menu и обработчики команд:

<details>
<summary>src/connect-wallet-menu.ts код</summary>

```ts
// src/connect-wallet-menu.ts

// ... other code

async function onOpenUniversalQRClick(query: CallbackQuery, _: string): Promise<void> {
    const chatId = query.message!. hat.id;
    const кошельки = ожидать getWallets();

    коннектор = getConnector(chatId);

    const link = коннектор. onnect(wallets);

    ожидает editQR(запрос). essage!, link);

    const keyboard = await buildUniversalKeyboard(link, wallets);

    ждет бота. ditMessageReplyMarkup(
        {
            inline_keyboard: [keyboard]
        },
        {
            message_id: запрос. essage?.message_id,
            chat_id: query.message?.chat. d
        }
    );
}

// ... другой код
```

</details>

<details>
<summary>src/commands-handlers.ts code</summary>

```ts
// src/commands-handlers.ts

// ... other code

export async function handleConnectCommand(msg: TelegramBot. essage): Promise<void> {
    const chatId = msg.chat. d;
    let messageWasDeleted = false;

    newConnectRequestListenersMap.get(chatId)?. );

    const connector = getConnector(chatId, () => {
        unsubscribe();
        newConnectRequestlenersMap. elete(chatId);
        deleteMessage();
    });

    ожидает коннектора. estoreConnection();
    если (коннектор. onnected) {
        const connectedName =
            (await getWalletInfo(connector. allet!.device.appName))?.name ||
            коннектор. allet!.device.appName;
        ждет бота. endMessage(
            чатId,
            `Вы уже подключили кошелек ${connectedName}\nВаш адрес: ${toUserFriendlyAddress(
                коннектор. allet!.account.address,
                connector.wallet!.account.chain === CHAIN. ESTNET
            )}\n\n Разсоедините кошелек сначала, чтобы подключить новый`
        );

        return;
    }

    const unsubscribe = коннектор. nStatusChange(async wallet => {
        if (wallet) {
            await deleteMessage();

            кошелекName =
                (ожидайте getWalletInfo(кошелёк. evice.appName)?. ame || wallet.device.appName;
            ожидает бота. endMessage(chatId, `${walletName} кошелек успешно подсоединен`);
            отказ от подписки();
            newConnectRequestListenersMap. elete(chatId);
        }
    });

    Кошельки = ожидание getWallets();

    const ссылка = коннектор. onnect(кошельки);
    const image = ожидать QRCode. oBuffer(link);

    const keyboard = ожидание buildUniversalKeyboard(ссылка, кошельки);

    const botMessage = ожидание бота. endPhoto(chatId, изображение, {
        reply_markup: {
            inline_keyboard: [keyboard]
        }
    });

    const deleteMessage = async (): Promise<void> => {
        if (! essageWasDeleted) {
            messageWasDeleted = true;
            ожидает бота. eleteMessage(chatId, botMessage.message_id);
        }
    };

    newConnectRequestListenersMap. et(chatId, async () => {
        unsubscribe();

        ожидает deleteMessage();

        newConnectRequestListenersMap. elete(chatId);
    });
}

// ... other code
```

</details>

Теперь мы будем правильно обрабатывать TG ссылки, когда пользователь нажимает на кнопку кошелька на втором экране (выбор кошелька):

<details>
<summary>src/connect-wallet-menu.ts код</summary>

```ts
// src/connect-wallet-menu.ts

// ... other code


async function onWalletClick(query: CallbackQuery, data: string): Promise<void> {
    const chatId = query.message!.chat. d;
    коннектор = getConnector(chatId);

    const selectedWallet = await getWalletInfo(данные);
    если (! electedWallet) {
        возвращение;
    }

    пустая кнопка = коннектор. onnect({
        bridgeUrl: selectedWallet.bridgeUrl,
        universalLink: selectedWallet.universalLink
    });

    let qrLink = buttonLink;

    if (isTelegramUrl(selectedWallet. niversalLink)) {
        buttonLink = addTGReturnStrategy(buttonLink, process. nv.TELEGRAM_BOT_LINK! ;
        qrLink = addTGReturnStrategy(qrLink, 'none');
    }

    ожидает editQR(запрос). essage!, qrLink);

    ждет бота. ditMessageReplyMarkup(
        {
            inline_keyboard: [
                [
                    {
                        text: '"Назад",
                        callback_data: JSON. tringify({ method: 'chose_wallet' })
                    },
                    {
                        текст: `Open ${selectedWallet.name}`,
                        url: buttonLink
                    }
                ]
            ]
        },
        {
            message_id: запрос. предание?. essage_id,
            chat_id: chatId
        }
    );
}

// . . другой код
```

</details>

Обратите внимание, что мы размещаем разные ссылки на QR и button-link (`qrLink` и `buttonLink`),
потому что нам не нужно перенаправляться, когда пользователь сканирует QR от @wallet, и в то же время нам нужно перенаправлять обратно к боту, когда пользователь подключается к @кошельку, используя кнопку-ссылку.

Теперь давайте добавим стратегию возврата для TG ссылок в обработчике `send transaction`:

<details>
<summary>src/commands-handlers.ts code</summary>

```ts
// src/commands-handlers.ts

// ... other code

export async function handleSendTXCommand(msg: TelegramBot. essage): Promise<void> {
    const chatId = msg. hat.id;

    const коннектор = getConnector(chatId);

    ожидание коннектора.restoreConnection();
    если (!connector. onnected) {
        ожидает бота. endMessage(chatId, 'Подключите кошелек для отправки транзакции');
        возвращение;
    }

    pTimeout(
        коннектор. endTransaction({
            validUntil: Math. ound(
                (Date.now() + Number(process.env. ELETE_SEND_TX_MESSAGE_TIMEOUT_MS)) / 1000
            ),
            сообщений: [
                {
                    amount: '1000000',
                    address: '0:0000000000000000000000000000000000000000000000000000000000000000'
                }
            ]
        }),
        Number(process). nv.DELETE_SEND_TX_MESSAGE_TIMEOUT_MS)
    )
        . hen(() => {
            бот. endMessage(chatId, `Транзакция успешно отправлена`);
        })
        . atch(e => {
            if (e === pTimeoutException) {
                bot. endMessage(chatId, «Транзакция не была подтверждена»);
                Возвращение;
            }

            if (e instanceof UserRejectsError) {
                bot. endMessage(chatId, `Вы отклонили транзакцию`);
                возврата;
            }

            бот. endMessage(chatId, `Неизвестная ошибка`);
        })
        . inally(() => connector.pauseConnection());

    let deeplink = '';
    const walletInfo = await getWalletInfo(connector.wallet!. evice.appName);
    if (walletInfo) {
        deeplink = walletInfo. niversalLink;
    }

    if (isTelegramUrl(deeplink)) {
        const url = new URL(deeplink);
        url. earchParams.append('startattach', 'tonconnect');
        deeplink = addTGReturnStrategy(url.toString(), process.env. ELEGRAM_BOT_LINK!);
    }

    ожидает бота. endMessage(
        chatId,
        `Open ${walletInfo?.name || connector.wallet!.device. ppName} и подтвердите транзакцию`,
        {
            reply_markup: {
                inline_keyboard: [
                    [
                        {
                            text: `Open ${walletInfo?. прийти || connector.wallet!.device. ppName}`,
                            url: deeplink
                        }
                    ]
                ]
            }
        }
    );
}

// . . другой код
```

</details>

Вот и все. Теперь пользователь может подключить @бумажник с помощью специальной кнопки на главном экране, а также мы предоставили надлежащую стратегию возврата ссылок TG.

## Добавить постоянное хранилище

В данный момент мы храним сессии TonConnect на объекте Карты. Но вы можете захотеть сохранить его в базе данных или другом постоянном хранилище для сохранения сессий при перезапуске сервера.
Мы будем использовать Redis для этого, но вы можете выбрать любой постоянный накопитель.

### Настройка красного цвета

Сначала запустите `npm i redis`.

[Подробности пакета](https://www.npmjs.com/package/redis)

Для работы с redis необходимо запустить redis сервер. Мы будем использовать изображение Docker:
`docker run -p 6379:6379 -it redis/redis-stack-server:latest`

Теперь добавьте параметр подключения redis в `.env`. URL по умолчанию `redis://127.0.0.1:6379`.

```dotenv
# .env
TELEGRAM_BOT_TOKEN=<YOUR BOT TOKEN, LIKE 1234567890:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA>
MANIFEST_URL=https://ton-connect.github.io/demo-dapp-with-react-ui/tonconnect-manifest.json
WALLETS_LIST_CACHE_TTL_MS=86400000
DELETE_SEND_TX_MESSAGE_TIMEOUT_MS=600000
CONNECTOR_TTL_MS=600000
REDIS_URL=redis://127.0.0.1:6379
```

Давайте интегрируем redis в `TonConnectStorage`:

```ts
// src/ton-connect/storage.ts

import { IStorage } from '@tonconnect/sdk';
import { createClient } from 'redis';

const client = createClient({ url: process.env.REDIS_URL });

клиент. n('error', err => console.log('Redis Client Error', err));

export async function initRedisClient(): Promise<void> {
    await client. onnect();
}
export class TonConnectStorage implements IStorage {
    constructor(private readonly chatId: number) {}

    private getKey(key: string): string {
        return this. Id. oString() + ключ;
    }

    async removeItem(key: string): Promise<void> {
        ожидающий клиента. el(t. etKey(ключ));
    }

    набор асинхронностей(ключ: строка, value: string): Promise<void> {
        ожидает клиента. et(это. etKey(key), значение);
    }

    async getItem(key: string): Promise<string | null> {
        return (await client). et(this.getKey(key))) || null;
    }
}
```

Чтобы это работало, мы должны дождаться инициализации redis в `main.ts`. Давайте обернем код в этот файл в функцию асинхронности:

```ts
// src/main.ts
// ... imports

async function main(): Promise<void> {
    await initRedisClient();

    const обратные вызовы = {
        ...walletMenuCallbacks
    };

    бот. n('callback_query', query => {
        if (!query. ata) {
            return;
        }

        let request: { method: string; данные: строка };

        try {
            request = JSON. арсе(запрос). ata);
        } catch {
            return;
        }

        if (! обратно[запрос]. ethod как ключ типа callbacks]) {
            return;
        }

        обратных вызовов. ethod как ключ типа обратных вызовов](query, request.data);
    });

    бот. nText(/\/connect/, handleConnectCommand);

    bot.onText(/\/send_tx/, handleSendTXCommand);

    bot. nText(/\/disconnect/, handleDisconnectCommand);

    bot.onText(/\/my_wallet/, handleShowMyWalletCommand);
}

main();
```

## Summary

Что дальше?

- Если вы хотите запустить бота в производстве, вы можете установить и использовать менеджер процесса, например [pm2](https://pm2.keymetrics.io/).
- Вы можете добавить улучшенную обработку ошибок в боте.

## Смотреть также

- [Отправка сообщений](/v3/guidelines/ton-connect/guidelines/sending-messages)
- [Руководство по интеграции](/v3/guidelines/ton-connect/guidelines/integration-with-javascript-sdk)
