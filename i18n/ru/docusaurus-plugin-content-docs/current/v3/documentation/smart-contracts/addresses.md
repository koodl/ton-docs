# Документация по адресу смарт-контрактов

В этом разделе описаны специфические адреса смарт-контрактов в блокчейне TON. Это также объясняет, как актеры синонимичны с умными контрактами на Тон.

## Все это умный контракт

На TON умные контракты создаются с помощью [модели актеров](/v3/concepts/dive-into-ton/ton-blockchain/blockchain-of-blockchains#single-actor). Фактически, актеры на TON технически представлены как умные контракты. Это означает, что даже ваш кошелек является простым действующим лицом (и смарт-контрактом).

Как правило, действующие лица обрабатывают входящие сообщения, изменяют их внутреннее состояние и генерируют исходящие сообщения. Поэтому каждый действующий элемент (т.е. умный контракт) на TON Blockchain должен иметь адрес, чтобы он мог получать сообщения от других действующих лиц.

:::info EVM Опыт
На Ethereum виртуальная машина (EVM) адреса полностью отделены от смарт-контрактов. Узнайте больше о различиях, прочитав статью ["Шесть уникальных аспектов TON Blockchain, которые будут удивлять разработчиков солидарности"](https://blog. on.org/six-unique-aspects-of-ton-blockchain-that-will-surprise-solidity-developers) от Tal Kol.
:::

## Адрес умного контракта

Умные адреса контрактов в TON обычно состоят из двух основных компонентов:

- **(workchain_id)**: Обозначает идентификатор рабочей цепочки (знакомое 32-разрядное целое)

- **(account_id)** Обозначает адрес аккаунта (64-512 бит, в зависимости от рабочей цепочки)

В разделе "Простой адрес" этой документации мы обсудим, как отображаются пары **(workchain_id, account_id)**.

### Идентификатор рабочей сети и ID аккаунта

#### Идентификатор цепочки работ

[Как мы видели ранее](/v3/concepts/dive-into-ton/ton-blockchain/blockchain-of-blockchains#workchain-blockchain-with-your-own-rules), можно создавать столько же рабочих цепей `2^32`, работающих на TON Blockchain. Мы также отметили, что 32-битные префиксные адреса смарт-контракта определяют и связаны с адресами смарт-контрактов в различных рабочих сетях. Это позволяет смарт-контрактам отправлять и получать сообщения из различных рабочих сетей в TON Blockchain.

В настоящее время в TON Blockchain работают только Masterchain (workchain_id=-1), а иногда и базовая цепочка работ (workchain_id=0).

Обе из них имеют 256-битные адреса, поэтому мы предполагаем, что workchain_id либо 0 или -1, и адрес в рабочей цепочке точно 256 бит.

#### ID клиента

Все ID аккаунта TON используют 256-битные адреса в Masterchain и Basechain (или базовую рабочую цепочку).

Фактически, **(account_id)** определяет как хэш-функции для смарт-объектов (особенно SHA-256). В каждом смарт-контракте, работающем в TON Blockchain хранится две основные компоненты. К ним относятся:

1. _Скомпилированный код_. Логика смарт-контракта скомпилирована в виде байт-кода.
2. _Первоначальное состояние_. Стоимость контракта в момент его развертывания по цепочке.

Наконец, для получения адреса контракта необходимо рассчитать хэш, соответствующий объекту **(начальный код, начальное состояние)**. At this time, we won't take a deep dive into how the [TVM](/v3/documentation/tvm/tvm-overview) works, but it's important to understand that account IDs on TON are determined using this formula:
:
**account_id = hash(initial code, initial state)**

В течение всего времени мы погружаемся в технические спецификации и рассмотрим схему ТВМ и ТЛ-В. Теперь, когда мы знакомы с поколением **account_id** и их взаимодействием с смарт-адресами на TON, давайте объясним адреса Raw и User-Friendly.

## Состояние адресов

Каждый адрес может быть в одном из возможных состояний:

- `nonexist` - не было принятых транзакций по этому адресу, поэтому они не имеют никаких данных (или контракт был удален). Мы можем сказать, что в этом состоянии находятся все 2<sup>256</sup> адреса.
- `uninit` - адрес содержит некоторые данные, содержащие баланс и информацию о метаданных. В этом штате еще нет данных о смарт-коде/постоянном контракте. Адрес вводит это состояние, например, когда он находится в несуществующем состоянии, и другой адрес отсылает токены на него.
- `active` - адрес имеет смарт-код контракта, постоянные данные и баланс. В этом состоянии он может выполнить некоторую логику во время транзакции и изменить ее постоянные данные. Адрес вводит это состояние, когда был `uninit` и было входящее сообщение с state_init param (примечание, чтобы иметь возможность разворачивать этот адрес, хэш `state_init` и `code` должен быть равен адресу).
- `frozen` - адрес не может выполнять какие-либо операции, это состояние содержит только два хэша предыдущего состояния (соответственно код и ячейки состояния). Когда накопительный заряд адресата превышает его баланс, он попадает в это состояние. Чтобы разморозить его, вы можете отправить внутреннее сообщение с помощью `state_init` и `code`, которые хранят хэши, описанные ранее, и некоторые Toncoin. Это может быть трудно восстановить его, поэтому вы не должны допустить эту ситуацию. There is a project to unfreeze the address, which you can find [here](https://unfreezer.ton.org/).

## Сырье и удобные для пользователя адреса

После краткого обзора адресов смарт-контрактов в рабочих цепочках TON рычагов и идентификаторов аккаунта (особенно в Masterchain и Basechain), важно понять, что эти адреса выражаются в двух основных форматах:

- **Сырье адресов**: Оригинальное полное представление адресов смарт-контрактов.
- **Удобные для пользователя адреса**: удобные для пользователя адреса - это расширенный формат необработанного адреса, который обеспечивает большую безопасность и простоту использования.

Ниже мы расскажем подробнее о различиях между этими двумя типами адресов и погрузимся в глубину того, почему на TON-машине используются удобные для пользователя адреса.

### Сырье

Исходные адреса смарт-контрактов состоят из идентификатора рабочей цепочки и идентификатора аккаунта _(workchain_id, account_id)_ и отображаются в следующем формате:

- [десятичная цепочка_id\]:[64 шестнадцатеричные цифры с account_id\]

Ниже приведён пример необработанного адреса смарт-контракта, использующего совместно идентификатор рабочей цепочки и идентификатор аккаунта (выраженный как **workchain_id** и **account_id**):

`-1:fcb91a3a3816d0f7b8c2c76108b8a9bc5a6b7a55bd79f8ab101c52db29232260`

Обратите внимание на `-1` в начале строки адреса, которая обозначает _workchain_id_ принадлежащий к цепочке Masterchain.

:::note
Заглавные буквы (такие как 'A', 'B', 'C', 'D' и т. д.) может использоваться в адресных строках вместо их аналогов (например 'a', 'b', 'c', 'd' и т.д.).
:::

#### Замечания с сырыми адресами

Использование Формы Raw Address представляет две основные проблемы:

1. При использовании формата сырых адресов невозможно проверить адреса для устранения ошибок до отправки транзакции.
   Это означает, что если вы случайно добавляете или удаляете символы в строке адреса перед отправкой транзакции, ваша транзакция будет отправлена в неправильный пункт назначения, что приведет к потере средств.
2. При использовании формата сырых адресов невозможно добавлять специальные флаги, такие как флаги, используемые при отправке транзакций, которые используют удобные для пользователя адреса.
   Чтобы помочь вам лучше понять это понятие, мы объясним какие флаги можно использовать ниже.

### Удобный адрес

Удобные для пользователя адреса были разработаны для обеспечения безопасности и упрощения работы для пользователей TON, которые обмениваются адресами в Интернете (например, на публичных платформах обмена сообщениями или через их поставщиков услуг электронной почты), а также в реальном мире.

#### Удобная структура адресов

Удобные для пользователя адреса состоят из 36 байт и получают путем генерации следующих компонентов:

1. _[flags - 1 байт]_ — Флаги, прикрепленные к адресам, изменяют реакцию смарт-контрактов на полученное сообщение.
   Виды флагов, в которых используется удобный для пользователя формат адреса, включают:

   - осваиваемый. Обозначает тип адреса, который можно отскочить или не обрезать. (_0x11_ для "bounceable", _0x51_ для "non-bounceable")
   - isTestnetonly. Обозначает тип адреса, используемый только для testnet. Адреса, начинающиеся с _0x80_ не должны приниматься программным обеспечением, работающим в производственной сети
   - isUrlSafe. Обозначает устаревший флаг, определяемый как URL-безопасный для адреса. Затем все адреса считаются URL-безопасными.
2. _\[workchain_id - 1 byte]_ — ID рабочей сети (_workchain_id_) определен знаком 8-битного integer _workchain_id_.\
   (_0x00_ для BaseChain, _0xff_ для MasterChain)
3. _\[account_id - 32 байт]_ — ID аккаунта состоит из ([big-endian](https://www.freecodecamp.org/news/what-is-endianness-big-endian-vs-little-endian/)) 256-битного адреса в рабочей цепочке.
4. _\[проверка адреса - 2 байта]_ — В удобных для пользователя адресах проверка адреса состоит из подписи CRC16-CCITT из предыдущих 34 байт. ([Example](https://github.com/andreypfau/ton-kotlin/blob/ce9595ec9e2ad0eb311351c8a270ef1bd2f4363e/ton-kotlin-crypto/common/src/crc32.kt))
   In fact, the idea pertaining to verification for user-friendly addresses is quite similar to the [Luhn algorithm](https://en.wikipedia.org/wiki/Luhn_algorithm), which is used on all credit cards to prevent users from entering non-existing card numbers by mistake.

Добавление этих 4 основных компонентов означает, что: `1 + 1 + 32 + 2 = 36` байт всего (по адресу для пользователя).

Чтобы сгенерировать удобный для пользователя адрес, разработчик должен кодировать все 36 байт, используя либо:

- _base64_ (то есть с цифрами, заглавными и строчными латинскими буквами, '/' и '+')
- _base64url_ (с '_' и '-' вместо '/' и '+')

После завершения этого процесса завершается создание удобного для пользователя адреса длиной 48 символов без интервала.

:::info DNS АДРЕС FLAGS
В TON DNS адреса, такие как mywallet.ton, иногда используются вместо сырых и дружественных адресов. DNS-адреса состоят из удобных для пользователя адресов и включают все необходимые флаги, позволяющие разработчикам получить доступ ко всем флагам DNS записи в домене TON.
:::

#### Примеры кодирования адресов для пользователя

Например, смарт-контракт "испытательный помощник" (специальный смарт-контракт, находящийся в мастер-цепочке testnet , который посылает 2 тестовых токена всем, кто их запрашивает) использует следующий необработанный адрес:

`-1:fcb91a3a3816d0f7b8c2c76108b8a9bc5a6b7a55bd79f8ab101c52db29232260`

Самый простой адрес "тестового посредника" должен быть преобразован в удобную для пользователя форму адреса. Это получается с помощью форм base64 или base64url (которые мы ввели ранее) следующим образом:

- `kf/8uRo6OBbQ97jCx2EIuKm8Wmt6Vb15+KsQFLbKSMiYIny` (base64)
- `kf_8uRo6OBbQ97jCx2EIuKm8Wmt6Vb15-KsQFLbKSMiYIny` (base64url)

:::info
Обратите внимание, что обе формы (_base64_ и _base64url_) действительны и должны быть приняты!
:::

#### Освобождаемые и неоплачиваемые адреса

Главной идеей флага "оплачиваемых" адресов является безопасность отправителя.

Например, если смарт-контракт назначения не существует, или если во время транзакции возникла проблема, сообщение будет "отпущено" обратно отправителю и составляет остаток от первоначальной стоимости сделки (минус все трансферты и сборы газа).
В отношении адресов, подлежащих оплате, в частности:

1. Флаг **bounceable=false** обычно означает, что получатель является кошельком.
2. Флаг **bounceable=true** обычно обозначает пользовательский смарт-контракт с собственной логикой приложения (например, DEX). В этом примере сообщения не должны отправляться по соображениям безопасности.

Не стесняйтесь прочитать больше по этой теме в нашей документации, чтобы получить более полное представление о [неограниченных сообщениях](/v3/documentation/smart-contracts/message-management/non-bounceable-messages).

#### Бронированные представления base64

Дополнительные бинарные данные, относящиеся к TON Blockchain используют подобные "armored" base64. Они отличаются друг от друга в зависимости от первых 4 символов их байт. Например, 256-битные открытые ключи Ed25519 представлены первым созданием 36-байтовой последовательности, использующей процесс ниже в порядке:

- Один байтный тег с использованием формата _0x3E_ означает открытый ключ
- Один байтный тег с использованием формата _0xE6_ означает публичный ключ Ed25519
- 32 байта, содержащие стандартное бинарное представление публичного ключа Ed25519
- 2 байта, содержащие big-endian представление CRC16-CCITT предыдущих 34 байт

Результат 36-байтовой последовательности преобразуется в строку base64 или base64url стандартной формы. Например, публичный ключ Ed25519 'E39ECDA0A7B0C60A7107EC43967829DBE8BC356A49B9DFC6186B3EAC74B5477D' (обычно представлен последовательностью из 32 байт, таких как: \`0xE3, 0x9E, . ., 0x7D) представлена через "бронированное" представительство следующим образом:

`Pubjns2gp7DGCnEH7EOWeCnb6Lw1akm538YYaz6sdLVHfRB2`

### Конвертация дружественных пользователю адресов и сырых адресов

Самый простой способ конвертировать удобные для пользователя и необработанные адреса - использовать один из нескольких TON API и другие инструменты, включая:

- [ton.org/address](https://ton.org/address)
- [dton.io API method](https://dton.io/api/address/0:867ac2b47d1955de6c8e23f57994fad507ea3bcfe2a7d76ff38f29ec46729627)
- [метод API тонцентра в mainnet](https://toncenter.com/api/v2/#/accounts/pack_address_packAddress_get)
- [toncenter API методов в testnet](https://testnet.toncenter.com/api/v2/#/accounts/pack_address_packAddress_get)

Кроме того, существуют два способа преобразования удобных для пользователя и сырых адресов кошельков с использованием JavaScript:

- [Преобразовать адрес из/в дружественную или сырую форму с помощью ton.js](https://github.com/ton-org/ton-core/blob/main/src/address/Address.spec.ts)
- [Преобразовать адрес из/в удобную для пользователя или сырую форму, используя tonweb](https://github.com/toncenter/tonweb/tree/master/src/utils#address-class)

Также можно использовать аналогичные механизмы с использованием [SDKs](/v3/guidelines/dapps/apis-sdks/sdk).

### Примеры адресов

Узнайте больше примеров в [TON Cookbook](/v3/guidelines/dapps/cookbook#working-with-contracts-addresses).

## Возможные проблемы

При взаимодействии с блокчейном TON важно понимать последствия передачи монет TON на адреса кошелька `uninit`. В этом разделе описываются различные сценарии и результаты их проведения, с тем чтобы получить ясность в отношении того, как обрабатываются такие операции.

### Что произойдет, когда вы переводите Toncoin на необработанный адрес?

#### Транзакция с `state_init` включена

Если вы включите `state_init` (который состоит из кода и данных кошелька или смарт-контракта), с вашей транзакцией. Умный контракт вводится сначала с использованием предоставленного `state_init`. После развертывания, входящее сообщение обрабатывается по аналогии с отправкой уже инициализированной учетной записи.

#### Транзакция без установленного флага `state_init` и `bounce`

Сообщение не может быть доставлено смарт-контракту `uninit`, и оно будет возвращено отправителю. После вычета сборов за потребляемый газ оставшееся количество возвращается на адрес отправителя.

#### Транзакция без флага `state_init` и `bounce`

Сообщение не может быть доставлено, но оно не будет возвращено отправителю. Вместо этого отправленная сумма будет зачислена на получаемый адрес, увеличивая его баланс, даже если кошелек еще не инициализирован. Они будут храниться там до тех пор, пока владелец адреса не запустит контракт на смарт-кошелёк, а затем они не смогут получить доступ к балансу.

#### Как сделать это правильно

Лучший способ развернуть кошелек - отправить несколько TON на его адрес (который еще не инициализирован) со снятым флагом `bounce`. После этого шага владелец может развернуть и инициализировать кошелек с использованием средств на текущем неинициализированном адресе. Этот шаг обычно происходит на первом операции кошелька.

### Блокчейн TON реализует защиту от ошибочных транзакций

В блокчейне TON стандартные кошельки и приложения автоматически управляют сложностями транзакций на неинициализированные адреса, используя оплачиваемый и неоплачиваемый адрес, которые описаны [here](#bounceable-vs-non-bounce-addresses). Кошельки обычно отправляют монеты на неинициализированные адреса, без возврата отправлять монеты как на оплачиваемые, так и на невозвращаемые адреса.

Если вам нужно быстро получить адрес в виде bounceable/non-bounceable, это может быть сделано [here](https://ton.org/address/).

### Ответственность за пользовательские товары

Если вы разрабатываете пользовательский продукт в TON blockchain, важно реализовать аналогичные проверки и логику:

Убедитесь, что ваше приложение проверяет, инициализирован ли адрес получателя перед отправкой средств.
Основываясь на состоянии адреса, используйте платные адреса для смарт-контрактов с пользовательской логикой приложения для обеспечения возврата средств. Использовать не подлежащие оплате адреса для кошельков.
