# Кошелек Highload

При работе с большим количеством сообщений за короткий период возникает потребность в специальном кошельке под названием Highload Wallet. Wallet V2 Highload был главным кошельком на TON долгое время, но вы должны быть очень осторожны с ним. В противном случае вы можете [заблокировать все средства](https://t.me/tonstatus/88).

[С расширением Кошелека V3 Highload](https://github.com/ton-blockchain/Highload-wallet-contract-v3), эта проблема была решена на уровне контрактной архитектуры и потребляет меньше газа. Эта глава расскажет об основах Highload Wallet V3 и важных нюансах.

## Highload-кошелек v3

Этот кошелек создан для тех, кто должен отправлять транзакции по очень высоким тарифам. Например, обмен криптовалют.

- [Исходный код](https://github.com/ton-blockchain/Highload-wallet-contract-v3)

Любое данное внешнее сообщение (запрос на передачу) в Highload v3 содержит:

- подпись (512 бит) в ячейке верхнего уровня - остальные параметры находятся в строке этой ячейки
- subwallet ID (32 bits)
- сообщение для отправки как ref (сериализованное внутреннее сообщение, которое будет отправлено)
- режим отправки сообщения (8 бит)
- ID составного запроса - 13 бит "shift" и 10 бит "bit number", однако 10 бит числа может подняться только до 1022, не 1023, а также последний такой идентификатор запроса (8388605) зарезервирован для чрезвычайных ситуаций и не должен использоваться обычно
- создано в или отметка времени сообщения
- таймаут

Тайм-аут хранится в Highload в качестве параметра и проверяется на тайм-аут во всех запросах - поэтому время ожидания для всех запросов одинаково. Сообщение не должно быть старше тайм-аута во время прибытия в кошелек Highload, или в коде требуется `created_at > now() - timeout`. Идентификаторы запросов хранятся в целях защиты от повторов в течение по крайней мере таймаута и, возможно, до 2 \* таймаута, Однако нельзя ожидать, что они будут храниться дольше, чем тайм-аут. ID субкошелька проверяется на соответствие тому, что хранится в кошельке. Хэш внутреннего реферала проверяется вместе с подписью против открытого ключа кошелька.

Highload v3 может отправлять только 1 сообщение из любого внешнего сообщения, однако он может отправить это сообщение себе со специальным кодом op кодом, разрешить установку любой ячейки для внутреннего вызова этого сообщения, эффективно позволяя отправлять до 254 сообщений на 1 внешнее сообщение (возможно больше, если другое сообщение будет отправлено на Highload бумажник снова между этими 254).

Highload v3 всегда будет хранить ID запроса (защита для повтора) после всех проверок, однако сообщение не может быть отправлено в связи с некоторыми условиями, включая, но не ограничиваясь:

- **содержит init** (такие сообщения, если это необходимо, может быть отправлена с помощью специального кода оператора для установки ячейки после внутреннего сообщения из кошелька Highload)
- недостаточно средств
- неверная структура сообщений (включающая внешние сообщения - могут отправляться только внутренние сообщения прямо из внешнего сообщения)

Highload v3 никогда не будет запускать несколько внешних сущностей, содержащих один и тот же `query_id` **и** `created_at` - к тому времени, когда он забыл любой `query_id`, условие `created_at` не позволит выполнить такое сообщение. Это эффективно делает `query_id` **и** `created_at` вместе "первичным ключом" запроса на перевод для Highload v3.

При итерации (увеличивающего) идентификатора запроса, более дешево (в терминах TON, потраченного на комиссии) сначала итерация через бит-число. и затем сдвиг, как при увеличении обычного числа. После того, как вы достигли последнего ID запроса (запомните об идентификаторе экстренного запроса - см. выше), вы можете сбросить ID запроса на 0, но если период ожидания Highload'а еще не истек, Затем словарь защиты повторов будет полон и вам придется дождаться истечения срока.

## Highload-кошелек v2

:::danger
Устаревший контракт, рекомендуется использовать Highload кошелек v3.
:::

Этот кошелек создан для тех, кто должен отправить сотни транзакций за короткий промежуток времени. Например, обмен криптовалют.

Она позволяет вам отправлять до транзакций `254` во время одного смарт-контракта. Он также использует несколько иной подход для решения атак повторов вместо seqno, так что вы можете позвонить этому кошельку несколько раз одновременно, чтобы отправить даже тысячи транзакций за секунду.

:::caution Ограничения
Обратите внимание, что при работе с кошельком Highload, следующие ограничения должны быть проверены и учтены.
:::

1. **Лимит хранения.** В настоящее время размер хранения контракта должен быть меньше 65535. Если размер
   old_queries будет расти выше этого предела, то исключение в ActionPhase будет выброшено и транзакция не будет выполнена.
   Ошибка транзакции может быть воспроизведена.
2. \*\*предел газа. \* В настоящее время предел газа составляет 1'000'000 газовых единиц, это означает, что существует ограничение на то, сколько
   старых запросов можно очистить в один tx. Если количество просроченных запросов будет выше, контракт застрят.

Это означает, что не рекомендуется устанавливать слишком высокую дату истечения срока действия:
количество запросов в течение срока действия не должно превышать 1000.

Также, количество просроченных запросов в одной транзакции должно быть меньше 100.

## Как

Вы также можете прочитать статью [Tutorials](/v3/guidelines/smart-contracts/howto/wallet#-high-load-wallet-v3).

Исходный код кошелька:

- [ton/crypto/smartcont/Highload-wallet-v2-code.fc](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/new-highload-wallet-v2.fif)
