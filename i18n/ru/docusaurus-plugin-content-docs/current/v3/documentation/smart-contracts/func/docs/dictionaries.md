# Словари в TON

Умные контракты могут использовать словари - упорядоченные сопоставления ключей. Они представлены на внутреннем уровне деревьями клеток.

:::warning
Работа с потенциально большими деревьями клеток создает пару соображений:

1. Каждая операция обновления создает значительное количество ячеек (и каждая построенная ячейка стоит 500 газов, , что может быть найдено на странице [TVM Инструкция](/v3/documentation/tvm/instructions#gas-prices) , что означает, что эти операции могут работать без заботы в случае их использования.
   - В частности, бот Wallet столкнулся с такой проблемой один раз при использовании кошелька highload-v2. Неограниченный цикл в сочетании с дорогостоящими обновлениями словаря в каждой итерации привел к тому, что газ заканчивается и в конечном итоге повторяется как [fd78228f352f582a544ab7ad7eb716610668b23b88dae48e4f4dbd4404b5d7f6](https://tonviewer. om/transaction/fd78228f352f582a544ab7ad7eb716610668b23b88dae48e4f4dbd4404b5d7f6) draining its balance.
2. Двоичное дерево для пар ключ-значение N содержит ветки N-1, таким образом, как минимум ячейки 2N-1 в целом. Умное хранение контрактов ограничено 65536 уникальными клетками, Таким образом, максимальное количество записей в словаре составляет 32768 или чуть больше, если есть повторяющиеся ячейки.
   :::

## Виды словарей

### Карта "Хэш"

Очевидно, самый известный и используемый вид словарей в TON - хэшкарта. Он имеет целую часть опкодов TVM ([инструкции TVM](/v3/documentation/tvm/instructions#quick-search) - Манипуляция словарей) и обычно используется в умных контрактах.

Эти словари представляют собой сопоставления ключей одинаковой длины (указанная длина предоставляется в качестве аргумента для всех функций) на значения кусочков. В отличие от "хэш" в названии, записи упорядочены и предлагают дешевое извлечение элемента по ключевой, предыдущей или следующей паре ключевого значения. Значения располагаются в той же ячейке, что и внутренние теги узла и, возможно, ключевые части, поэтому они не могут использовать все 1023 бита; В такой ситуации обычно используется `~udict_set_ref`.

Пустая хэшкарта представлена как «null» по TVM; поэтому она не является камерой. Чтобы сохранить словарь в ячейке, сначала сохраняется один бит (0 для пустого, иногда), а затем добавляет ссылку, если хэшпап не пуст. Таким образом, `store_maybe_ref` и `store_dict` являются взаимозаменяемыми, а некоторые смарт-исполнители используют `load_dict` для загрузки `Maybe ^Cell` из входящего сообщения или хранилища.

Возможные операции для хэш-карты:

- загрузить из маски, магазина в конструктор
- get/set/delete значение по ключу
- заменить значение (установить новое значение, если ключ уже присутствовал) / добавить одно (если ключ отсутствует)
- перемещение к следующей / предыдущей паре ключевых значений в порядке следования ключей (это может быть использовано для [итерации по словарям](/v3/documentation/smart-contracts/func/cookbook#how-to-iterate-dictionaries), если ограничение на газ не касается)
- получение минимального/максимального ключа с его значением
- получить функцию (продолжение) по ключу и немедленно выполнить ее

Для того, чтобы контракт не прерывал превышения лимита газа, во время обработки одной транзакции должно происходить лишь ограниченное количество обновлений. Если баланс контракта используется для поддержания карты в соответствии с условиями разработчика, контракт может отправить само по себе сообщение для продолжения очистки.

:::info
Есть инструкции по извлечению подсловарей: подмножество записей в заданном диапазоне клавиш. Они не были протестированы, так что вы можете проверить их только в форме сборки TVM: `SUBDICTGET` и т.п.
:::

#### Hashmap examples

Давайте посмотрим, как выглядят хэшкарты, смотря конкретно на отображение 257-битных целых клавиш на пустые ломтики значений (такая карта указывает только на наличие или отсутствие элемента).

Способ проверки быстро, это запустить следующий скрипт в Python (возможно, замените `pytoniq` другим SDK в зависимости от случая):

```python
импорт pytoniq
k = pytoniq.HashMap(257)
em = pytoniq.begin_cell().to_slice()
k.set(5, em)
k.set(7, em)
k. et(5 - 2**256, em)
k.set(6 - 2**256, em)
print(str(pytoniq.begin_cell().store_maybe_ref(k.serialize()).end_cell()))
```

Структура является двоичным деревом, даже сбалансированной, если не обратите внимания на корневую ячейку.

```
1[80] -> {
	2[00] -> {
		265[9FC00000000000000000000000000000000000000000000000000000000000000080] -> {
			4[50],
			4[50]
		},
		266[9FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF40] -> {
[00],
[00]
		}
	}
}
```

[Больше примеров парсинга хэш-карты](/v3/documentation/data-formats/tlb/tl-b-types#hashmap-parsing-example) в документации.

### Расширенные карты (с дополнительными данными в каждом узле)

Эти карты используются самостоятельно валидаторами TON для вычисления общего баланса всех контрактов в шарде (используя карты с общим балансом поддерева с каждым узлом позволяет им быстро проверить обновления). Для работы с ними нет примитивов TVM.

### Префикс словаря

:::info
Тестирование показывает, что существует недостаточная документация для создания префиксных словарей. Вы не должны использовать их в производственных контрактах, если вы не имеете полного знания о том, как соответствующие опкоды, "PFXDICTSET" и т.п.
:::
