# Функции

Программа FunC - это по сути список объявлений/определений функций и глобальных объявлений переменных. Этот раздел посвящен первой теме.

Любое определение функции или определение начинается с общего шаблона, и одна из трех вещей идет дальше:

- единственный `;`, что означает, что функция объявлена, но еще не определена. Он может быть определен позже в том же файле или в другом файле, который передается перед текущим компилятором FunC. Например,
  ```func
  int add(int x, int y);
  ```
  это простое объявление функции с именем `add` типа `(int, int) -> int`.

- определение функционального кузова сборщика. Это способ определения функций низкоуровневого TVM примитива для последующего использования в программе FunC. Например,
  ```func
  int add(int x, int y) asm "ADD";
  ```
  является определением ассемблера той же функции `add` типа `(int, int) -> int`, которая будет переведена на опкод TVM `ADD`.

- обычное определение описания блока функции. Это обычный способ определения функций. Например,
  ```func
  int add(int x, int y) {
    return x + y;
  }
  ```
  является обычным определением функции «add».

## Объявление функции

Как отмечалось ранее, любое определение функции или определение начинается с общей структуры. Следующий шаблон:

```func
[<forall declarator>] <return_type> <function_name>(<comma_separated_function_args>) <specifiers>
```

где `[ ... ]` соответствует необязательной записи.

### Имя функции

Имя функции может быть любым [identifier](/v3/documentation/smart-contracts/func/docs/literals_identifiers#identifiers) и может начинаться с символа `.` или `~`. Знаком этих символов является [explained](/v3/documentation/smart-contracts/func/docs/statements#methods-calls) в разделе операторов.

Например, `udict_add_builder?`, `dict_set` и `~dict_set` являются допустимыми и разными именами функций. (Они определены в [stdlib.fc](/v3/documentation/smart-contracts/func/docs/stdlib).)

#### Специальные имена функций

У FunC (на самом деле Fift assembler) несколько зарезервированных функций с предустановленным [ids](/v3/documentation/smart-contracts/func/docs/functions#method_id).

- `main` и `recv_internal` имеют id = 0
- `recv_external` имеет id = -1
- `run_ticktock` имеет id = -2

Каждая программа должна иметь функцию id 0, то есть функцию `main` или `recv_internal`.
`run_ticktock` называется в транзакциях ticktock специальных смарт-контрактов.

#### Получить внутренние

`recv_internal` вызывается, когда смарт-контракт получает входящее внутреннее сообщение.
В стеке есть несколько переменных, когда [TVM initiates](/v3/documentation/tvm/tvm-overview#initialization-of-tvm), установив аргументы в `recv_internal` мы даем знать о некоторых из них. Эти аргументы о том, какой код не знает, будет просто лежать в нижней части стека никогда не трогать.

Таким образом, каждое из следующих утверждений `recv_internal` верно, но те, у которых меньше переменных, тратят немного меньше газа (каждый неиспользуемый аргумент добавляет дополнительные инструкции `DROP`)

```func

() recv_internal(int balance, int msg_value, cell in_msg_cell, slice in_msg) {}
() recv_internal(int msg_value, ячейка in_msg_cell, срез in_msg) {}
() recv_internal(cell in_msg_cell, slice in_msg) {}
() recv_internal(slice in_msg) {}
```

#### Получить внешние

`recv_external` предназначен для входящих внешних сообщений.

### Тип возврата

Return type can be any atomic or composite type as described in the [types](/v3/documentation/smart-contracts/func/docs/types) section. Например,

```func
int foo();
(int, int) foo'();
[int, int] foo''();
(int -> int) foo'''();
foo<unk> (); 
 () foo<unk> ();
```

являются допустимыми декларированием функций.

Разрешена также установка по типу конструкции. Например,

```func
_ pyth(int m, int n) {
  return (m * m - n * n, 2 * м * n, m * m + n * n);
}
```

является допустимым определением функции «pyth» типа «(int, int) -> (int, int, int)», которая вычисляет тройки Pythagorean.

### Аргументы функции

Аргументы функции разделяются запятыми. Допустимыми заявлениями аргумента являются:

- Обычное объявление: тип + имя. Например, `int x` -- это объявление типа `int` и имени `x` в объявлении функции `() foo(int x);`
- Неиспользованное объявление аргумента: только тип. Например,
  ```func
  int first(int x, int) {
    return x;
  }
  ```
  является допустимым определением функции типа `(int, int) -> int`
- Аргумент с объявлением типа inferred : только имя.
  Например,
  ```func
  int inc(x) {
    return x + 1;
  }
  ```
  является допустимым определением функции типа `int -> int`. Тип `int` `x` задан типом checker.

Обратите внимание, что хотя функция может выглядеть как функция нескольких аргументов, она на самом деле является функцией одного [tensor-type](/v3/documentation/smart-contracts/func/docs/types#tensor-types). Чтобы увидеть разницу, обратитесь к [приложению функций](/v3/documentation/smart-contracts/func/docs/statements#function-application). Тем не менее компоненты аргумента обычно называются функциональными аргументами.

### Функциональные вызовы

#### Неизменяемые методы

:::info
Неизменяемая функция поддерживает короткую форму вызова функции с помощью `.`
:::

```func
example(a);
a.example();
```

Если у функции есть хотя бы один аргумент, то она может быть вызвана как метод немодификации. Например, у `store_uint` есть тип `(builder, int, int) -> builder` (второй аргумент должен храниться, а третий — битовая длина). `begin_cell` - это функция, создающая нового конструктора. Следующие коды эквивалентны:

```func
строитель b = begin_cell();
b = store_uint(b, 239, 8);
```

```func
builder b = begin_cell();
b = b.store_uint(239, 8);
```

Таким образом, первый аргумент функции может быть передан ей перед именем функции, если она разделена `.`. Код можно дополнительно упростить:

```func
builder b = begin_cell().store_uint(239, 8);
```

Возможны также несколько вызовов методов:

```func
builder b = begin_cell().store_uint(239, 8)
                        .store_int(-1, 16)
                        .store_uint(0xff, 10);
```

#### Изменение функций

:::info
Модификация функции поддерживает короткую форму операторами `~` и `.`.
:::

Если первый аргумент функции имеет тип «A», а возвращаемое значение функции имеет форму «(A, B)`, где `B\` - некоторый произвольный тип, то функция может быть вызвана в качестве модификационного метода.

Изменение вызовов функций может принимать некоторые аргументы и возвращать некоторые значения, но они изменяют их первый аргумент, то есть назначить первую часть возвращаемого значения переменной из первого аргумента.

```func
a~example();
a = example(a);
```

Например, предположим, что `cs` является частью ячейки, а `load_uint` имеет тип `(slice, int) -> (slice, int)`: требуется кусочек ячеек и количество битов для загрузки и возвращает оставшуюся часть маски и загруженное значение. Следующие коды эквивалентны:

```func
сс, int x) = load_uint(сs, 8);
```

```func
сс, int x) = cs.load_uint(8);
```

```func
int x = cs~load_uint(8);
```

В некоторых случаях мы хотим использовать функцию в качестве модификационного метода, который не возвращает ни одно значение и только изменяет первый аргумент. Это может быть сделано с помощью типов единиц следующим образом: Предположим, мы хотим определить функцию `inc` типа `int -> int`, , который увеличивает целое число, и использовать его в качестве модификационного метода. Затем мы должны определить «inc» как функцию типа «int -> (int, ()»:

```func
(int, ()) inc(int x) {
  return (x + 1, ());
}
```

При таком определении он может быть использован в качестве модификационного метода. Ниже будет прибавлено значение `x`.

```func
x~inc();
```

#### `.` и `~` в именах функций

Предположим, мы хотим использовать «inc» в качестве немодифицирующего метода. Мы можем написать что-то вроде следующего:

```func
(int y, _) = inc(x);
```

Но можно переопределить определение «inc» как модификационный метод.

```func
int inc(int x) {
  return x + 1;
}
(int, ()) ~inc(int x) {
  return (x + 1, ());
}
```

А затем именуйте это так:

```func
x~inc();
int y = inc(x);
int z = x.inc();
```

Первый вызов будет модифицировать x; второй и третий не будут.

Короче говоря, когда функция с именем «foo» называется методом немодификации или изменения (i). с синтаксисом `.foo` или `~foo`), компилятор FunC использует определение `. oo` или `~foo` соответственно, если такое определение представлено, а если нет, то оно использует определение `foo`.

### Спецификаторы

Есть три типа спецификаторов: `impure`, `inline`/`inline_ref` и `method_id`. Одни, несколько, или никто из них не может быть помещен в объявление функции, но в настоящее время они должны быть представлены в правильном порядке. Например, после 'inline' поместить `impure` запрещено.

#### 5.2 Нечистый указатель

Параметр `impure` означает, что функция может иметь некоторые побочные эффекты, которые нельзя игнорировать. Например, мы должны поместить спецификатор `impure`, если функция может изменить хранение контракта, отправить сообщения, или выбросить исключение, когда некоторые данные недействительны и функция предназначена для проверки этих данных.

Если `impure` не указан и результат вызова функции не используется, , то компилятор FunC может и удалит этот вызов функции.

Например, в функции [stdlib.fc](/v3/documentation/smart-contracts/func/docs/stdlib)

```func
int random() impure asm "RANDU256";
```

определено. `impure` используется, потому что `RANDU256` изменяет внутреннее состояние генератора случайных чисел.

#### Встроенный спецификатор

Если у функции есть спецификатор 'inline', то ее код на самом деле заменяется на каждом месте, где функция вызывается. Само собой разумеется, что неоднократные призывы к внутренним функциям невозможны.

Например,

```func
(int) add(int a, int b) inline {
    return a + b;
}
```

так как функция "add" помечена спецификатором "inline". Компилятор попытается заменить вызовы в `add` фактическим кодом `a + b`, избегая переадресации функции вызова.

Еще один пример того, как вы можете использовать inline, взятый из [ICO-Minter.fc](https://github.com/ton-blockchain/token-contract/blob/f2253cb0f0e1ae0974d7dc0cef3a62cb6e19f806/ft/jetton-minter-ICO.fc#L16):

```func
() save_data(int total_supply, slice admin_address, содержимое ячейки, клеточный jetton_wallet_code) impure inline {
  set_data(begin_cell()
            . tore_coins(сумма_supply)
            . tore_slice(admin_address)
            . tore_ref(content)
            . tore_ref(jetton_wallet_code)
           . nd_cell()
          );
}
```

#### Inline_ref спецификатор

Код функции с спецификатором 'inline_ref' помещается в отдельную ячейку, и каждый раз, когда функция вызывается, команда «CALLREF» выполняется TVM. Таким образом, она похожа на 'inline', но потому что ячейка может использоваться повторно без дублирования в нескольких местах, в терминах размера кода почти всегда более эффективно использовать спецификатор `inline_ref` вместо `inline`, если только функция не называется ровно один раз. Рекурсивные вызовы функции inline_ref'а до сих пор невозможны, так как в ячейках TVM нет циклических ссылок.

#### method_id

Каждая функция программы TVM имеет внутренний целочисленный идентификатор, с помощью которого она может быть вызвана. Обычные функции обычно нумеруются последующими целыми числами, но get-методы контракта пронумерованы crc16 хэшами. `method_id(<some_number>)` спецификатор позволяет задать id функции в указанное значение, и `method_id` использует значение `(crc16(<function_name>) & 0xffff) | 0x10000`. Если у функции есть спецификатор `method_id`, то она может быть вызвана в lite-client или ton-explorer в качестве get-метода по его имени.

Например,

```func
(int, int) get_n_k() method_id {
  (_, int n, int k, _, _, _) = unpack_state();
  return (n, k);
}
```

является get-методом многостороннего контракта.

### Полиморфизм со всеми

Перед любым декларированием или определением функции может быть декларирование переменных типа `forall`. Он имеет следующий синтаксис:

```func
forall <comma_separated_type_variables_names>->
```

где имя переменной типа может быть любым [identifier](/v3/documentation/smart-contracts/func/docs/literals_identifiers#identifiers). Обычно они называются прописными буквами.

Например,

```func
forall X, Y -> [Y, X] pair_swap([X, Y] pair) {
  [X p1, Y p2] = pair;
  return [p2, p1];
}
```

является функцией, которая принимает трубку длины ровно 2, , но со значениями любых (одного стека) типов в компонентах и изменяет их друг с другом.

`pair_swap([2, 3])` будет производиться `[3, 2]` и `pair_swap([1, [2, 3, 4]])` будет производиться `[[2, 3, 4], 1]`.

В данном примере `X` и `Y` [тип переменных](/v3/documentation/smart-contracts/func/docs/types#polymorphism-with-type-variables). При вызове функции переменные типа заменяются фактическими типами, и выполняется код функции. Обратите внимание, что хотя эта функция является полиморфической, фактический код сборки для каждой подстановки одинаков. Это достигается по сути полиморфизмом стека манипулирующих примитивами. В настоящее время другие формы полиморфизма (например, ad-hoc полиморфизм с типовыми классами) не поддерживаются.

Также стоит отметить, что ширина типа `X` и `Y` должна быть равна 1; то есть значения «X» или «Y» должны занять одну запись в стеке. Таким образом, на самом деле вы не можете вызвать функцию `pair_swap` на трубке типа `[(int, int), int]`, потому что тип `(int, int)` имеет ширину 2, i. ., она занимает 2 записи стека.

## Определение тела сборщика

Как упоминалось выше, функцию можно определить с помощью кода сборщика. Синтаксис представляет собой ключевое слово `asm`, за которым следуют один или несколько команд assembler, представленных в виде строк.
Например, можно определить:

```func
int inc_then_negate(int x) asm "INC" "NEGATE";
```

– функция, которая увеличивает целое число, а затем отрицает его. Звонки этой функции будут переведены на 2 команды сборщика `INC` и `NEGATE`. Альтернативный способ определения функции:

```func
int inc_then_negate'(int x) asm "INC NEGATE";
```

`INC NEGATE` будет рассматриваться FunC как одна команда сборщика, но это нормально, потому что Fift assembler знает, что это 2 отдельных команды.

:::info
Список команд ассемблера можно найти здесь: [инструкции TVM](/v3/documentation/tvm/instructions).
:::

### Перестроенные записи в стеке

В некоторых случаях мы хотим передать аргументы функции сборщика в том порядке, в котором требует команда сборки, или/и взять результат в другой последовательности записей, чем возвращается команда. Мы могли бы вручную изменить расположение стека, добавив соответствующие примитивы стека, но FunC может сделать это автоматически.

:::info
Обратите внимание, что при реорганизации вручную аргументы будут вычислены в переоборудованном порядке. Для перезаписи этого поведения используйте `#pragma compute-asm-ltr`: [compute-asm-ltr](/v3/documentation/smart-contracts/func/docs/compiler_directives#pragma-compute-asm-ltr)
:::

Например, предположим, что команда сборщика STUXQ принимает целое число, конструктор и целое; затем он возвращает конструктор вместе с флагом integer (integer flag), указывающим на успех или неудачу операции.
Мы можем определить функцию:

```func
(builder, int) store_uint_quite(int x, builder b, int len) asm "STUXQ";
```

Однако предполагается, что мы хотим переставить аргументы. Затем мы можем определить:

```func
(builder, int) store_uint_quite(builder b, int x, int len) asm(x b len) "STUXQ";
```

Таким образом, после ключевого слова `asm` можно указать требуемый порядок аргументов.

Также, мы можем переставить возвращаемые значения:

```func
(int, builder) store_uint_quite(int x, builder b, int len) asm( -> 1 0) "STUXQ";
```

Номера соответствуют индексам возвращаемых значений (0 - это самый глубокий элемент стека среди возвращаемых значений).

Также возможно объединение этих техник.

```func
(int, builder) store_uint_quite(builder b, int x, int len) asm(x b len -> 1 0) "STUXQ";
```

### Многострочные асмы

Мультистрочная команда ассемблера или даже пятистрочные сниппеты могут быть определены через многострочные строки, которые начинаются и заканчиваются `"""`.

```func
срез hello_world() asm """
  "Hello"
  " "
  "Мир"
  $+ $>s
  PUSHSLICE
""";
```
