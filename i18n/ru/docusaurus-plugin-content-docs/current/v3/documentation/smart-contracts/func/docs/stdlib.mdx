---
toc_min_heading_level: 2
toc_max_heading_level: 6
---

# Стандартная библиотека FunC

:::info
В этом разделе обсуждается библиотека [stdlib.fc](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/stdlib.fc) со стандартными функциями, используемыми в FunC.
:::

В настоящее время библиотека является лишь оберточным для наиболее распространенного сборщика команд TVM, которые не встроены. Каждое использованное в библиотеке описание команд TVM можно найти в разделе [документация TVM](/v3/documentation/tvm/tvm-overview). Некоторые описания были заимствованы для этого документа.

Некоторые функции закомментированы в файле. Это означает, что они уже стали встроенными в целях оптимизации. Однако подпись типа и семантика остаются неизменными.

Обратите внимание, что некоторые менее распространенные команды не представлены в stdlib. Однажды они также будут добавлены.

## Примитивы манипуляций с трубами

Имена и типы в основном самообъясняются. См. [полиморхизм с forall](/v3/documentation/smart-contracts/func/docs/functions#polymorphism-with-forall) для получения дополнительной информации о функциях полиморфии.

Заметим, что значения атомарного типа 'трубка' не могут быть включены в составные типы (например, `[int, cell]`) и vise versa.

### Списки стилей Lisp

Списки могут быть представлены как вложенные двухэлементные трубки. Пустой список обычно представлен в виде TVM 'null' (его можно получить, позвонив 'null()'). Например, трубка `(1, (2, (3, null)))` представляет список `[1, 2, 3]`. Элементы списка могут быть различными.

#### минус

```func
forall X -> tuple cons(X head, tuple tail) asm "CONS";
```

Добавляет элемент в начало списка стилей lisp.

#### отключиться

```func
forall X -> (X, tuple) uncons(tuple list) asm "UNCONS";
```

Извлекает голову и хвост списка стиля Лис.

#### следующий список

```func
forall X -> (tuple, X) list_next(tuple list) asm( -> 1 0) "UNCONS";
```

Извлекает голову и хвост списка стилей Лис. Может использоваться как [(non-)модифицирующий метод](/v3/documentation/smart-contracts/func/docs/statements#methods-calls).

```func
() foo(tuple xs) {
    (_, int x) = xs. ist_next(); ;; получить первый элемент, `_` означает не использовать хвостовой список
    int y = xs~list_next(); ;; pop первый элемент
    int z = xs~list_next(); ;; pop второй элемент
}
```

#### авто

```func
forall X -> X car(tuple list) asm "CAR";
```

Возвращает голову списка стилей lisp.

#### кдр

```func
трубка cdr(туообразный список) asm "CDR";
```

Возвращает хвост списка стилей lisp.

### Другие примитивы

#### пустая тушка

```func
трубка empty_tuple() asm "NIL";
```

Создает нулевую патрубку.

#### tpush

```func
forall X -> tuple tpush(tuple t, X value) asm "TPUSH";
forall X -> (tuple, ()) ~tpush(tuple t, X value) asm "TPUSH";
```

Добавляет значение `x` к `Tuple t = (x1, ... xn)`, но только если получившийся `Tuple t' = (x1, ..., xn, x)` не превышает 255 символов. Иначе выводится исключение для проверки типа.

#### одинарный

```func
forall X -> [X] single(X x) см "SINGLE";
```

Создает синглтон, то есть трубку длиной один.

#### неодинарный

```func
forall X -> X unsingle([X] t) asm "UNSINGLE";
```

Распакует синглтон.

#### пара

```func
forall X, Y -> [X, Y] pair(X x, Y y) asm "PAIR";
```

Создает пару.

#### отчистить

```func
forall X, Y -> (X, Y) unpair([X, Y] t) asm "UNPAIR";
```

Распаковывает пару.

#### тройное

```func
forall X, Y, Z -> [X, Y, Z] triple(X x, Y y, Z z) asm "TRIPLE";
```

Создает тройку.

#### нетронутый

```func
forall X, Y, Z -> (X, Y, Z) untriple([X, Y, Z] t) asm "UNTRIPLE";
```

Распаковывает тройку.

#### трубочка4

```func
forall X, Y, Z, W -> [X, Y, Z, W] tuple4(X x, Y y, Z z, W w) asm "4 TUPLE";
```

Создает 4-элементный трубок.

#### untuple4

```func
forall X, Y, Z, W -> (X, Y, Z, W) untuple4([X, Y, Z, W] t) asm "4 UNTUPLE";
```

Распаковывает 4-элементную трубку.

#### первый

```func
forall X -> X first(tuple t) asm "FIRST";
```

Возвращает первый элемент трубки.

#### секунда

```func
forall X -> X second(tuple t) asm "SECOND";
```

Возвращает второй элемент трубки.

#### третья

```func
forall X -> X third(tuple t) asm "THIRD";
```

Возвращает третий элемент трубки.

#### четвертый

```func
forall X -> X четвертый (трубчатый t) asm "3 INDEX";
```

Возвращает четвертый элемент трубки.

#### первой_пара

```func
forall X, Y -> X pair_first([X, Y] p) asm "FIRST";
```

Возвращает первый элемент пары.

#### пара секунды

```func
forall X, Y -> Y pair_second([X, Y] p) asm "SECOND";
```

Возвращает второй элемент пары.

#### тройный_первый

```func
forall X, Y, Z -> X triple_first([X, Y, Z] p) asm "FIRST";
```

Возвращает первый элемент тройки.

#### тройная секунда

```func
forall X, Y, Z -> Y triple_second([X, Y, Z] p) asm "SECOND";
```

Возвращает второй элемент тройки.

#### тройная третья

```func
forall X, Y, Z -> Z triple_third([X, Y, Z] p) asm "THIRD";
```

Возвращает третий элемент тройки.

## Примитивы, специфичные для домена

### Извлечение информации из c7

Некоторую полезную информацию о приглашении на контракт можно найти в специальном регистре [c7](/v3/documentation/tvm/tvm-overview#control-registers). Эти примитивы служат для удобного извлечения данных.

#### сейчас

```func
int now() asm "СЕЙЧАС";
```

Возвращает текущее время Unix как целое число

#### my_адрес

```func
срез my_address() asm "MYADDR";
```

Возвращает внутренний адрес текущего смарт-контракта как кусочек с `MsgAddressInt`. При необходимости его можно разобрать, используя примитивы, такие как `parse_std_addr`.

#### get_balance

```func
[int, cell] get_balance() asm "BALANCE";
```

Возвращает оставшийся баланс смарт-контракта как «трубка», состоящий из «int» (оставшийся баланс в nanotoncoin) и «cell» (словарь с 32-битными ключами, представляющими баланс «дополнительных валют»). Обратите внимание, что RAW примитивы, такие как `send_raw_message` не обновляют это поле.

#### cur_lt

```func
int cur_lt() asm "LTIME";
```

Возвращает логическое время текущей транзакции.

#### block_lt

```func
int block_lt() asm "BLOCKLT";
```

Returns the starting logical time of the current
block.

#### config_param

```func
ячейка config_param(int x) asm "CONFIGOPTPARAM";
```

Возвращает значение глобального параметра конфигурации с индексом `i` как `cell` или `null`.

### Хэши

#### хэш ячейки

```func
int cell_hash(cell c) asm "HASHCU";
```

Вычисляет хэш представлений `cell c` и возвращает его как 256-битное незнакомое целое значение `x`. Полезно для подписания и проверки подписей произвольных сущностей, представленных деревом ячеек.

#### хэш

```func
int slice_hash(slice s) asm "HASHSU";
```

Вычисляет хэш `slice s` и возвращает его как 256-битное незнакомое целое значение `x`. Результат такой же, как если бы была создана обычная ячейка, содержащая только данные и ссылки из папки `s`, а также ее хэш, вычисленный пользователем `cell_hash`.

#### хэш строки

```func
int string_hash(slice s) asm "SHA256U";
```

Рассчитывает sha256 данных битов `slice s`. Если длина бита «s» не делится на восьмерку, то она выдаёт исключение переполнения ячейки. Хэш-значение возвращается как 256-битное незнакомое целое «x».

### Проверка подписи

#### проверить подпись

```func
int check_signature(int hash, slice signature, int public_key) asm "CHKSIGNU";
```

Проверяет `signature` Ed25519 из `hash` (256-битное не подписанное целое, обычно вычисляется как хэш некоторых данных), используя `public_key` (также представлен 256-битным незнаковым числом). Подпись должна содержать не менее 512 битов данных; используется только первые 512 бит. Если подпись верна, результат — `-1`; в противном случае — `0`. Обратите внимание, что `CHKSIGNU` создает 256-битный кусочек с хэшем и вызывает `CHKSIGNS`. То есть, если `hash` вычисляется как хэш некоторых данных, то эти данные хэшируются _twice_, а второй хэш происходит внутри `CHKSIGNS`.

#### check_data_signature

```func
int check_data_signature(данные о масках, подпись маски, int public_key) asm "CHKSIGNS";
```

Проверяет, является ли `signature` верной подписью Ed25519 части данных `slice data`, используя `public_key`, аналогично `check_signature`. Если битовая длина `data` не делится на восьмерку, она выдаёт исключение переполнения ячейки. Верификация Ed25519 подписей является стандартной, с sha256 для уменьшения числа `data` до 256-битного числа, который фактически подписан.

### Вычисление размера бока

Примититы, приведенные ниже, могут быть полезны для расчета сборов за хранение данных пользователя.

#### compute_data_size?

```func
(int, int, int) compute_data_size?(cell c, int max_cells) asm "CDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT";
```

Возвращает `(x, y, z, -1)` или `(null, null, null, 0)`. Рекурсивно вычисляет количество разных ячеек `x`, битов `y` и ссылки на ячейку `z` в DAG корневой точке `ячейки`, эффективно возвращает общее хранилище, используемое этим DAG с учетом определения одинаковых ячеек. Значения «x», «y», «y», и `z` вычисляются глубоко первым прохождением этого DAG с хэш-таблицей посещенных ячеек для предотвращения посещений уже посещаемых ячеек. Общее количество посещенных ячеек не может превышать отрицательный `max_cells`; в противном случае, вычисление прервано до посещения ячейки `(max_cell + 1)`-st и возвращается нулевой флаг для обозначения ошибки. Если `c` это `null`, то он возвращает `x = y = z = 0`.

#### slice_compute_data_size?

```func
(int, int, int) slice_compute_data_size?(slice s, int max_cells) asm "SDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT";
```

Аналогично `compute_data_size?`, но принимает `slice s` вместо `cell`. Возвращаемое значение `x` не учитывает ячейку, которая содержит сам кусочек `s`; Однако данные и ссылки на ячейки 's' учитываются в `y` и `z`.

#### размер вычислителя_данных

```func
(int, int, int) compute_data_size(cell c, int max_cells) impure asm "CDATASIZE";
```

Нетихую версию `compute_data_size?`, которая бросает исключение переполнения ячейки (8) при ошибке.

#### размер slice_compute_data_

```func
(int, int, int) slice_compute_data_size(slice s, int max_cells) impure asm "SDATASIZE";
```

Нетихую версию `slice_compute_data_size?`, которая бросает исключение переполнения ячейки (8) при ошибке.

### Постоянное сохранение и загрузка накопителя

#### get_данные

```func
ячейка get_data() asm "c4 PUSH";
```

Возвращает постоянную ячейку хранения контракта. Позже его можно разобрать или модифицировать с помощью кусков и строителей примитивов.

#### набор данных

```func
() set_data(клеточная с) нарушающая ось "c4 POP";
```

Устанавливает ячейку 'c' постоянными контрактными данными. Вы можете обновить постоянное хранение контракта с этим примитивом.

### Продолжение примитивов

#### get_c3

```func
cont get_c3() impure asm "c3 PUSH";
```

Обычно `c3` имеет продолжение инициализации по всему коду контракта. Используется для вызовов функций. Примитивный возвращает текущее значение `c3`.

#### набор c3

```func
() set_c3(cont c) нарушить asm "c3 POP";
```

Обновляет текущее значение «c3». Обычно используется для обновления кода смарт-контракта в момент выполнения. Обратите внимание, что после выполнения этого примитива текущий код (и стек рекурсивных вызовов функций) не меняется но любой другой вызов функции будет использовать функцию из нового кода.

#### благословение

```func
ясень благословение (маска ) затухает "BLESS";
```

Преобразует `slice s` в простое обычное продолжение `c` с помощью `c.code = s`, и пустой стек и savelist.

### Примититы, связанные с газом

#### принять сообщение

```func
() impure asm accept_message() "ACCEPT";
```

Устанавливает текущий предел газа `gl` на его максимально допустимое значение `gm` и сбрасывает зачёт `gc` на ноль, уменьшение значения «gr» на «gc» в процессе. Другими словами, текущий смарт-контракт согласен на покупку газа для завершения текущей сделки. Это действие требуется для обработки внешних сообщений, не имеющих никакого значения (отсюда и нет газа).

Для получения более подробной информации проверьте [accept_message effects](/v3/documentation/smart-contracts/transaction-fees/accept-message-effects)

#### предел нагрузки

```func
() set_gas_limit(int limit) нарушает асму "SETGASLIMIT";
```

Устанавливает минимальный предел газа `gl` в `limit` и `gm` и сбрасывает зачёт `gc` на нуль. На тот момент, если количество потребляемого газа (включая настоящую инструкцию) превышает конечное значение `gl`, (необработанный) выбрасывается из исключения из газа, прежде чем устанавливать новые предельные значения газа. Обратите внимание, что `set_gas_limit` с аргументом `limit ≥ 2^63 − 1` эквивалентен `accept_message`.

Для получения более подробной информации проверьте [accept_message effects](/v3/documentation/smart-contracts/transaction-fees/accept-message-effects)

#### коммит

```func
() commit() impure asm "COMMIT";
```

Зафиксирует текущее состояние реестров `c4` («непрерывные данные») и `c5` («действия»), чтобы текущее выполнение считалось «успешным» с сохраненными значениями, даже если исключение было выведено позже.

#### купить газ

```func
() impure asm buy_gas(int gram) "BUYGAS";
```

:::caution
`BUYGAS` опкод в настоящее время не реализован
:::

Вычисляет количество газа, которое можно купить за `gram` nanotoncoins и соответственно устанавливает `gl` таким же образом, как `set_gas_limit`.

### Примитивы действий

#### raw_заповедник

```func
() raw_reserve(int amount, int mode) нарушает asm "RAWRESERVE";
```

Создает действие вывода, которое зарезервировало бы ровно `amount` nanotoncoins (если `mode = 0`), максимум `amount` nanotoncoins (если `mode = 2`), или все, кроме `amount` nanotoncoins (если `mode = 1` или `mode = 3`) с оставшегося баланса счета. Это примерно эквивалентно созданию исходящего сообщения, содержащего `amount` nanotoncoins (или `b - количество` nanotoncoins, где `b` является оставшимся балансом) на себя, так что последующие действия вывода не смогут тратить больше денег, чем остаток. Бит +2 в 'режиме' означает, что внешнее действие не проваливается, если указанная сумма не может быть зарезервирована; вместо этого, весь остаток зарезервирован. Бит +8 в режиме `mode` означает `amount <- -amount` перед выполнением дальнейших действий. Бит +4 в 'режиме' означает, что `amount` увеличивается на первоначальный баланс текущего счета (до этапа вычисления), включая все дополнительные валюты перед выполнением любых других проверок и действий. В настоящее время `amount` должен быть неотрицательным целым числом, а `mode` должен быть в диапазоне `0..15`.

#### raw_reserve_extra

```func
() raw_reserve_extra(int amount, cell extra_amount, int mode) нарушает asm "RAWRESERVEX";
```

Аналогично `raw_reserve`, но также принимает словарь `extra_amount` (представлен `cell` или `null`) с дополнительными валютами. Таким образом, валюты, отличные от Toncoin, могут быть зарезервированы.

#### send_raw_message

```func
() send_raw_message(cell msg, int mode) impure asm "SENDRAWMSG";
```

Отправляет необработанное сообщение, содержащееся в `msg`, которое должно содержать правильно сериализованные объектные сообщения X, с единственным исключением, что адрес источника может иметь значение `addr_none` (будет автоматически заменен текущим адресом смарт-контракта), и `ihr_fee`, `fwd_fee`, `created_lt` и `created_at` могут иметь произвольные значения (должны быть перезаписаны правильными значениями во время текущей транзакции). Параметр `mode` содержит флаги.

На данный момент есть 3 режима и 4 флага для сообщений. Вы можете комбинировать один режим с несколькими (возможно, none) флагами для получения требуемого `mode`. Комбинация означает просто получение суммы их значений. Ниже приведена таблица с описаниями режимов и флагов.

| Режим  | Описание                                                                                                                     |
| :----- | :--------------------------------------------------------------------------------------------------------------------------- |
| `0`    | Обычное сообщение                                                                                                            |
| `64`   | Перенесите все оставшиеся значения входящего сообщения в дополнение к значению, первоначально указанному в новом сообщении   |
| `128`  | Провести все оставшиеся остатки текущего смарт-контракта вместо значения, первоначально указанного в сообщении               |

| Флаг  | Описание                                                                                                                             |
| :---- | :----------------------------------------------------------------------------------------------------------------------------------- |
| `+1`  | Оплатить комиссию за перевод отдельно от стоимости сообщения                                                                         |
| `+2`  | Игнорировать некоторые ошибки, возникающие при обработке этого сообщения на этапе действия (отметьте ниже)                           |
| `+16` | В случае действия не удалось - отскочить транзакцию. Эффект «+2» не используется.                                                    |
| `+32` | Текущий счет должен быть уничтожен, если его результирующий баланс равен нулю (часто используется с режимом 128)                     |

:::info +2 флаг

1. Недостаточно Тонкоинов:
   - Недостаточно значения для передачи сообщения (было потрачено все входящее сообщение).
   - Недостаточно средств для обработки сообщения.
   - Недостаточно значений, привязанных к сообщению для оплаты трансакционных сборов.
   - Недостаточно дополнительной валюты для отправки сообщения.
   - Недостаточно средств для оплаты внешних исходящих сообщений.
2. Сообщение слишком велико (проверьте [размер сообщения](/v3/documentation/smart-contracts/message-management/sending-messages#message-size) для больше).
3. У сообщения слишком большая глубина Merkle.

Однако он не игнорирует ошибки в следующих сценариях:

1. Сообщение имеет неверный формат.
2. Режим сообщений включает и 64 и 128 модов.
3. Исходящее сообщение содержит некорректные библиотеки в StateInit.
4. Внешнее сообщение не является обычным или содержит флаг +16 или +32 или оба флага.
   :::

:::warning

1. **+16 флагов** — не используйте внешние сообщения (например, в кошельки), так как отправителя не получает.
2. **+2 флаг** — важна во внешних сообщениях (например, в кошельках).
   :::

Подробный пример [here](/v3/documentation/smart-contracts/message-management/sending-messages#example-with-use-cases).

#### установить код

```func
() set_code(ячейка new_code) нарушает ось "SETCODE";
```

Создает выходное действие, которое изменит этот смарт-код на тот из ячейки `new_code`. Обратите внимание, что это изменение вступит в силу только после успешного прекращения текущего запуска смарт-контракта. (Ср. [set_c3](/v3/documentation/smart-contracts/func/docs/stdlib#set_c3))

### Примитивы генератора случайных чисел

Псевдослучайный генератор чисел использует случайный seed, неподписанное 256-битное целое и (некоторые) другие данные, хранящиеся в [c7](/v3/documentation/tvm/tvm-overview#control-registers). Начальное значение случайного seed перед выполнением смарт-контракта в TON Blockchain представляет собой хэш адреса смарт-контракта и глобального случайного seed. Если внутри блока есть несколько запусков одного и того же смарт-контракта, то у всех этих запусков будет одно и то же самое. Это можно исправить, например, запустив `randomize_lt` перед использованием генератора случайных чисел в первый раз.

:::caution
Keep in mind that random numbers generated by the functions below can be predicted if you do not use additional tricks.

- [Генерация случайных чисел](/v3/guidelines/smart-contracts/security/random-number-generation)

:::

#### случайный

```func
int random() impure asm "RANDU256";
```

Генерирует новый псевдослучайный unsigned 256-bit integer `x`. Алгоритм выглядит следующим образом: если «r» — это старое значение случайного seed — 32-байтного массива (путем построения big-endian представления неподписанного 256-битного целого), затем вычисляется `sha512(r)`; первые 32 байта этого хэша хранятся как новое значение `r'` случайного seed, и оставшиеся 32 байта возвращаются как следующее случайное значение `x`.

#### рэнд

```func
int rand(int range) неочищенная ось "RAND";
```

Генерирует новый псевдослучайный целочисленный `z` в диапазоне `0..range−1` (или `range..−1` если `range < 0`). Точнее, случайное значение `x` генерируется как значение `random`; затем `z := x * диапазон / 2^256` вычисляется
.

#### get_seed

```func
int get_seed() непонятно "РАНССЕРИЯ";
```

Возвращает текущее случайное семя как неподписанное 256-битное целое число.

#### _установить сид

```func
int set_seed(int seed) impure asm "SETRAND";
```

Устанавливает случайное семя неподписанным 256-битным семенем.

#### случайный

```func
() в случайном порядке(int x) нарушается ось "ADDRAND";
```

Смешивает незнакомое 256-битное целое `x` в случайное семя `r`, установив случайное семя на sha256 от слияния двух 32-байтовых строк: первая с big-endian представлением старого seed `r`, и второй с big-endian представлением `x`.

#### randomize_lt

```func
() impure asm "LTIME" "ADDRAND";
```

Эквивалент `randomize(cur_lt());`.

### Примитивы управления адресами

Примитивы адреса, перечисленные ниже, сериализовать и десериализовать значения в соответствии с следующей схемой TL-B.

```func
addr_none$00 = MsgAddressExt;

addr_extern$01 len:(## 8) external_address:(bits len)
             = MsgAddressExt;

anycast_info$_ глубина:(#<= 30) { depth >= 1 }
  rewrite_pfx:(bits depth) = Anycast;

addr_std$10 anycast:(Maybe Anycast)
  workchain_id:int8 address:bits256 = MsgAddressInt;

addr_var$11 anycast:(Maybe Anycast) addr_len:(## 9)
  workchain_id:int32 address:(bits addr_len) = MsgAddressInt;
_ _:MsgAddressInt = MsgAddress;
_ _:MsgAddressExt = MsgAddress;

int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
  src:MsgAddress dest:MsgAddressInt
  value:CurrencyCollection ihr_fee:Grams fwd_fee:Grams
  created_lt:uint64 created_at:uint32 = CommonMsgInfoRelaxed;

ext_out_msg_info$11 src:MsgAddress dest:MsgAddressExt
  created_lt:uint64 created_at:uint32 = CommonMsgInfoRelaxed;
```

Десериализованный "MsgAddress" представлен следующим образом:

- `addr_none` представлен `t = (0)`, т.е. трубочкой, содержащей ровно
  одно целое, равное нулю
- `addr_extern` is represented by `t = (1, s)`, where slice `s` contains the
  field `external_address`. Другими словами, «t» — это пара (трубочка, состоящая из двух записей), содержащая число, равное одному и маске «s»
- `addr_std` представлен в формате `t = (2, u, x, s)`, где `u` либо `null` (если `anycast` отсутствует), либо кусочек `s'`, содержащий `rewrite_pfx` (если `anycast` присутствует). Далее, целое число `x` — это `workchain_id`, а маска `s` содержит адрес
- «addr_var» представлен в виде «t = (3, u, x, s)», где «u», «x» и «s» имеют то же значение, что и для «addr_std»

#### загрузка_мсг_ддр

```func
(slice, slice) load_msg_addr(slice s) asm( -> 1 0) "LDMSGADDR";
```

Загружает из `slice s` единственный префикс, который является допустимым `MsgAddress` и возвращает оба префикса `s'` и оставшиеся `s''` в качестве slices.

#### parse_addr

```func
трубка parse_addr(slice ) asm "PARSEMSGADDR";
```

Декомпилирует `slice s`, содержащий корректный `MsgAddress` в `tuple t` с отдельными полями этого `MsgAddress`. Если `s` не является допустимым `MsgAddress`, то выводится исключение десериализации ячеек.

#### parse_std_addr

```func
(int, int) parse_std_addr(slice s) asm "REWRITESTDADDR";
```

Разделяет фрагменты `s`, содержащие допустимые `MsgAddressInt` (обычно `msg_addr_std`), применяет перезапись из `anycast` (если есть) в одинаковый префикс адреса и возвращает как рабочую цепочку, так и 256-битный адрес в качестве целых чисел. Если адрес не 256-бит или «s» не является допустимой сериализацией «MsgAddressInt», то выдаёт исключение «десериализация».

#### parse_var_addr

```func
(int, slice) parse_var_addr(slice s) asm "REWRITEVARADDR";
```

Вариант `parse_std_addr`, который возвращает адрес (rewriten) в виде маски `s`, даже если он не ровно 256 бит длиной (представлен `msg_addr_var`).

## Отладка примитивов

Отладочные примитивы могут быть использованы для проверки состояния различных переменных при запуске тестов или консольных скриптов.

#### ~дамп

```func
forall X -> () ~dump(значение X) нарушить asm "s0 DUMP";
```

Выводит ценность. Несколько значений можно сбросить как трубку, например `~dump([v1, v2, v3])`.

#### ~strdump

```func
() ~strdump(slice str) наружная ось "STRDUMP";
```

Дает строку. Длина бита параметра Slice должна быть делится на 8.

#### дамп_стек

```func
() impure asm dump_stack() "ДюМПСТК";
```

Давливает стек (на большинстве 255 верхних значений) и показывает полную глубину стека.

## Примитивы кусочков

Считается, что примитивные _загрузки_ некоторые данные, если он возвращает данные и оставшуюся часть маски (так что он также может использоваться как [модифицирующий метод](/v3/documentation/smart-contracts/func/docs/statements#modifying-methods)).

Говорят, что примитивные _preloads_ некоторые данные, если они возвращают только данные (их можно использовать в качестве [немодифицирующего метода](/v3/documentation/smart-contracts/func/docs/statements#non-modifying-methods)).

Если не указано иное, загрузка и предварительная загрузка примитивов считывают данные с префикса маски.

#### начальный раз_бор

```func
срез begin_parse(ячейка c) asm "CTOS";
```

Преобразует `cell` в `slice`. Обратите внимание, что `c` должен быть обычной ячейкой или экзотической ячейкой (см. [TVM.pdf](https://ton.org/tvm. df), 3.1.2), который автоматически загружается для получения обычной ячейки `c' впоследствии преобразована в `slice\`.

#### Окончательный разбор

```func
() end_parse(slice s) нарушает "ENDS";
```

Проверяет, является ли «s» пустым. Если нет, то вводит исключение.

#### нагрузка_реф

```func
(slice, cell) load_ref(slice s) asm( -> 1 0) "LDREF";
```

Загружает первую ссылку из маски.

#### preload_ref

```func
preload_ref(slice s) asm "PLDREF";
```

Предзагружает первую ссылку из маски.

#### _инт загрузки

```func
;; (slice, int) ~load_int(slice s, int len) asm(s len -> 1 0) "LDIX";
```

Загружает подписанное целое число `len`-bit из ломтика.

#### _выгрузка

```func
;; (slice, int) ~load_uint(Slice s, int len) asm( -> 1 0) "LDUX";
```

Загружает незнакомое целое число `len`-bit из ломтика.

#### предзагрузка_инт

```func
;; int preload_int(slice s, int len) asm "PLDIX";
```

Предварительно загружает знакомое целое число `len`-бит из ломтика.

#### предзагрузка_инт

```func
;; int preload_uint(Slice s, int len) asm "PLDUX";
```

Предзагружает незнакомое целое число `len`-bit из ломтика.

#### _загрузить биты

```func
;; (slice, slice) load_bits(slice s, int len) asm(s len -> 1 0) "LDSLICEX";
```

Загружает первые `0 ≤ len ≤ 1023` бит из маски `s` в отдельный кусочек \`s''.

#### предзагрузки_биты

```func
;; slice preload_bits(slice s, int len) asm "PLDSLICEX";
```

Предварительно загружает первые `0 ≤ len ≤ 1023` бит из маски `s` в отдельный кусочек \`s''.

#### загрузить монеты

```func
(slice, int) load_coins(slice s) asm( -> 1 0) "LDGRAMS";
```

Загружает сериализованное количество Toncoins (любое неподписанное целое число до `2^120 - 1`).

#### про_кинуть биты

```func
slice skip_bits(slice s, int len) asm "SDSKIPFIRST";
(slice, ()) ~skip_bits(slice s, int len) asm "SDSKIPFIRST";
```

Возвращает все, кроме первого «0 ≤ len ≤ 1023» бит «s».

#### первые биты

```func
slice first_bits(slice s, int len) asm "SDCUTFIRST";
```

Возвращает первые `0 ≤ len ≤ 1023` бит s\`.

#### пропустить_last_bits

```func
slice skip_last_bits(slice s, int len) asm "SDSKIPLAST";
(slice, ()) ~skip_last_bits(slice s, int len) asm "SDSKIPLAST";
```

Возвращает все, кроме последнего `0 ≤ len ≤ 1023` бит s\`.

#### кусок_последний

```func
slice slice_last(slice s, int len) asm "SDCUTLAST";
```

Возвращает последние `0 ≤ len ≤ 1023` бит s\`.

#### _выставить

```func
(slice, cell) load_dict(slice s) asm( -> 1 0) "LDDICT";
```

Загружает словарь `D` из маски `s`. Может быть применено к словарям или к значениям произвольного типа `возможно ^Y` (возвращает `null`, если используется конструктор `nothing`).

#### предвыгрузка

```func
клеток preload_dict(slice s) asm "PLDDICT";
```

Предзагружает словарь `D` из маски `s`.

#### про_диктировать

```func
кусочек skip_dict(кусочки) зазор "SKIPDICT";
```

Загружает словарь как `load_dict`, но возвращает только оставшуюся часть маски.

### Примитивы размера маски

#### slice_refs

```func
int slice_refs(Slice s) asm "SREFS";
```

Возвращает количество ссылок в кузнице \`.

#### кусок_биты

```func
int slice_bits(slice s) asm "SBITS";
```

Возвращает количество битов в маске 's'.

#### slice_bits_refs

```func
(int, int) slice_bits_refs(slice s) asm "SBITREFS";
```

Возвращает как количество битов данных, так и количество ссылок в s\`.

#### slice_empty?

```func
int slice_empty?(Slice s) asm "SEMPTY";
```

Проверяет, является ли маска 's' пустой (например, нет битов данных и ссылок на ячейки).

#### slice_data_empty?

```func
int slice_data_empty?(Slice s) asm "SDEMPTY";
```

Проверяет, не содержит ли кусочек данных бит.

#### slice_refs_empty?

```func
int slice_refs_empty?(Slice s) asm "SREMPTY";
```

Проверяет, не имеет ли название 's' ссылок.

#### кусок_глубина

```func
int slice_depth(slice s) asm "SDEPTH";
```

Возвращает глубину маски `s`. Если у `s` нет ссылок, то возвращает `0`; в противном случае возвращаемое значение равно одному плюс максимальную глубину ячеек, указанных из `s`.

## Примитивы строителя

Говорят, что primitive _stores_ значение `x` в конструктор `b`, если он возвращает измененную версию конструктора `b'` со значением `x`, сохраненным в конце его. Он может использоваться в качестве [немодифицирующего метода](/v3/documentation/smart-contracts/func/docs/statements#non-modifying-methods).

Все перечисленные ниже примитивы проверяют наличие достаточного места в `builder`первом, а затем диапазона сериализации.

#### начала_ячейка

```func
builder begin_cell() asm "NEWC";
```

Создает новый пустой `builder`.

#### конец ячейки

```func
ячейка end_cell(builder b) asm "ENDC";
```

Преобразует `builder` в обычную `cell`.

#### магазин_реф

```func
конструктор store_ref(builder b, ячейка c) asm(c b) "STREF";
```

Сохраняет ссылку на ячейку `c` в встроенный `b`.

#### _построитьuint

```func
builder store_uint(builder b, int x, int len) asm(x b len) "STUX";
```

Запоминает незнакомое число `len`-bit `x` в `b` для `0 ≤ len ≤ 256`.

#### магазин_инт

```func
builder store_int(builder b, int x, int len) asm(x b len) "STIX";
```

Запоминает подписанный `len`-bit integer `x` в `b` для `0 ≤ len ≤ 257`.

#### сохранить кусочек

```func
builder store_slice(builder b, ломтик) asm "STSLICER";
```

Сохраняет кусочек `s` в встроенный `b`.

#### хранить граммы

```func
builder store_grams(builder b, int x) asm "STGRAMS";
```

#### store_coins

```func
builder store_coins(builder b, int x) asm "STGRAMS";
```

Магазин (сериализация) целого числа `x` в диапазоне `0..2^120 - 1` во встроенный `b`. Сериализация `x` состоит из 4-битного unsigned big-endian integer `l`, который является наименьшим целым числом `l ≥ 0`, типа `x < 2^8l`, за которым следует `8l`-bit unsigned big-endian представление `x`. Если `x` не принадлежит поддерживаемому диапазону, выбрасывается проверяемое исключение.

Это самый распространенный способ хранения Тонкоинов.

#### выставить

```func
builder store_dict(builder b, cell c) asm(c b) "STDICT";
```

Сохраняет словарь `D` в виде ячейки `c` или `null` в встроенном файле `b`. Другими словами, хранит `1`-bit и ссылку на `c`, если `c` не является `null` и `0`-bit иначе.

#### сохранить_может быть_ссылки

```func
builder store_maybe_ref(builder b, cell c) asm(c b) "STOPTREF";
```

Эквивалент `store_dict`.

### Примитивы строителя

#### конструктор_реф

```func
int builder_refs(builder b) asm "BREFS";
```

Возвращает количество ссылок на ячейку, уже сохраненных в строителе `b`.

#### конструктор_биты

```func
int builder_bits(builder b) asm "BBITS";
```

Возвращает количество бит данных, уже сохраненных в builder `b`.

#### конструктор_глубина

```func
int builder_depth(builder b) asm "BDEPTH";
```

Возвращает глубину строителя `b`. Если ссылки на ячейку не хранятся в `b`, то возвращает `0`; в противном случае возвращаемое значение является единицей плюс максимальная глубина ячеек, указанных из «b».

## Примитивы ячейки

#### глубина ячейки

```func
int cell_depth(cell c) asm "CDEPTH";
```

Возвращает глубину ячейки `c`. Если у `c` нет ссылок, тогда возвращайте `0`; в противном случае возвращаемое значение равно одному плюс максимальную глубину ячеек из `c`. Если `c` является `null` вместо ячейки, то он возвращает ноль.

#### ячейка_null?

```func
int cell_null?(клетка c) ось "ISNULL";
```

Проверяет, является ли `c` `null`. Обычно ячейка `null`-cell представляет собой пустой словарь. У FunC также есть встроенный полиморфический `null?`. (See [built-ins](/v3/documentation/smart-contracts/func/docs/builtins#other-primitives).)

## Примитивы словарей

:::caution
Примитивы словаря ниже являются низкоуровневыми и не проверяют правильность структуры ячейки, к которой они применяются, соответствует сигнатуре операции. Применение операции по словарю в "не-словаре" или применение операции, соответствующей длине или знаку одного ключа в словаре с другим видом ключей, например одновременная запись в один словарь ключей с 8битным знаком и 7бит-неподписанным ключом **Неопределенное поведение**. Часто в таких случаях исключение бросается, но в редких случаях неправильное значение может быть написано / прочитано. Разработчикам настоятельно рекомендуется избегать такого кода.
:::

Как сказано в [TVM.pdf](https://ton.org/tvm.pdf):

> Словарь допускает два различных представления в виде стека TVM:
>
> - Кусочек `s` с сериализацией значения TL-B типа `HashmapE(n, X)`. Другими словами, `s` состоит из одного бита, равного нулю (если словарь пуст) или одного бита, равного одному и ссылки на ячейку, содержащую корень двоичного дерева, i. ., сериализованное значение типа «Hashmap(n, X)».
> - “Может быть ячейка” `c^?`, т.е. значение, которое является либо ячейкой (содержащей сериализованное значение типа "Hashmap(n, X)`как раньше) или`null`(соответствующий пустой словарь, cf. [null значения](/v3/documentation/smart-contracts/func/docs/types#null-values)). Когда используется`c^?`для обозначения словаря`может быть ячейка` `c^?`, обычно это означает `D\`.
>
> Большинство примитивов словаря, перечисленных ниже, принимают и возвращают словари во второй форме, что более удобно при манипуляции стеком. Тем не менее, сериализованные словари внутри более крупных TL-B объектов используют первое представление.

В словарях FunC также представлен тип «cell» с явным предположением, что это может быть значение «null». Для словарей с разными форматами ключей или значениями нет отдельного типа (в конце концов, это FunC, а не FunC++).

### Примечание таксономии

Словарь primitive может интерпретировать ключи словаря как неподписанные `l`-bit integers, как подписанные `l`-bit integers, или как `l`-bit slices. Примитивы, перечисленные ниже, отличаются префиксом перед словом `dict` в их именах. `i` означает подписанные целые ключи, `u` означает неподписанные целые ключи, а пустой префикс означает маскированные ключи.

Например, `udict_set` является функцией set-by-key для словарей с незнакомыми целыми ключами; `idict_set` — это соответствующая функция для словарей с подписанными целыми ключами; `dict_set` — функция для словарей с клавишами маски.

В заголовках используется пустой префикс.

Кроме того, некоторые примитивы имеют свои аналоги префикса `~`. Можно использовать их в качестве [модификации методов](/v3/documentation/smart-contracts/func/docs/statements#modifying-methods).

### Значения словаря

Значения внутри словаря могут храниться как подписка внутри внутренней словарной ячейки, либо со ссылкой на отдельную ячейку. В предыдущем сценарии не уверен, что ценность, которая достаточно мала, чтобы вместить в ячейку, также будет вписываться в словарь, как часть внутреннего пространства клетки может быть уже занята соответствующей частью. И наоборот, последний метод хранения менее эффективен с точки зрения использования газа. Сохранение значения с помощью второго метода является равным вставке кусочек без битов данных и единая ссылка на значение в первом методе.

#### набор дикторов

```func
cell udict_set(ячейка, int key_len, int index, slice value) asm(value index dict key_len) "DICTUSET";
ячейка idict_set(ячейка, int key_len, int index, slice value) asm(value dict key_len) "DICTISET";
ячейка dict_set(ячейка, int key_len, индекс массы, значение массы) asm(значение dict key_len) "DICTSET";
(cell, ()) ~udict_set(ячейка, int key_len, int index, slice value) asm(value index dict key_len) "DICTUSET";
(cell, ()) ~idict_set(ячейка, int key_len, int index, slice value) asm(value index dict key_len) "DICTISET";
(cell, ()) ~dict_set(ячейка, int key_len, slice index, slice value) asm(value index dict key_len) "DICTSET";
```

Устанавливает значение, связанное с `key_len`-bit ключом `index` в словаре `dict` в `value` (slice) и возвращает результирующий словарь.

#### диктов_набор

```func
ячейка idict_set_ref(клетка, int key_len, int index, cell value) asm(value dict key_len) "DICTISETREF";
ячейка udict_set_ref(ячейка, int key_len, int index, ячейка) asm(значение dict key_len) "DICTUSETREF";
(cell, ()) ~idict_set_ref(ячейка, int key_len, int index, cell value) asm(value index dict key_len) "DICTISETREF";
(cell, ()) ~udict_set_ref(ячейка, int key_len, int index, cell value) asm(value index dict key_len) "DICTUSETREF";
```

Аналогично `dict_set`, но с параметром установлено значение `value`.

#### dict_get?

```func
(slice, int) idict_get?(ячейка, int key_len, int index) asm(индекс dict key_len) "DICTIGET" "NULLSWAPIFNOT";
(slice, int) udict_get? ячейка dict, int key_len, int index) asm(index dict key_len) "DICTUGET" "NULLSWAPIFNOT";
```

Поиск ключа `index` в словаре `dict`, который использует ключи битов `key_len`. Если получится успешно, оно возвращает соответствующее значение в виде «slice» и возвращает значение флага «-1», указывающее на **успех**. Если поиск не удался, он возвращает `(null, 0)​`.

#### dict_get_ref?

```func
(клетка, int) idict_get_ref?(ячейка, int key_len, int index) asm(index dict key_len) "DICTIGETREF";
(клетка, int) udict_get_ref?(ячейка, int key_len, int index) asm(индекс dict key_len) "DICTUGETREF";
```

Подобно `dict_get?`, но возвращает первую ссылку на найденное значение.

#### dict_get_ref

```func
ячейка idict_get_ref(ячейка, int key_len, int index) asm(индекс dict key_len) "DICTIGETOPTREF";
```

Вариант `dict_get_ref?`, который возвращает `null` вместо значения, если ключ `index` отсутствует из словаря `dict`.

#### dict_set_get_ref

```func
(ячейка, ячейка) idict_set_get_ref(ячейка, int key_len, int index, cell value) asm(value index dict key_len) "DICTISETGETOPTREF";
(ячейка, ячейка) udict_set_get_ref(ячейка, int key_len, int index, ячейка) asm(показатель индекса dict key_len) "DICTUSETGETOPTREF";
```

Устанавливает значение, связанное с `index` в `value` (если `value` `null`, , то ключ удаляется) и возвращает старое значение (или «null», если значение отсутствует).

#### dict_delete?

```func
(клетка, int) idict_delete?(ячейка, int key_len, int index) asm(index dict key_len) "DICTIDEL";
(ячейка, int) udict_delete?(ячейка, int key_len, int index) asm(индекс dict key_len) "DICTUDEL";
```

Удаляет `key_len`-bit `index` из словаря `dict`. При наличии ключа возвращает измененный словарь 'dict'' и флаг успеха `−1`. В противном случае, возвращает исходный словарь `dict` и `0`.

#### dict_delete_get?

```func
(cell, slice, int) idict_delete_get?(ячейка, int key_len, int index) asm(index dict key_len) "DICTIDELGET" "NULLSWAPIFNOT";
(ячейка, slice, int) udict_delete_get? ячейка dict, int key_len, int index) asm(index dict key_len) "DICTUDELGET" "NULLSWAPIFNOT";
(ячейка, (slice, int)) ~idict_delete_get? ячейка dict, int key_len, int index) asm(index dict key_len) "DICTIDELGET" "NULLSWAPIFNOT";
(ячейка, (slice, int)) ~udict_delete_get? ячейка dict, int key_len, int index) asm(index dict key_len) "DICTUDELGET" "NULLSWAPIFNOT";
```

Удаляет `key_len`-bit `index` из словаря `dict`. При наличии ключа возвращает измененный словарь `dict`, исходное значение `x`, связанное с ключом k (представленным слоем) и успешным флагом `−1`. В противном случае, возвращает `(dict, null, 0)`.

#### dict_add?

```func
(cell, int) udict_add?(ячейка dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTUADD";
(cell, int) idict_add? ячейка, int key_len, int index, slice value) asm(value index dict key_len) "DICTIADD";
```

`add` аналог `dict_set` устанавливает значение, связанное с ключом `index` в словаре `dict` на `value`, но только если он уже не присутствует в `D`. Возвращает модифицированную версию словаря и флага `-1` или `(dict, 0)`.

#### dict_replace?

```func
(ячейка, int) udict_replace?(ячейка dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTUREPLACE";
(ячейка, int) idict_replace? ячейка, int key_len, int index, slice value) asm(value index dict key_len) "DICTIREPLACE";
```

Операция `replace` похожа на `dict_set`, но которая устанавливает значение ключа `index` в словаре `dict` на `value` только если ключ уже присутствовал в `dict`. Возвращает модифицированную версию словаря и флага `-1` или `(dict, 0)`.

### Компоненты строителя

Следующие примитивы принимают новое значение в качестве строителя вместо маски, , который часто более удобен, если значение должно быть сериализовано из нескольких компонентов, вычисленных в стеке. Чистый эффект примерно эквивалентен преобразованию b в кусок и выполнению указанного выше соответствующего примитивного эффекта.

#### диктов_построитель

```func
ячейка udict_set_builder(ячейка, int key_len, int index, builder value) asm(value dict key_len) "DICTUSETB";
ячейка idict_set_builder(ячейка, int key_len, int index, значение строителя) asm(значение dict key_len) "DICTISETB";
ячейка dict_set_builder(ячейка dict, int key_len, индекс массы, значение строителя) asm(значение dict key_len) "DICTSETB";
(cell, ()) ~idict_set_builder(ячейка, int key_len, int index, builder value) asm(value index dict key_len) "DICTISETB";
(cell, ()) ~udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTUSETB";
(cell, ()) ~dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) "DICTSETB";
```

Подобно `dict_set`, но принимает конструктор.

#### dict_add_builder?

```func
(ячейка, int) udict_add_builder?(ячейка, int key_len, int index, builder value) asm(value index dict key_len) "DICTUADDB";
(ячейка, int) idict_add_builder? ячейка, int key_len, int index, builder value) asm(value index dict key_len) "DICTIADDB";
```

Подобно `dict_add?`, но принимает конструктор.

#### dict_replace_builder?

```func
(cell, int) udict_replace_builder?(ячейка, int key_len, int index, builder value) asm(value index dict key_len) "DICTUREPLACEB";
(ячейка, int) idict_replace_builder? ячейка, int key_len, int index, builder value) asm(value index dict key_len) "DICTIREPLACEB";
```

Подобно `dict_replace?`, но принимает конструктор.

#### dict_delete_get_min

```func
(ячейка, int, slice, int) udict_delete_get_min(ячейка, int key_len) asm(-> 0 2 1 3) "DICTUREMMIN" "NULLSWAPIFNOT2";
(ячейка, int, slice, int) idict_delete_get_min(ячейка, int key_len) asm(-> 0 2 1 3) "DICTIREMMIN" "NULLSWAPIFNOT2";
(ячейка, кусок, кусок, int) dict_delete_get_min(ячейка, int key_len) asm(-> 0 2 1 3) "DICTREMMIN" "NULLSWAPIFNOT2";
(ячейка, (int, slice, int)) ~idict::delete_get_min(ячейка, int key_len) asm(-> 0 2 1 3) "DICTIREMMIN" "NULLSWAPIFNOT2";
(cell, (int, slice, int)) ~udict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) "DICTUREMMIN" "NULLSWAPIFNOT2";
(ячейка, (slice, slice, int)) ~dict::delete_get_min(ячейка, int key_len) asm(-> 0 2 1 3) "DICTREMMIN" "NULLSWAPIFNOT2";
```

Вычисляет минимальный ключ `k` в словаре `dict`, удаляет его и возвращает `(dict', k, x, -1)`, где `dict'` является модифицированной версией `dict` и `x` — это значение, связанное с `k`. Если dict пуст, возвращает `(dict, null, null, 0)`.

Обратите внимание, что возвращаемый ключ `idict_delete_get_min` может отличаться от ключа, возвращаемого `dict_delete_get_min` и `udict_delete_get_min`.

#### dict_delete_get_max

```func
(ячейка, int, slice, int) udict_delete_get_max(ячейка, int key_len) asm(-> 0 2 1 3) "DICTUREMMAX" "NULLSWAPIFNOT2";
(ячейка, int, slice, int) idict_delete_get_max(ячейка, int key_len) asm(-> 0 2 1 3) "DICTIREMMAX" "NULLSWAPIFNOT2";
(ячейка, кусок, кусок, int) dict_delete_get_max(ячейка, int key_len) asm(-> 0 2 1 3) "DICTREMMAX" "NULLSWAPIFNOT2";
(ячейка, (int, slice, int)) ~udict::delete_get_max(ячейка, int key_len) asm(-> 0 2 1 3) "DICTUREMMAX" "NULLSWAPIFNOT2";
(ячейка, (int, slice, int)) ~idict::delete_get_max(ячейка, int key_len) asm(-> 0 2 1 3) "DICTIREMMAX" "NULLSWAPIFNOT2";
(ячейка, (slice, slice, int)) ~dict::delete_get_max(ячейка, int key_len) asm(-> 0 2 1 3) "DICTREMMAX" "NULLSWAPIFNOT2";
```

Вычисляет максимальный ключ `k` в словаре `dict`, удаляет его и возвращает `(dict', k, x, -1)`, где `dict'` является модифицированной версией `dict` и `x` — это значение, связанное с `k`. Если dict пуст, возвращает `(dict, null, null, 0)`.

#### dict_get_min?

```func
(int, slice, int) udict_get_min?(ячейка, int key_len) asm (-> 1 0 2) "DICTUMIN" "NULLSWAPIFNOT2";
(int, slice, int) idict_get_min? ячейка, int key_len) asm (-> 1 0 2) "DICTIMIN" "NULLSWAPIFNOT2";
```

Вычисляет минимальный ключ `k` в словаре `dict`, соответствующее значение `x` и возвращает `(k, x, -1)`. Если словарь пуст, возвращает `(null, null, 0)`.

#### dict_get_max?

```func
(int, slice, int) udict_get_max?(ячейка, int key_len) asm (-> 1 0 2) "DICTUMAX" "NULLSWAPIFNOT2";
(int, slice, int) idict_get_max? ячейка, int key_len) asm (-> 1 0 2) "DICTIMAX" "NULLSWAPIFNOT2";
```

Вычисляет максимальный ключ `k` в словаре `dict`, соответствующее значение `x` и возвращает `(k, x, -1)`. Если словарь пуст, возвращает `(null, null, 0)`.

#### dict_get_min_ref?

```func
(int, cell, int) udict_get_min_ref?(ячейка, int key_len) asm (-> 1 0 2) "DICTUMINREF" "NULLSWAPIFNOT2";
(int, ячейка, int) idict_get_min_ref? ячейка, int key_len) asm (-> 1 0 2) "DICTIMINREF" "NULLSWAPIFNOT2";
```

Подобно `dict_get_min?`, но возвращает только ссылку в качестве ссылки.

#### dict_get_max_ref?

```func
(int, cell, int) udict_get_max_ref?(ячейка, int key_len) asm (-> 1 0 2) "DICTUMAXREF" "NULLSWAPIFNOT2";
(int, cell, int) idict_get_max_ref? ячейка, int key_len) asm (-> 1 0 2) "DICTIMAXREF" "NULLSWAPIFNOT2";
```

Подобно `dict_get_max?`, но возвращает только ссылку в качестве ссылки.

#### dict_get_next?

```func
(int, slice, int) udict_get_next?(ячейка, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTUGETNEXT" "NULLSWAPIFNOT2";
(int, slice, int) idict_get_next? ячейка, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTIGETNEXT" "NULLSWAPIFNOT2";
```

Вычисляет минимальный ключ `k` в словаре `dict`, превышающий `pivot`; возвращает `k`, соответствующее значение и флаг, указывающий на успех. Если словарь пуст, возвращает `(null, null, 0)`.

#### dict_get_nexteq?

```func
(int, slice, int) udict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTUGETNEXTEQ" "NULLSWAPIFNOT2";
(int, slice, int) idict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTIGETNEXTEQ" "NULLSWAPIFNOT2";
```

Аналогично `dict_get_next?`, но вычисляет минимальный ключ `k`, который больше или равен `pivot`.

#### dict_get_prev?

```func
(int, slice, int) udict_get_prev?(ячейка, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTUGETPREV" "NULLSWAPIFNOT2";
(int, slice, int) idict_get_prev? ячейка, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTIGETPREV" "NULLSWAPIFNOT2";
```

Аналогично `dict_get_next?`, но вычисляет максимальный ключ `k` меньше, чем `pivot`.

#### dict_get_preveq?

```func
(int, slice, int) udict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTUGETPREVEQ" "NULLSWAPIFNOT2";
(int, slice, int) idict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTIGETPREVEQ" "NULLSWAPIFNOT2";
```

Аналогично `dict_get_prev?`, но вычисляет максимальный ключ `k` меньше или равен `pivot`.

#### new_dict

```func
ячейка new_dict() asm "NEWDICT";
```

Создает пустой словарь, который на самом деле является значением `null`. Особый случай «null()».

#### диктов_пустой?

```func
int dict_empty?(cell c) asm "DICTEMPTY";
```

Проверяет, является ли словарь пустым. Эквивалент `cell_null?`.

## Префикс примитивов для словарей

TVM также поддерживает словари с нефиксированными ключами длины, которые образуют префиксный код (например, нет ключа, который является префиксом к другому ключею). Узнайте больше о них в разделе [Инструкция по TVM](/v3/documentation/tvm/tvm-overview).

#### pfxdict_get?

```func
(slice, slice, slice, int) pfxdict_get?(cell dict, int key_len, slice key) asm(key dict key_len) "PFXDICTGETQ" "NULLSWAPIFNOT2";
```

Возвращает `(s', x, s'', -1)` или `(null, null, s, 0)`.
Выглядит уникальный префикс `key` маски в префиксном коде `dict`. Если найдено, префикс «s» возвращается как «s» и соответствующее значение (также slice) как «x». Оставшаяся часть 's' возвращается как 's''. Если префикс `s` не является ключом в префикс-коде словаря `dict`, он возвращает неизменный `s` и нулевой флаг для указания на ошибку.

#### pfxdict_set?

```func
(cell, int) pfxdict_set?(ячейка dict, int key_len, slice key, slice value) asm(value key dict key_len) "PFXDICTSET";
```

Подобно `dict_set`, но может быть не выполнен, если ключ является префиксом другого ключа, представленного в словаре. Указание успеха, возвращает флаг.

#### pfxdict_delete?

```func
(cell, int) pfxdict_delete?(cell dict, int key_len, slice key) asm(key dict key_len) "PFXDICTDEL";
```

Похоже на `dict_delete?`.

## Специальные примитивы

#### пустой

```func
forall X -> X null() asm "PUSHNULL";
```

По типу TVM «Null» FunC означает отсутствие значения какого-либо атомарного типа. Поэтому `null` на самом деле может иметь любой атомарный тип.

#### ~impure_touch

```func
forall X -> (X, ()) ~impure_touch(X x) возмущение "NOP";
```

Отметьте используемую переменную, чтобы произведенный код не удалялся, даже если он не накладывался. (с.f. [impure specifier](/v3/documentation/smart-contracts/func/docs/functions#impure-specifier))

## Другие примитивы

#### мин

```func
int min(int x, int y) asm "MIN";
```

Вычисляет минимум из двух целых чисел «x» и «y».

#### макс

```func
int max(int x, int y) ось "MAX";
```

Вычисляет максимум два целых числа «x» и «y».

#### minmax

```func
(int, int) minmax(int x, int y) asm "MINMAX";
```

Сортирует два целых числа.

#### abs

```func
int abs(int x) ось "ABS";
```

Вычисляет абсолютное значение целого числа `x`.
