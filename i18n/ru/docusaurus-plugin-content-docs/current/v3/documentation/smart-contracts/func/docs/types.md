# Типы

:::info

Документация FunC была первоначально написана [@akifoq](https://github.com/akifoq).

:::

У FunC есть следующие встроенные типы.

## Атомные типы

- `int` - это 257-битные числовые знаки. По умолчанию, проверки переполнения включены и приводят к целочисленному переполнению исключений.
- `cell` - это тип камер TVM. Все данные в TON Blockchain хранятся в деревьях клеток. Каждая ячейка имеет до 1023 бит произвольных данных и до четырех ссылок на другие ячейки. Ячейки служат памятью в телевизорах на основе стека.
- `slice` - это разновидность клеточных масок. Ген может быть преобразован в ломтик, а затем данные и ссылки на другие ячейки из ячейки можно получить, загрузив их из ломтика.
- `builder` - это тип клеток строителей. Биты и ссылки на другие ячейки могут храниться в конструкторе, а затем конструктор может быть завершен в новую ячейку.
- «трубка» - это тип трубки TVM. Tuple - это упорядоченная коллекция до 255 компонентов с произвольными типами значений, которые, возможно, отличаются друг от друга.
- `cont` - это продолжение TVM. Продолжение используется для управления потоком выполнения программы TVM. Это довольно низкий объект с точки зрения FunC, хотя и парадоксально довольно общий.

Обратите внимание, что любой из вышеуказанных типов занимает только одну запись в стеке TVM.

### Отсутствие логического типа

В FunC булевы представлены числовыми значениями; `false` представлен как `0` и `true` представлен как `-1` (257 единиц в двоичном нотах). Логические операции выполняются как побитные операции. Когда отмечено условие, каждое не-нулевое целое считается значением «true».

### Null значения

По значению 'null' типа TVM 'Null' FunC означает отсутствие значения какого-либо атомарного типа. Некоторые примитивы из стандартной библиотеки могут быть введены как те, которые возвращают атомарный тип и в некоторых случаях возвращают `null`. Другие могут быть набраны как единицы, исключающие значение атомарного типа, но хорошо работают и с значениями `null`. Такое поведение явно указано в описании примитивной спецификации. По умолчанию значения `null` запрещены и приводят к run-time исключению.

Таким образом, атомный тип `A` может быть имплицитно преобразован в тип `A^?` a.k.a. `Может быть А` (проверка типов агностична к такому преобразованию).

## Тип отверстия

Функция FunC поддерживает ввод типа. Типы `_` и `var` представляют тип "дырки", который позже может быть заполнен реальным типом во время проверки типа. Например, `var x = 2;` — это определение переменной `x` равное `2`. Тип чекера может означать, что `x` имеет тип `int`, потому что `2` имеет тип `int`, и левая и правая стороны назначения должны иметь одинаковые типы.

## Композитные типы

Виды могут быть составлены в более сложные.

### Функциональный тип

Типы формы `A -> B` представляют функции с указанным доменом и codomain. Например, `int -> cell` является типом функции, которая принимает один целочисленный аргумент и возвращает ячейку TVM.

Во внутреннем плане значения таких типов представлены как продолжения.

### Типы датчиков

Типы формы «(A, B, ...)» представляют по сути упорядоченные коллекции значений типов «A», «B», «B». .\`, который все вместе занимает более одного стека ТВМ.

Например, если функция `foo` имеет тип `int -> (int, int)`, это означает, что функция занимает одно целое число и возвращает пару из них.

Вызов этой функции может выглядеть как `(int a, int b) = foo(42);`. Во внутреннем плане функция потребляет одну запись в стеке и оставляет две из них.

Обратите внимание, что из ракурса низкого уровня значение «(2, (3, 9))» типа «(int, (int, int))» и значения «(2, 3, 9)`типа`(int, int, int)`представлен таким же образом, как и три записи стека`2`, `3`и`9`. Для чекера типа FunC это значения **различных** типов. Например, код `(int a, int b, int c) = (2, (3, 9));\` не компилируется.

Особый случай растяжения — это **тип единицы** `()`. Обычно он используется для обозначения того факта, что функция не возвращает никакого значения или не имеет аргументов. Например, функция `print_int` будет иметь тип `int -> ()`, а функция `random` имеет тип `() -> int`. Уникальный житель «()», занимающий 0 записей.

Тип формы '(A)' рассматривается по типу чекера как тот же тип, что и 'A'.

### Типы трюков

Типы формы «[A, B, ...]» представляют ТВМ трубки с определенной длиной и типом компонентов, известных во времени компиляции. Например, `[int, cell]` - тип ТВМ трубки, длина которой ровно 2, , где первый компонент является целым числом, а второй - ячейкой. `[]` - это тип пустых труб (единственного жителя – пустой трубочки). Обратите внимание, что в отличие от типа единиц `()`, значение `[]` занимает одну запись в стеке.

## Полиморфизм с переменными типа

В FunC имеется система типа Miller-Rabin с поддержкой полиморфических функций. Например, следующая функция:

```func
forall X -> (X, X) duplicate(X value) {
  return (value, value);
}
```

является функцией полиморфии, которая принимает значение (одна строка стека) и возвращает две копии этого значения. `duplicate(6)` будет выводить значения `6 6`, а `duplicate([])` будет выводиться две копии `[] []` пустой трубочки.

В этом примере «X» — это переменная типа.

See more info on this topic in the [functions](/v3/documentation/smart-contracts/func/docs/functions#polymorphism-with-forall) section.

## Определенные пользователем типы

В настоящее время FunC не поддерживает определение типов, за исключением конструкций, описанных выше.

## Ширина типа

Как вы могли заметить, каждое значение типа занимает некоторое количество записей. Если это одно и то же число для всех значений типа, то это число называется **тип ширины**. В настоящее время полиморфические функции могут определяться только для типов с фиксированными и известными в предварительном типе шириной.
