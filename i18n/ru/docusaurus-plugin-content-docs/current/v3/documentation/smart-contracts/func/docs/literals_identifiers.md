# Литературы и идентификаторы

## Числовые знаки

FunC позволяет десятичным и шестнадцатеричным числовым буквам (разрешены ведущие нули).

Например, `0`, `123`, `-17`, `00987`, `0xef`, `0xEF`, `0x0`, `-0xfFAb`, `0x0001`, `-0`, `-0x0` — допустимые числовые знаки.

## String literals

Строки в FunC цитируются в двойных кавычках \`\`, как `это строка`. Специальные символы, такие как `\nи многострочные строки, не поддерживаются.
Необязательно, строковые литералы могут указывать тип после них, например `"string"u\`.

Поддерживаются следующие типы строк:

- без типа - используется для определения функций asm и для определения узла узла по ASCII строке
- `s`- определяет сырую часть конста по его содержимому (hex-encoded и опционально bit-padded)
- `a` - создает кост, содержащий структуру `MsgAddressInt` из указанного адреса
- `u` - создает int const, который соответствует шестнадцатеричным значениям предоставленной ASCII строки
- `h`— создает int const - это первые 32 биты SHA256 хеша строки
- H\`—создает int const, который составляет все 256 бит хеша SHA256
- `c` - создает int const значение crc32 строки

Например, следующие значения в соответствующих константах:

- `"string"` становится \`x{737472696e67}кусочеком
- `"abcdef"s` становится `x{abcdef}` ломтиком
- `"Ef8zMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM0vF"a` становится `x{9FE6666666666666666666666666666666666666666666666666666666666666667_}`const (`addr_std$10 anycast:none$0 workchain_id:int8=0xFF address:bits256=0x33...33`)
- `NstK"u` становится `0x4e73744b` int const
- `"transfer(slice, int)"h` становится `0x7a62e8a8` int const
- `"transfer(slice, int)"H` становится `0x7a62e8a8ebac41bd6de16c65e7be363bc2d2cbc6a0873778dead4795c13db979` int const
- `"transfer(slice, int)"c` становится `2235694568` int const

## Идентификаторы

Функция позволяет очень широкий класс идентификаторов (функций и имен переменных). В частности, любая (однострочная) строка, не содержащая специальных символов `;`, `, `(`, `)`, `, `, `, `, ` (пробел или таб), `~` и `. , не запускается как комментарий или строковый литерал (с ``), не является числовым буквами, не подчеркивание `_` и не ключевое слово является допустимым идентификатором (с единственным исключением, если оно начинается с `` `, он должен заканчиваться тем же `и не может содержать каких-либо других` \`, кроме этих двух).

Также, имена функций в определениях функций могут начинаться с `.` или `~`.

Например, это допустимые идентификаторы:

- `запрос`, `query'`, `query''`
- `elem0`, `elem1`, `elem2`
- `CHECK`
- `_internal_value`
- `message_found?`
- `get_pubkeys&signatures`
- `dict::udict_set_builder`
- `_+_` (стандартный оператор добавок типа `(int, int) -> int` в нотации префикса, хотя он уже определен)
- `fatal!`

`'` в конце имени переменной обычно используется при вводе некоторых измененных версий старого значения. Например, почти все модификации встроенных примитивов для манипуляций с хэшпаном (за исключением префикса `~`) принимают хэшкарту и возвращают новую версию хэшкарты вместе с некоторыми другими данными, при необходимости. Удобно называть эти значения одним и тем же именем, суффиксом «».

Суффикс `? обычно используется для логических переменных (TVM не имеет встроенного була типа; bools представлены целыми числами: 0 - false и -1 - истинно), или для функций, которые возвращают некоторые флаги, обычно указывает на успех операции (например, `udict_get? от [stdlib.fc](/v3/documentation/smart-contracts/func/docs/stdlib)).

Это недопустимые идентификаторы:

- `take(first)Entry`
- `"not_a_string`
- `msg.sender`
- `send_message,then_terminate`
- `_`

Другие редкие примеры допустимых идентификаторов:

- `123validname`
- `2+2=2*2`
- `-alsovalidname`
- `0xefefefhahaha`
- \`{hehehe}
- \`\`pa{--}в"\`aaa\`\`\`

Это также недопустимые идентификаторы:

- \`\`pa;;in"`aaa``` (потому что `;\` запрещен)
- \`{-aaa-}
- `aa(bb`
- `123` (это число)

Кроме того, у FunC есть специальный тип идентификаторов, которые цитируются в обратных кавычках ` `.
В кавычках допускаются любые символы, кроме «\n» и самих кавычек.

Например, `«Я тоже переменная» является допустимым идентификатором, а также` «любые символы; ~ () разрешены здесь...»

## Константы

FunC позволяет определить скомпилированные константы, которые подставляются и прекалируются во время компиляции.

Константы определяются как «const optional-type identifier = value-or-expression;»

`opal-type` может быть использован для принудительного применения определенного типа константы и для лучшей читаемости.

На данный момент поддерживаются типы `int` и `slice`.

`value-or-expression` может быть буквальным или предварительно вычислительным выражением литералов и констант.

Например, константы могут определяться следующим образом:

- `const int101 = 101;` определяет константу `int101` эквивалентной числовой букве `101`
- `const str1 = "константа 1", str2 = "aabbcc"s;` определяет две константы, равные соответствующим строкам
- `const int int240 = (int1 + int2) * 10) << 3;` определяет константу `int240`, которая равняется результату вычисления
- `const slice str2r = str2;` определяет константу `str2r`, равную значению константы `str2`

Поскольку во время компиляции заменяются числовые константы, все выполненные в процессе компиляции оптимизации и предварительные вычисления успешно выполняются (в отличие от старого метода определения констант через встроенный asm `PUSHINT`).
