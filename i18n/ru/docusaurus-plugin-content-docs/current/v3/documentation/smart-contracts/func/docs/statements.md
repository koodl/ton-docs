# Заявления

В этом разделе кратко рассматриваются заявления FunC, составляющие кодекс обычных функциональных органов.

## Выражения

Наиболее распространенным типом выписки является заявление выражения. Это выражение после `;`. Описание выражения будет достаточно сложным, поэтому здесь представлен только эскиз. Как правило, все субвыражения вычисляются слева направо, за исключением [перестановки стека asm](/v3/documentation/smart-contracts/func/docs/functions#rearranging-stack-entries), которые могут определять порядок вручную.

### Объявление переменной

Невозможно объявить локальную переменную без определения ее начального значения.

Вот несколько примеров декларирования переменных:

```func
int x = 2;
var x = 2;
(int, int) p = (1, 2);
(int, var) p = (1, 2);
(int, int, int) (x, y, z) = (1, 2, 3);
(int x, int y, int z) = (1, 2, 3);
var (x, y, z) = (1, 2, 3);
(int x = 1, int y = 2, int z = 3);
[int, int, int] [x, y, z] = [1, 2, 3];
[int x, int y, int z] = [1, 2, 3];
var [x, y, z] = [1, 2, 3];
```

Переменная может быть "переобъявлено" в той же области. Например, это правильный код:

```func
int x = 2;
int y = x + 1;
int x = 3;
```

На самом деле, второе вхождение `int x` является не декларацией, а лишь компилируемым страхованием времени, которое у `x` есть тип `int`. Таким образом, третья строка по сути эквивалентна простому присвоению `x = 3;`.

В вложенных областях переменная может быть по-настоящему перезаявлена так же, как и в языке С. Например, рассмотреть код:

```func
int x = 0;
int i = 0;
while (i < 10) {
  (int, int) x = (i, i + 1);
  ;; здесь x - переменная типа (int, int)
  i += 1;
}
;; здесь x - (иная) переменная типа int
```

Однако, как указано в глобальных переменных [section](/v3/documentation/smart-contracts/func/docs/global_variables) глобальная переменная не может быть объявлена.

Обратите внимание, что объявление переменной **является** оператором выражения, поэтому конструкции, такие как `int x = 2`, являются полноценными выражениями. Например, это правильный код:

```func
int y = (int x = 3) + 1;
```

Это определение двух переменных `x` и `y` равное `3` и `4` соответственно.

#### Подчёркивание

Подчёркивание `_` используется, когда значение не требуется. Например, предположим, что функция `foo` имеет тип `int -> (int, int, int)`. Мы можем получить первое возвращаемое значение и проигнорировать второе и третье так:

```func
(int fst, _) = фун(42);
```

### Приложение функции

Вызов функции выглядит как таковой в обычном языке. Аргументы вызова функции перечислены после имени функции, разделённого запятыми.

```func
;; suppose foo имеет тип (int, int, int) -> int
int x = foo(1, 2, 3);
```

Но обратите внимание, что `foo` на самом деле является функцией **one** аргумента типа `(int, int, int)`. Чтобы увидеть разницу, предположим, что `bar` является функцией типа `int -> (int, int, int)`. В отличие от обычных языков, вы можете составить следующие функции:

```func
int x = foo(bar(42));
```

вместо похожной, но более длинной формы:

```func
(int a, int b, int c) = bar(42);
int x = foo(a, b, c);
```

Также возможны звонки в стиле Haskell, но не всегда (будет исправлено позднее):

```func
;; suppose foo имеет тип int -> int -> int -> int
;; т.е. is carried
(int a, int b, int c) = (1, 2, 3);
int x = foo a b c; ;; ok
;; int y = foo 1 2 3; не компилировать
int y = foo (1) (2) (3); ;; Ok
```

### Выражения Lambda

Выражения Lambda пока не поддерживаются.

### Методы вызовов

#### Неизменяемые методы

Если у функции есть хотя бы один аргумент, то она может быть вызвана как метод немодификации. Например, у `store_uint` есть тип `(builder, int, int) -> builder` (второй аргумент должен храниться, а третий — битовая длина). `begin_cell` - это функция, создающая нового конструктора. Следующие коды эквивалентны:

```func
строитель b = begin_cell();
b = store_uint(b, 239, 8);
```

```func
builder b = begin_cell();
b = b.store_uint(239, 8);
```

Таким образом, первый аргумент функции может быть передан ей перед именем функции, если она разделена `.`. Код можно дополнительно упростить:

```func
builder b = begin_cell().store_uint(239, 8);
```

Возможны также несколько вызовов методов:

```func
builder b = begin_cell().store_uint(239, 8)
                        .store_int(-1, 16)
                        .store_uint(0xff, 10);
```

#### Изменение методов

Если первый аргумент функции имеет тип «A», а возвращаемое значение функции имеет форму «(A, B)`, где `B`- некоторый произвольный тип, то функция может быть вызвана в качестве модификационного метода. Изменение вызовов метода может принять некоторые аргументы и вернуть некоторые значения, но они изменяют их первый аргумент, то есть назначить первую часть возвращаемого значения переменной из первого аргумента. Например, предположим, что`cs`является частью ячейки, а`load_uint`имеет тип`(slice, int) -> (slice, int)\`: требуется кусочек ячеек и количество битов для загрузки и возвращает оставшуюся часть маски и загруженное значение. Следующие коды эквивалентны:

```func
сс, int x) = load_uint(сs, 8);
```

```func
сс, int x) = cs.load_uint(8);
```

```func
int x = cs~load_uint(8);
```

В некоторых случаях мы хотим использовать функцию в качестве модификационного метода, который не возвращает ни одно значение и только изменяет первый аргумент. Это может быть сделано с помощью типов единиц следующим образом: Предположим, мы хотим определить функцию `inc` типа `int -> int`, , который увеличивает целое число, и использовать его в качестве модификационного метода. Затем мы должны определить «inc» как функцию типа «int -> (int, ()»:

```func
(int, ()) inc(int x) {
  return (x + 1, ());
}
```

При таком определении он может быть использован в качестве модификационного метода. Ниже будет прибавлено значение `x`.

```func
x~inc();
```

#### `.` и `~` в именах функций

Предположим, мы хотим использовать «inc» в качестве немодифицирующего метода. Мы можем написать что-то вроде следующего:

```func
(int y, _) = inc(x);
```

Но можно переопределить определение «inc» как модификационный метод.

```func
int inc(int x) {
  return x + 1;
}
(int, ()) ~inc(int x) {
  return (x + 1, ());
}
```

А затем именуйте это так:

```func
x~inc();
int y = inc(x);
int z = x.inc();
```

Первый вызов будет модифицировать x; второй и третий не будут.

Короче говоря, когда функция с именем «foo» называется методом немодификации или изменения (i). с синтаксисом `.foo` или `~foo`), компилятор FunC использует определение `. oo` или `~foo` соответственно, если такое определение представлено, а если нет, то оно использует определение `foo`.

### Операторы

Обратите внимание, что в настоящее время все unary и двоичные операторы являются целочисленными операторами. Логические операторы представлены как побитные целочисленные операторы (см. [отсутствие логического типа](/v3/documentation/smart-contracts/func/docs/types#absence-of-boolean-type)).

#### Операторы Unary

Существует два унитарных оператора:

- `~` побито не (приоритет 75)
- `-` является целым отрицанием (приоритет 20)

Они должны быть отделены от аргумента:

- `- x` в порядке.
- `-x` не подходит (это один идентификатор)

#### Двоичные операторы

С приоритетом 30 (левая ассоциация):

- `*` — умножение целого числа
- `/` — целое деление (этаж)
- `~/` — целое деление (округл)
- `^/` — целое деление (потолк)
- `%` — целое сокращение на modulo (этаж)
- `~%` — целое сокращение на modulo (округл)
- `^%` — сокращение целого числа на modulo (потолк)
- `/%` возвращает частный, а остаток
- `&` побито И

С приоритетом 20 (левая ассоциация):

- `+` — целочисленное дополнение
- `-` — вычитание целого числа
- `|` побито ИЛИ
- `^` — это битум XOR

С приоритетом 17 (левая ассоциация):

- `<<` побито левый сдвиг
- `>>` — это побитый правый сдвиг
- `~>>` — правый битрейный сдвиг (раунд)
- `^>>` — это побитовый правый сдвиг (поток)

С приоритетом 15 (левая ассоциация):

- `==` это целочисленная проверка равенства
- `!=` это целочисленное неравенство
- `<` — сравнение целого числа
- `<=` — числовое сравнение
- `>` — это сравнение целого числа
- `>=` — числовое сравнение
- `<=>` является целочисленным сравнением (возвращает -1, 0 или 1)

Они также должны быть отделены от этого аргумента:

- `x + y` нормально
- `x+y` не в состоянии (это один идентификатор)

#### Условный оператор

Он имеет обычный синтаксис.

```func
<condition> ? <consequence> : <alternative>
```

Например:

```func
x > 0 ? x * fac(x - 1) : 1;
```

Она имеет приоритет 13.

#### Задания

Приоритет 10.

Простое назначение `=` и аналогов бинарных операций: `+=`, `-=`, `*=`, `/=`, `~/=`, `^/=`, `%=`, `~%=`, `^%=`, `<=`, `>=`, `~>=`, `^>>=`, `^>=`, `&=`, `|=`, `^=`.

## Циклы

FunC поддерживает `repeat`, `while`, и `do { ... } циклов until. Цикл `for\` не поддерживается.

### Повторить цикл

Синтаксис — это ключевое слово «повторить», за которым следует выражение типа «int». Повторяет код за указанное количество раз. Примеры:

```func
int x = 1;
repeat(10) {
  x *= 2;
}
;; x = 1024
```

```func
int x = 1, y = 10;
repeat(y + 6) {
  x *= 2;
}
;; x = 65536
```

```func
int x = 1;
repeat(-1) {
  x *= 2;
}
;; x = 1
```

Если количество раз меньше `-2^31` или больше `2^31 - 1`, то проверяется исключение диапазона.

### Цикл "пока"

Имеет обычный синтаксис. Например:

```func
int x = 2;
в то время как (x < 100) {
  x = x * x;
}
;; x = 256
```

Заметим, что значение истины условия `x < 100` является типом `int` (см. [отсутствие логического типа](/v3/documentation/smart-contracts/func/docs/types#absence-of-boolean-type)).

### До цикла

Имеет следующий синтаксис:

```func
int x = 0;
do {
  x += 3;
} до (x % 17 == 0);
;; x = 51
```

## Операторы если

Примеры:

```func
;; обычно, если
if (flag) {
  do_something();
}
```

```func
;; эквивалент if (~ flag)
ifnot (flag) {
  do_something();
}
```

```func
;; usual if-else
if (flag) {
  do_something();
}
else {
  do_alternative();
}
```

```func
;; Некоторые специфические функции
if (flag1) {
  do_something1();
} else {
  do_alternative4();
}
```

Необходимы фигурные скобки. Этот код не будет скомпилирован:

```func
если (flag1)
  do_something();
```

## Пытаться уловить заявления

_Доступно в func начиная с версии 0.4.0_

Выполняет код в блоке `try`. Если это не удалось, полностью откатится изменения, внесенные в блок «try» и вместо этого выполняет блок «catch»; `catch` получает два аргумента: параметр исключения любого типа (`x`) и код ошибки (`n`, integer).

В отличие от многих других языков в заявлении FunC о попытке вылова, изменения, внесенные в блоке try block, в частности, изменения локальных и глобальных переменных, все изменения регистров (т.е. `c4` регистр хранения, `c5` action/message register, Контекстный регистр `c7` и другие) **удаляются** если в блоке try есть ошибка, и поэтому все обновления хранилища контракта и отправка сообщений будут отменены. Важно отметить, что некоторые параметры состояния TVM, такие как _codepage_ и счетчики газов не будут откатиться. Это означает, в частности, что будет учтено весь газ, израсходованный в блоке проверки, и будут сохранены эффекты OP, изменяющих лимит газа (`accept_message` и `set_gas_limit`).

Обратите внимание, что параметр исключения может иметь любой тип (возможно другой в случае различных исключений) и поэтому funC не может предсказать его на время компиляции. Это означает, что разработчику нужно "помочь" компилятору путем наложения параметра исключения к какому-либо типу (см. Пример 2 ниже):

Примеры:

```func
try {
  do_something();
} catch (x, n) {
  handle_exception();
}
```

```func
forall X -> int cast_to_int(X x) asm "NOP";
...
try {
  throw_arg(-1, 100);
} catch (x, n) {
  x. ast_to_int();
  ;; x = -1, n = 100
  return x + 1;
}
```

```func
int x = 0;
try {
  x += 1;
  бросок (100);
} catch (_, _) {
}
;; x = 0 (не 1)
```

## Выписки блока

Также разрешены операторы блоков. Они открывают новую вложенную область:

```func
int x = 1;
builder b = begin_cell();
{
  builder x = begin_cell(). tore_uint(0, 8);
  b = x;
}
x = 1;
```
