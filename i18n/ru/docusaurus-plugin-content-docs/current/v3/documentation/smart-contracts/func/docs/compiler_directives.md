# Директивы компилятора

Это ключевые слова, начинающиеся с `#` и указывающие компилятору выполнять некоторые действия, проверять или изменять параметры.

Эти директивы можно использовать только на самом верхнем уровне (не внутри любого определения функции).

## #включать

Директива `#include` позволяет включить другой исходный код FunC, который будет обработан вместо include.

Синтаксис `#include "filename.fc";`. Файлы автоматически проверяются на повторную интеграцию и при попытке включить
файл более одного раза будет проигнорирован по умолчанию, с предупреждением, если уровень громкости не ниже 2.

Если возникла ошибка во время разбора входящего файла, то дополнительно, стек включения печатается с местоположением
каждого включенного файла в цепочке.

## #pragma

Директива `#pragma` используется для предоставления компилятору дополнительной информации, помимо того, что сам язык передается.

### #pragma версия

Версия pragma используется для обеспечения конкретной версии компилятора FunC при компиляции файла.

Версия указана в формате semver, то есть _a.b. _, где _a_ — основная версия, _b_ — младший, а _c_ — патч.

Существует несколько операторов сравнения для разработчиков:

- _a.b.c_ или _=a.b.c_— требует точно _a.b.c_ версии компилятора
- _>a.b.c_—требуется версия компилятора больше чем _a.b.c_,
  - _>=a.b.c_—требует, чтобы версия компилятора была больше или равна _a.b.c_
- _\<a.b.c_— требует меньшую версию компилятора чем _a.b.c_,
  - _\<=a.b.c_— требует, чтобы версия компилятора была меньше или равна _a.b.c_
- _^a.b.c_—требует, чтобы основная версия компилятора была равна части 'a', а младшая часть должна быть не ниже 'b',
  - _^a.b_—требует, чтобы основная версия компилятора была равной _a_ части и младше не менее _b_ части
  - _^a_—требует, чтобы основная версия компилятора не была меньше _a_

Для других операторов сравнения (_=_, _>_, _>=_, _\<_, _\<=_) короткий формат предполагает нули в пропущенных частях:

- _>a.b_ то же самое, что и _>a.b.0_ (поэтому не соответствует версии _a.b.0_)
- _\<=a_ то же самое, что и _\<=a.0.0_ (поэтому не соответствует _a.0.1_ версии)
- _^a.b.0_ это **НЕ** то же самое, что и _^a.b_

Например, _^a.1.2_ совпадает с _a.1.3_ но не _a.2.3_ или _a.1.0_, однако, _^a.1_ совпадает со всеми.

Эта директива может использоваться несколько раз; версия компилятора должна соответствовать всем установленным условиям.

### #pragma неверсия

Синтаксис этой прагмы такой же, как и прагма версии, но не удается, если условие удовлетворено.

Он может быть использован для черного списка конкретной версии, известной, например, с проблемами.

### #pragma allow-post-modification

_funC v0.4.1_

По умолчанию запрещается использовать переменную до ее модификации в том же выражении. Другими словами, выражение `(x, y) = (ds, ds~load_uint(8))` не компилируется, а `(x, y) = (ds~load_uint(8), ds)` верно.

Это правило может быть перезаписано `#pragma allow-post-modification`, которые позволяют изменять переменную после использования при массовых назначениях и вызове функций; как обычные подвыражения будут вычисляться слева направо: `(x, y) = (ds, ds~load_bits(8))` приведет к `x`, содержащий первоначальный `ds`; Первый аргумент `f(ds, ds~load_bits(8))` будет содержать начальный `ds`, а второй - 8 бит `ds`.

`#pragma allow-post-modification` работает только для кода после прагмы.

### #прагма compute-asm-ltr

_funC v0.4.1_

Объявления Asm могут перезаписывать порядок аргументов, например, в следующем выражении

```func
idict_set_ref(ds~load_dict(), ds~load_uint(8), ds~load_uint(256), ds~load_ref())
```

порядок парсинга будет следующим: `load_ref()`, `load_uint(256)`, `load_dict()` и `load_uint(8)` из-за следующего объявления asm (примечание `asm(value index dict key_len)`):

```func
ячейка idict_set_ref(клетка, int key_len, int index, cell value) asm(value dict key_len) "DICTISETREF";
```

Это поведение можно изменить на строгую левую на правую последовательность вычислений через `#pragma compute-asm-ltr`

В результате

```func
#pragma compute-asm-ltr
...
idict_set_ref(ds~load_dict(), ds~load_uint(8), ds~load_uint(256), ds~load_ref());
```

порядок разбора будет `load_dict()`, `load_uint(8)`, `load_uint(256)`, `load_ref()` и вся перестановка asm произойдет после вычисления.

`#pragma compute-asm-ltr` работает только для кода после прагмы.
