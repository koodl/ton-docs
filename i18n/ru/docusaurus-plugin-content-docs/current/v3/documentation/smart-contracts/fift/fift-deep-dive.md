# Fift deep dive

Для локальных манипуляций с клетками и другими примитивами ТВМ используется высокоуровневый стек языковой "Fif", для преобразования кода сборки ТВМ в пакетный пакет клеток.

:::caution
Этот раздел описывает взаимодействие с особенностями TON на **очень** низком уровне.
Серьезное понимание основ стека языков.
:::

## Простая арифметика

Вы можете использовать интерпретатор Fift в качестве калькулятора, записывая в выражениях [обратная польская нотация](https://en.wikipedia.org/wiki/Reverse_Polish_notation).

```
6 17 17 * * 289 + .
2023 ok
```

## Стандартный выход

```
27 излучает ."[30;1mgrey текст" 27 излучает ."[37m"
серый текст ОК
```

`emit` принимает номер сверху стека и печатает символ Unicode с указанным кодом в stdout.
`."..."` выводит постоянную строку.

## Определение функций (Фифтовые слова)

Основной способ определения слова - заключить его в фигурные скобки, затем написать имя `:` и слово `:`.

```
{ minmax drop } : мин
{ minmax nip } : макс.
```

> Fift.fif

Однако существует несколько _определяющих слов_, а не только `:`. Смысл этих слов не совпадает с **активными** (работа в фигурных скобках), а некоторые - **префикс** (после них не требуют пробела):

```
{ bl word 1 2 ' (create) } "::" 1 (create)
{ bl word 0 2 ' (create) } :: :
{ bl word 2 ' (create) } :: :_
{ bl word 3 2 ' (create) } :: :_
{ bl word 0 (create) } : create
```

> Fift.fif

## Условное исполнение

Блоки кода (разделенные фигурными скобками) могут быть выполнены либо условно, либо безоговорочно.

```
{ { ."true " } { ."false " } cond } : ?. 4 5 = ?. 4 5 < ?.
false true ok
{ ."Привет" } выполнить ."world"
hello world ok
```

## Циклы

```
// ( l c -- l') удаляет первые с элементов из списка l
{ ' safe-cdr swap times } : list-delete-first
```

> GetOpt.fif

Циклическое слово `times` принимает два аргумента - давайте назовем их `cont` и `n` - выполняем `cont` `n` раз.
Здесь `list-delete-first` принимает продолжение `safe-cdr` (удаляя заголовок из Lisp-style list), ставит его под `c`, а затем `c` раз удаляет головы из списка присутствующих на стеке.

Есть также слова `while` и `until`.

## Комментарии

```
{ 0 word drop 0 'nop } :: //
{ char " word 1 { swap { abort } if drop } ::_ abort"
{ { bl word dup "" $= abort"comment extends after end of file" "*/" $= } until 0 'nop } :: /*
```

> Fift.fif

Комментарии определяются в разделе 'Fift.fif'. Коммент с одной строкой начинается с `//` и продолжается до конца строки; многострочный комментарий начинается с `/*` и заканчивается символом `*/`.

Давайте поймем, почему они так работают.\
Fift program is a program that allows you to translate words from English into Russian and from English into Russian. Первая строка `Fift.fif` (код, показанный выше) является объявлением нового слова `//`.
Комментарии должны работать даже при определении новых слов, поэтому они должны работать в вложенной среде. Поэтому они определяются как **активные** слова, используя `:`. Действия создаваемого слова перечислены в фигурных скобках:

1. `0`: ноль выталкивается в стек
2. `word`: эта команда читает символы до тех пор, пока не будет достигнута одна равная началу стека и не будет загружена данные, прочитанные как строка. Особый случай — здесь «слово» пропускает ведущие пробелы, а затем читает до конца текущей строки ввода.
3. `drop`: верхний элемент (данные комментариев) удаляется из стека.
4. `0`: ноль снова вставляется в стек - количество результатов, используется, потому что слово определяется с помощью `::`.
5. `'nop` толкает токен выполнения ничего не делая при вызове. Это почти эквивалентно `{ nop }`.

## Использование Fift для определения кодов сборки ТВМ

```
x{00} @Defop NOP
{ 1 ' @addop создает } : @Defop
{ tuck sbitrefs @ensurebitrefs swap s, } : @addop
{ @havebitrefs ' @| ifnot } : @ensurebitrefs
{ 2 pick brembitrefs 1- 2x<= } : @havebitrefs
{ rot >= -rot <= and } : 2x<=
...
```

> Asm.fif (обратный порядок строк)

`@Defop` проверяет, достаточно ли свободного места для opcode (`@havebitrefs`), и если нет, то он идет на запись другому строителю (`@|`; также известный как неявный прыжок). Поэтому вы обычно не хотите писать `x{A988} с как опкод: может быть недостаточно места для размещения этого опкода, поэтому компиляция не удалась; вместо этого напишите `x{A988} @addop\`.

Вы можете использовать Fift для включения в контракт сумки больших ячеек:

```
<b 8 4 u, 8 4 u, "fift/blob.boc" file>B B>boc ref, b> <s @Defop LDBLOB
```

Эта команда определяет опкод, который при включении в программу записывает `x{88}` (`PUSHREF`) и ссылку на предоставленные ячейки. Таким образом, когда берутся инструкция «LDBLOB», она толкает клетку в стек TVM.

## Особые функции

- Ed25519 криптография
  - newkeypair - генерирует пару частных и публичных ключей
  - priv>pub - генерирует открытый ключ из частного
  - ed25519_sign[_uint] - генерирует данные о подписи и приватный ключ
  - ed25519_chksign     - checks Ed25519 signature
- Взаимодействие с TVM
  - runvmcode и подобный - вызывает TVM с кодовым фрагментом взятым из стека
- Запись BOC в файлы:
  `boc>B ".../contract.boc" B>file`

## Продолжить обучение

- [Пятью: Краткое введение](https://docs.ton.org/fiftbase.pdf) от Nikolai Durov
