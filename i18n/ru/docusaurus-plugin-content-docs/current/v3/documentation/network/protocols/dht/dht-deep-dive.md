# DHT

DHT означает распределенную хэш-таблицу и по существу является распределенной базой данных ключевой стоимости,
где каждый участник сети может хранить что-то, например, информацию о себе.

Реализация DHT в TON по своей сути похожа на реализацию [Kademlia](https://codethechange.stanford.edu/guides/guide_kademlia.html), которая используется в IPFS.
Любой сетевой участник может запустить узел DHT, создавать ключи и хранить данные.
Для этого ему необходимо сгенерировать случайный идентификатор и сообщить другим узлам о себе.

Чтобы определить, какой узел хранить данные, алгоритм используется для определения «расстояния» между узлом и ключом.
Алгоритм прост: мы принимаем ID узла и ID ключа, выполняем операцию XOR. Чем меньше значение, тем ближе узел.
Задача состоит в том, чтобы сохранить ключ на узлах как можно ближе к ключу, чтобы другие участники сети могли используя
тот же алгоритм, найдите узел, который может дать данные на этот ключ.

## Поиск значения по ключу

Давайте рассмотрим пример с поиском ключа, [подключитесь к любому узлу DHT и установите соединение через ADNL UDP](/v3/documentation/network/protocols/adnl/adnl-udp#packet-structure-and-communication).

Например, мы хотим найти адрес и публичный ключ для подключения к узлу, на котором хост foundation.ton.
Допустим, мы уже получили ADNL адрес этого сайта, выполнив метод DNS договора.
Адрес ADNL в шестнадцатеричном представлении является `516618cf6cbe9004f6883e742c9a2e3ca53ed02e3e36f4cef62a98ee1e449174`.
Теперь наша цель состоит в том, чтобы найти ip, порт и публичный ключ узла, который имеет этот адрес.

Для этого нам нужно получить идентификатор ключа DHT, сначала мы заполним схему ключей DHT:

```tlb
dht.key id:int256 имя:байты idx:int = dht.Key
```

`name` - это тип ключа, для ADNL адресов используется слово `address` и, например, для поиска узлов на шардинге - `nodes`. Но тип ключа может быть любым массивом байт, в зависимости от значения, которое вы ищете.

Заполнение этой схемы, мы получим:

```
8fde67f6 -- TL ID dht. ey
516618cf6cbe9004f6883e742c9a2e3ca53ed02e3e36f4cef62a98ee1e449174 -- наш поиск ADNL адреса
07 61646472657373 -- тип ключа, слово "address" как TL массив байт
00000000 -- индекс 0, потому что только 1 ключ
```

Далее - получить идентификатор ключа, хеш sha256 из сериализованных выше байт. Будет `b30af0538916421b46df4ce580bf3a29316831e0c3323a7f156df0236c5b2f75`

Теперь мы можем начать поиск. Для этого нам нужно выполнить запрос, который содержит [schema](https://github.com/ton-blockchain/ton/blob/ad736c6bc3c06ad54dc6e40d62acbaf5dae41584/tl/generate/scheme/ton_api.tl#L197):

```tlb
dht.findValue key:int256 k:int = dht.ValueResult
```

`key` - идентификатор ключа DHT, а `k` - это "ширина" поиска, чем меньше он есть, тем точнее, но меньше потенциальных узлов для запроса. Максимальная k для узлов в TON - 10, обычно 6 используется.

Давайте заполним эту структуру, сериализуем и отправим запрос, используя схему `adnl.message.query`. [Подробнее об этом можно прочитать в другой статье](/v3/documentation/network/protocols/adnl/adnl-udp#packet-structure-and-communication).

В ответ мы можем получить:

- `dht.valueNotFound` - если значение не найдено.
- `dht.valueFound` - если значение найдено на этом узле.

##### dht.valueНе найдено

Если мы получим `dht. alueNotFound`, ответ будет содержать список узлов, которые известны узлу, который мы запрашивали, и как можно ближе к ключу, который мы запросили из списка известных ему узлов. В этом случае нам нужно соединиться и добавить полученные узлы в список известных нам.
После этого из списка всех узлов, которые нам известны, выберите ближайший доступен и еще не запрошен, и сделать тот же запрос к нему. И так до тех пор, пока мы не попробуем все узлы в диапазоне, который мы выбрали, или до тех пор, пока мы не прекратим получать новые узлы.

Давайте более подробно проанализируем поля ответа, используемую схему:

```tlb
adnl.address.udp ip:int port:int = adnl.Address;
adnl.addressList addrs:(vector adnl.Address) version:int reinit_date:int priority:int expire_at:int = adnl.AddressList;

dht.node id:PublicKey addr_list:adnl.addressList version:int signature:bytes = dht.Node;
dht.nodes nodes:(vector dht.node) = dht.Nodes;

dht.valueNotFound nodes:dht.nodes = dht.ValueResult;
```

`dht.nodes -> nodes` - список узлов DHT (массив).

Каждый узел имеет публичный ключ `id`, обычно [pub.ed25519](https://github.com/ton-blockchain/ton/blob/ad736c6bc3c06ad54dc6e40d62acbaf5dae41584/tl/generate/scheme/ton_api.tl#L47), используемый в качестве ключа сервера для соединения с узлом через ADNL. Также каждый узел имеет список адресов `addr_list:adnl.addressList`, версии и подписи.

Нам нужно проверить подпись каждого узла, для этого мы читаем значение «signature» и устанавливаем поле «zero (мы делаем пустой массив байтов). После - мы сериализируем структуру TL `dht.node` пустой подписью и проверьте поле `signature`, которое было перед пустым.
Мы проверяем полученные сериализованные байты, используя открытый ключ из поля `id`. [[Implementation example]](https://github.com/xssnick/tonutils-go/blob/46dbf5f820af066ab10c5639a508b4295e5aa0fb/adnl/dht/client.go#L91)

Из списка `addrs:(vector adnl. ddress)` мы принимаем адрес и пытаемся установить UDP соединение ADNL в качестве ключа сервера мы используем `id`, который является публичным ключом.

Чтобы найти "расстояние" к этому узлу - нам нужно взять [key id](/v3/documentation/network/protocols/adnl/adnl-tcp#getting-key-id) из поля `id` и проверить расстояние между действиями XOR с ключа узла и нужным ключом.
Если расстояние достаточно маленькое, мы можем сделать тот же запрос к этому узлу. И так что, пока мы не найдем значение или больше нет новых узлов.

##### dht.valueНайдено

Ответ будет содержать ценность, полную ключевую информацию и подпись (зависит от типа ценности).

Давайте более подробно проанализируем поля ответа, используемую схему:

```tlb
adnl.address.udp ip:int port:int = adnl.Address;
adnl.addressList addrs:(vector adnl.Address) version:int reinit_date:int priority:int expire_at:int = adnl. ddressList;

dht.key id:int256 name:bytes idx:int = dht.Key;

dht.updateRule.signature = dht.UpdateRule;
dht.updateRule.anybody = dht. pdateRule;
dht.updateRule.overlayNodes = dht.UpdateRule;

dht.keyDescription key:dht.key id:PublicKey update_rule:dht.UpdateRule signature:bytes = dht. eyDescription;

dht.value key:dht.keyDescription value:bytes ttl:int signature:bytes = dht.Value; 

dht.valueFound value:dht.Value = dht.ValueResult;
```

Сначала давайте проанализируем `key:dht.keyDescription`, это полное описание ключа, самого ключа и информации о том, кто и как можно обновить значение.

- `key:dht.key` - ключ должен совпадать с ключом, из которого мы взяли ID ключа для поиска.
- `id:PublicKey` - открытый ключ владельца записи.
- `update_rule:dht.UpdateRule` - правило обновления записей.
- - `dht.updateRule.signature` - только владелец закрытого ключа может обновить запись, `signature` ключа и значение должны быть действительными
- - `dht.updateRule.anybody` - все могут обновить запись, `signature` пуст и не отмечен
- - `dht.updateRule.overlayNodes` - узлы из одного и того же накладываемого могут обновить ключ, используемые для поиска узлов одного и того же наложения и добавления себя

###### dht.updateRule.signature

После прочтения описания ключа мы действуем в зависимости от `updateRule`, для запроса адреса ADNL тип всегда `dht.updateRule.signature`.
Мы проверяем подпись ключа таким же образом, как и в прошлый раз, сделаем подпись пустой массивом байтов, сериализацией и проверкой. После - мы повторяем то же самое для значения, то есть для всего объекта `dht.value` (при возвращении подписи ключа в место).

[[Implementation example]](https://github.com/xssnick/tonutils-go/blob/46dbf5f820af066ab10c5639a508b4295e5aa0fb/adnl/dht/client.go#L331)

###### dht.updateRule.overlayNodes

Используется для ключей, содержащих информацию о других узлах-шардах рабочей цепочки в сети, значение всегда имеет структуру TL `overlay.nodes`.
Значение должно быть пустым.

```tlb
overlay.node id:PublicKey overlay:int256 version:int signature:bytes = overlay.Node;
overlay.nodes nodes:(vector overlay.node) = overlay.Nodes;
```

Для проверки достоверности, мы должны проверить все узлы «узлы» и для каждого проверяющего «подпись» на его «id» сериализуя структуру TL:

```tlb
overlay.node.toSign id:adnl.id.short overlay:int256 version:int = overlay.node.ToSign;
```

Как видим, id должен быть заменен на adnl.id.short, который является ключом id (хэш) поля `id` из исходной структуры. После сериализации - мы проверяем подпись с данными.

В результате мы получим корректный список узлов, которые могут дать нам информацию о нужном шарде.

###### dht.updateRule.anybody

Нет подписей, каждый может обновить.

#### Использование значения

Когда все проверяется, а значение «ttl:int» не истекло, мы можем начать работать с самим значением, т.е. `value:bytes`. Для адреса ADNL должна быть структура `adnl.addressist` внутри.
Он будет содержать IP адреса и порты серверов, соответствующих запрошенному ADNL адресу. В нашем случае, скорее всего будет 1 RLDP-HTTP адрес сервиса `foundation.ton`.
Мы будем использовать открытый ключ `id:PublicKey` из информации о ключе DHT в качестве ключа сервера.

После установления соединения мы можем запросить страницы сайта по протоколу RLDP. Задача с стороны DHT на данном этапе завершена.

### Поиск узлов, в которых хранится состояние блокчейна

DHT также используется для поиска информации о узлах, которые хранят данные рабочих цепей и их шардов. Процесс такой же, как при поиске любого ключа, единственная разница в сериализации самого ключа и проверке ответа, мы проанализируем эти моменты в этом разделе.

Для получения данных, например, о шестеренке и ее осколках, нам необходимо заполнить структуру TL:

```
tonNode.shardPublicOverlayId workchain:int shard:long zero_state_file_hash:int256 = tonNode.ShardPublicOverlayId;
```

Где `workchain` в случае мастер-цепочки будет равен -1, его шард будет равен -922337203685477580 (0xFFFFFFFFFFFFFFFFFFFFFF), и `zero_state_file_hash` — хэш нулевого состояния цепи (file_hash), как и другие данные, его можно взять из глобальной конфигурации сети, в поле «валидатор»

```json
"zero_state": {
  "workchain": -1,
  "shard": -9223372036854775808, 
  "seqno": 0,
  "root_hash": "F6OpKZKqvqeFp6CQmFomXNMfMj2EnaUSOXN+Mh+wVWk=",
  "file_hash": "XplPz01CXAps5qeSWUtxcyBfdAo5zVb1N979KLSKD24="
}
```

После того, как мы заполнили `tonNode.shardPublicOverlayId`, мы сериализуем его и получаем от него ключ, хэшируя (как всегда).

Нам нужно использовать результирующий идентификатор ключа в качестве `name` для заполнения структуры `pub.overlay name:bytes = PublicKey`, обернув его в массив байтов TL. Далее мы сериализируем его, и теперь мы получаем ID ключа.

Результирующий идентификатор будет ключом для использования

```bash
dht.findValue
```

и значение поля `name` будет иметь слово `nodes`. Мы повторяем процесс из предыдущего раздела, все равно как и в прошлый раз, но `updateRule` будет [dht.updateRule.overlayNodes](#dhtupdateruleoverlaynodes).

После проверки - мы получим открытые ключи узлов с информацией о нашей рабочей цепочке и шарде. Для получения ADNL адресов узлов, мы должны сделать идентификаторы из ключей (используя метод хэширования) и повторить процедуру, описанную выше для каждого из адресов ADNL, как с адресом ADNL "foundation". домен.

В результате мы получим адреса узлов, из которых, если хотим, мы можем найти адреса других узлов этой цепочки, используя [overlay.getRandomPeers](https://github. om/ton-blockchain/ton/blob/ad736c6bc3c06ad54dc6e40d62acbaf5dae41584/tl/generate/scheme/ton_api.tl#L237).
Мы также сможем получать всю информацию о блоках с этих узлов.

## Справочная литература

_Здесь [ссылка на оригинальную статью](https://github.com/xssnick/ton-deep-doc/blob/master/DHT.md) от [Oleg Baranov](https://github.com/xssnick)._
