# Наложение подсетей

Осуществление:

- https://github.com/ton-blockchain/ton/tree/master/overlay

## Общий обзор

Архитектура TON построена таким образом, что множество цепей может существовать одновременно и независимо в ней - они могут быть как частными, так и публичными.
Узлы имеют возможность выбирать, какие осколки и цепочки они хранят и обрабатывают.
В то же время благодаря своей универсальности протокол по коммуникациям остается неизменным. Такие протоколы, как DHT, RLDP и Overlays позволяют это достичь.
Мы уже знакомы с первыми двуми, в этом разделе мы узнаем, что такое Накладываемое изображение.

Наслоения отвечают за деление одной сети на дополнительные подсети. Наслоения могут быть публичными, к которым каждый может подключаться, и приватными, где для входа необходимы дополнительные учетные данные, известно только определенному количеству людей.

Все цепочки TON, включая шедевры, общаются с помощью собственного наслоения.
Чтобы присоединиться к нему, вам нужно найти уже присутствующие в нем узлы и начать обмен данными с ними.
Для публичных наслоений вы можете найти узлы с помощью DHT.

## ADNL против сетей наслоений

In contrast to ADNL, the TON overlay networks usually do not support
sending datagrams to other arbitrary nodes. Вместо этого некоторые “полупостоянные
ссылки” устанавливаются между определенными узлами (называемыми “соседи” по отношению к
сети оверлеев, которые рассматриваются), и сообщения, как правило, пересылаются
по этим ссылкам (i. , от узла до одного из его соседей).

Каждая подсеть оверлея имеет 256-разрядный сетевой идентификатор, обычно равный
SHA256 описанию сети оверлеев – сериализованной TL.

Подсети наслоений могут быть публичными или приватными.

Подсети оверлея работают согласно специальному протоколу [gossip](https://en.wikipedia.org/wiki/Gossip_protocol).

## Взаимодействие с узлами оверлея

We have already analyzed an example with finding overlay nodes in an article about DHT,
in the section [Search for nodes that store the state of the blockchain](/v3/documentation/network/protocols/dht/dht-deep-dive#search-for-nodes-that-store-the-state-of-the-blockchain).
В этом разделе мы сосредоточимся на взаимодействии с ними.

При запросе DHT, мы получим адреса узлов накладываемого изображения, с которого мы можем найти адреса других узлов этого оверлея с помощью [overlay.getRandomPeers](https://github. om/ton-blockchain/ton/blob/ad736c6bc3c06ad54dc6e40d62acbaf5dae41584/tl/generate/scheme/ton_api.tl#L237) запрос.
Как только мы подключимся к достаточному количеству узлов, мы можем получать от них информацию обо всех блоках и другие события цепи, а также отправить нам наши транзакции для обработки.

### Найти соседей

Давайте рассмотрим пример получения узлов в накладываемом изображении.

Для этого отправьте запрос `overlay.getRandomPeers` на любой известный узел оверлея, сериализуйте схему TL:

```tlb
overlay.node id:PublicKey overlay:int256 version:int signature:bytes = overlay.Node;
overlay.nodes nodes:(vector overlay.node) = overlay.Nodes;

overlay.getRandomPeers peers:overlay.nodes = overlay.Nodes;
```

`peers` - должны содержать узлов, которых мы знаем, поэтому мы не возвращаем их назад, но поскольку мы пока не знаем ни одного узла, `пиров. odes` будет пустым массивом.

В случае, если мы хотим не просто получить некоторую информацию, а участвовать в оверлеи и получать трансляции, также следует добавить в `peers` информацию о нашем узле, из которого мы запрашиваем.
Когда пиры будут получать информацию о нас - они начнут отправлять нам трансляции с помощью ADNL или RLDP.

Каждый запрос внутри наслоения должен быть префиксом TL схемы:

```tlb
overlay.query overlay:int256 = True;
```

Поле «overlay» должно быть id накладываемого изображения - id «tonNode». hardPublicOverlayId\` ключ схемы - тот же самый ключ для поиска DHT.

Нам нужно совмещать сериализованные схемы сериализации 2 сериализованных массивов байтов, `overlay.query` сначала придет `overlay.getRandomPeers` сек.

Мы поместим результирующий массив в схеме `adnl.message.query` и отправим его через ADNL. В ответ мы ожидаем "наложения". odes\` - это список узлов, к которым мы можем подключаться и при необходимости повторять тот же самый запрос к новым из них, пока мы не получим достаточно соединений.

### Функциональные запросы

После установления соединения мы можем получить доступ к узлам накладываемого изображения с помощью [requests](https://github.com/ton-blockchain/ton/blob/ad736c6bc3c06ad54dc6e40d62acbaf5dae41584/tl/generate/scheme/ton_api.tl#L413) `tonNode.*`.

Для такого рода запросов используется протокол RLDP. И важно не забывать префикс `overlay.query` - он должен использоваться для каждого запроса в оверлее.

Нет ничего необычного в отношении самих запросов, они очень похожи на то, что мы [делали в статье о ADNL TCP](/v3/documentation/network/protocols/adnl/adnl-tcp#getmasterchaininfo).

Например, в запросе `downloadBlockFull` используется уже знакомый код блока:

```tlb
tonNode.downloadBlockFull block:tonNode.blockIdExt = tonNode.DataFull;
```

Пройдя его, мы сможем загрузить полную информацию о блоке, в ответ мы получим:

```tlb
tonNode.dataПолный id:tonNode.blockIdExt proof:bytes block:bytes is_link:Bool = tonNode.DataFull;
  или
tonNode.dataFullEmpty = tonNode.DataFull;
```

Если присутствует, поле `block` будет содержать данные в формате TL-B.

Таким образом, мы можем получать информацию непосредственно от узлов.

## Справочная литература

_Здесь [ссылка на оригинальную статью](https://github.com/xssnick/ton-deep-doc/blob/master/Overlay-Network.md) от [Oleg Baranov](https://github.com/xssnick)._
