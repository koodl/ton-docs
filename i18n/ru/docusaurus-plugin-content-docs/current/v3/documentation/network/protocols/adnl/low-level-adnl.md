# ADNL низкого уровня

Абстрактный сетевой слой датаграммы (ADNL) - это основной протокол TON, который помогает сетевым узлам общаться друг с другом.

## Личность узла

Каждый узел должен иметь хотя бы одну идентичность, возможно, но не обязательно использовать несколько. Каждая идентичность – это клавиша, которая используется для выполнения Diffie-Hellman между сверстниками. Из общего ключа получается абстрактный сетевой адрес: `address = SHA-256(type_id || public_key)`. Обратите внимание, что type_id должен быть сериализирован как little-endian uint32.

## Список криптосистем с открытым ключом

| type_id | криптосистема       |
| ---------------------------- | ------------------- |
| 0x4813b4c6                   | ed25519<sup>1</sup> |

_1. Для выполнения x25519, клавиатура должна генерироваться в формате x25519. Однако открытый ключ передается по сети в формате ed25519, так что вам нужно преобразовать открытый ключ из x25519 в ed25519, примеры таких преобразований можно найти [here](https://github. om/andreypfau/curve25519-kotlin/blob/f008dbc2c0ebc3ed6ca5d3251ffb7cf48edc91e2/src/commonMain/kotlin/curve25519/MontgomeryPoint.kt#L39) для Kotlin._

## Клиент-серверный протокол (ADNL через TCP)

Клиент подключается к серверу, используя TCP и посылает ADNL пакет рукопожатий, содержащий абстрактный адрес сервера, публичный ключ клиента и параметры сеанса AES-CTR, которые определяются клиентом.

### Handshake

Для начала клиент должен выполнить ключевой протокол договора (например, x25519), используя свой закрытый ключ и открытый ключ сервера с учетом `type_id` ключа сервера. В результате клиент получит `секретную`, который используется для шифрования сессионных ключей в будущих шагах.

Затем клиент должен генерировать параметры сеанса AES-CTR, 16-байтный ключ и 32-байтный ключ, Как для TX (client->server), так и для RX (server->client) и сериализуют его в 160-байтном буфере, следующим образом:

| Параметр                        | Размер   |
| ------------------------------- | -------- |
| rx_key     | 32 байта |
| tx_клавиша | 32 байта |
| rx_nonce   | 16 байт  |
| tx_nonce   | 16 байт  |
| padding                         | 64 байта |

Цель отступа неизвестна, она не используется реализациями сервера. Рекомендуется заполнять весь 160-байтный буфер случайными байтами, в противном случае атакующий может выполнить активную атаку, используя взломанные AES-CTR параметры.

Следующим шагом является шифрование параметров сеанса с помощью `secret` с помощью протокола с ключом соглашения выше. Для этого необходимо инициализировать AES-256 в режиме CTR с помощью 128-битного big-endian счетчика (ключ), nonce) пара, которая вычисляется как таковая (`aes_params` - это 160-байтный буфер, который был собран выше):

```cpp
хэш = SHA-256(aes_params)
ключ = секретный[0..16] || хэш[16..32]
nonce = хэш[0..4] || секретный[20..32]
```

После шифрования `aes_params`, отмеченного как `E(aes_params)`, необходимо удалить AES, так как он больше не требуется.

Теперь мы готовы сериализовать всю эту информацию на 256-байтный пакет рукопожатия и отправить её на сервер:

| Параметр                                                    | Размер   | Примечания                                                         |
| ----------------------------------------------------------- | -------- | ------------------------------------------------------------------ |
| адрес получателя                                            | 32 байта | Идентификация пиров сервера, как описано в соответствующем разделе |
| публичный отправитель                                       | 32 байта | Публичный ключ клиента                                             |
| SHA-256(aes_params) | 32 байта | Доказательство целостности параметров сеанса                       |
| E(aes_params)       | 160 байт | Параметры зашифрованного сеанса                                    |

Сервер должен расшифровать сессионные параметры с использованием секрета, полученного от ключевого соглашения таким же образом, как и клиент. Затем сервер должен выполнить следующие проверки для подтверждения свойств безопасности:

1. Сервер должен иметь соответствующий закрытый ключ для `receiver_address`, в противном случае нет способа выполнить протокол соглашения с ключом.
2. `SHA-256(aes_params) == SHA-256(D(E(aes_params))`, в противном случае протокол по ключевому соглашению потерпел неудачу и `secret` не совпадал с обеих сторон.

Если какая-либо из этих проверок не удается, сервер немедленно отключится от соединения без ответа на клиента. Если все проходит проверка, сервер должен выдать клиенту пустой датаграмм (см. раздел Датаграмма), чтобы доказать, что он владеет закрытым ключом для указанного `receiver_address`.

### Датаграмма

Как клиент, так и сервер должны инициализировать два AES-CTR экземпляра для TX и RX направлений. AES-256 должен использоваться в режиме CTR с 128-битным битным битным счетчиком. Каждый экземпляр AES инициализируется с помощью пары (ключ, nonce), принадлежащей ему, которая может быть взята из `aes_params` в рукопожатии.

Чтобы отправить датаграмму, пир (клиент или сервер) должен построить следующую структуру, зашифровать ее и отправить другому пиру:

| Параметр | Размер                          | Примечания                                                   |
| -------- | ------------------------------- | ------------------------------------------------------------ |
| длина    | 4 байта (LE) | Длина всей датаграммы, исключая поле «длина»                 |
| nonce    | 32 байта                        | Случайное значение                                           |
| буфер    | `длина - 64` байт               | Фактические данные для отправки на другую сторону            |
| хэш      | 32 байта                        | `SHA-256(nonce \\|\\| buffer)` для обеспечения целостности |

Вся структура должна быть зашифрована с помощью соответствующего экземпляра AES (TX для клиента -> сервера, RX для сервера -> клиента).

Узел получения должен получить первые 4 байта, расшифровать его в поле `length` и читать ровно `length` байт, чтобы получить полную датаграмму. Получающий узел может начать расшифровать и обрабатывать буфер раньше, но должен учитывать, что он может быть поврежден, умышленно или случайно. Датаграмма «хэш» должна быть проверена, чтобы обеспечить целостность буфера. В случае неудачи не могут быть выданы новые датаграммы и соединение должно быть прекращено.

Первый датаграмм в сеансе всегда направляется с сервера клиенту после того, как пакет рукопожатия был успешно принят сервером, и его фактический буфер пуст. Клиент должен расшифровать его и отключиться от сервера в случае сбоя, потому что это означает, что сервер не соблюдал должным образом протокол, а фактические ключи сеанса различаются на стороне сервера и клиента.

### Подробности связи

Если вы хотите погрузиться в подробности общения, вы можете посмотреть статью [ADNL TCP - Liteserver](/v3/documentation/network/protocols/adnl/adnl-tcp), чтобы увидеть некоторые примеры.

### Соображения безопасности

#### Handshake padding

Не известно, почему первоначальная команда TON решила включить это поле в рукопожатие. Целостность `aes_params` защищена хешем SHA-256, а конфиденциальность защищена ключом из параметра `secret`. Вероятно, он намеревался в какой-то момент мигрировать с AES-CTR. Для этого спецификация может быть расширена, чтобы включить специальное значение магии в `aes_params`, , который сообщит, что пир готов к использованию обновленных примитивов. Ответ на подобные рукопожатия можно расшифровать дважды с новыми и старыми схемами для уточнения того, какая схема используется другим пиром.

#### Процесс деривации ключа шифрования параметров сеанса

Если ключ шифрования получен только из параметра `secret`, он будет статичным, потому что секрет статичен. Чтобы получить новый ключ шифрования для каждой сессии, разработчики также используют `SHA-256(aes_params)`, что случайно, если `aes_params` является случайным. Однако фактический алгоритм деривации ключей с совмещением различных субмассивов считается вредным.

#### Датаграмма nonce

Не очевидно, почему поле 'nonce' в датаграмме присутствует, потому что даже без него, любые два шифра будут отличаться в зависимости от ограниченных сессий для AES и шифрования в режиме CTR. Тем не менее, следующая атака может быть осуществлена в случае отсутствия или предсказуемого отсутствия. Режим шифрования CTR превращает блочные шифры, такие как AES, в коды потока, чтобы сделать возможным выполнение побитового отражения. Если злоумышленник знает обычный текст, принадлежащий зашифрованным датаграммам, он может получить чистый поток ключей, XOR он со своим обычным текстом и эффективно заменяет сообщение, которое было отправлено пиром. Целостность буфера защищена хешем SHA-256, но злоумышленник тоже может заменить его, потому что знание полного текстового текста означает знание его хэша. Однажды поле присутствует для предотвращения такой атаки, поэтому ни один атакующий не может заменить SHA-256 без знания о нем.

## P2P protocol (ADNL over UDP)

Подробное описание находится в статье [ADNL UDP - Internode](/v3/documentation/network/protocols/adnl/adnl-udp).

## Справочная литература

- [Открытая сеть, стр. 80](https://ton.org/ton.pdf)
- [ADNL реализация в TON](https://github.com/ton-blockchain/ton/tree/master/adnl)

_Спасибо [hacker-volodya](https://github.com/hacker-volodya) за вклад в сообщество!_\
_Здесь [ссылка на оригинальную статью](https://github.com/tonstack/ton-docs/tree/main/ADNL) на GitHub._
